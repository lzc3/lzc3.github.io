<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>快捷键合集</title>
    <link href="/2025/05/09/%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%90%88%E9%9B%86/"/>
    <url>/2025/05/09/%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h3><h3 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h3><h5 id="换行后消除格式"><a href="#换行后消除格式" class="headerlink" title="换行后消除格式"></a>换行后消除格式</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">crtl</span> + [ <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>快捷键</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快捷键</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态代理</title>
    <link href="/2025/05/05/java/%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2025/05/05/java/%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>实现动态代理一般有两种形式，一种方式是通过jdk自带的动态代理实现，通过反射实现，只能对实现接口的类进行代理；另一种方式是通过CGLIB实现，其针对类进实现代理，对指定的类生成一个子类，覆盖其中的方法，不能代理final修饰的类。</p></blockquote><h3 id="jdk自带的动态代理"><a href="#jdk自带的动态代理" class="headerlink" title="jdk自带的动态代理"></a>jdk自带的动态代理</h3><p>先看一个例子</p><ul><li><p>首先，我们有一个接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">DoSomething</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>有一个类实现了该接口</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-title">implements</span> <span class="hljs-title">DoSomething</span> </span>&#123;<br><br>        <span class="hljs-variable">@Override</span><br>        public void doSomething() &#123;<br>            System.out.println(<span class="hljs-string">&quot;drive drive&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>在代码逻辑中，我们new了一个car对象，通过Proxy.newProxyInstance进行代理</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Proxy.newProxyInstance(car.getClass().getClassLoader(), car.getClass().getInterfaces(), <span class="hljs-built_in">new</span> InvocationHandler() &#123;<br>    @Override<br>    <span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> invoke(<span class="hljs-keyword">Object</span> proxy, <span class="hljs-keyword">Method</span> <span class="hljs-keyword">method</span>, <span class="hljs-keyword">Object</span>[] args) throws Throwable &#123;<br>        // 在调用方法前可以添加额外的逻辑<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Before method call.&quot;);<br><br>        // 调用实际对象的方法<br>        <span class="hljs-keyword">Object</span> result = <span class="hljs-keyword">method</span>.invoke(car, args);<br><br>        // 在调用方法后可以添加额外的逻辑<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;After method call.&quot;);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>动态代理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm</title>
    <link href="/2025/05/04/java/%E5%9F%BA%E7%A1%80/jvm/"/>
    <url>/2025/05/04/java/%E5%9F%BA%E7%A1%80/jvm/</url>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新中</p></blockquote><h5 id="jit-即时编译"><a href="#jit-即时编译" class="headerlink" title="jit 即时编译"></a>jit 即时编译</h5><h5 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h5><blockquote><p>栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等。</p><p>而堆只负责存储对象信息。</p></blockquote><ul><li><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据</p></li><li><p>堆解决的是数据存储的问题，即数据怎么放、放在哪儿</p></li></ul><p>为什么要把堆和栈区分？</p><ul><li>从设计的角度来看，栈代表了处理逻辑，而堆代表了数据，这样分开，处理逻辑更为清晰，分而治之的思想，这种隔离、模块化的思想在软件设计的方方面面都有体现。</li><li>堆和栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象），这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式（如共享内存），另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</li><li>栈因为运行时的需要，比如保存系统运行的上下文，需要对地址段划分，由于栈只能<strong>向上增长</strong>，因此就会<strong>限制</strong>住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</li><li>面向对象就是对合栈的完美结合。面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为，就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写了处理数据的逻辑。</li></ul><p>堆中存的是对象，栈中存的是基本数据类型和堆中对象的引用，大小为4byte。</p><p>为什么不把基本类型放在堆中？</p><p>​其占用的内存一般是1~8个字节，需要空间比较少，而且因为是基本类型，所以不会出现动态增长的清空，因此栈中存储就够了，如果把他存在堆中没有什么意义。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据，一个是堆中的数据。最常见的一个问题就是，java中参数传递的问题。</p><h5 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h5><p>按回收策略分类</p><ul><li><p>引用计数</p><ul><li>原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收<br>时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</li></ul></li><li><p>标记 清除</p><ul><li>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的<br>对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</li></ul></li><li><p>复制</p><ul><li>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在<br>使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制<br>过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两<br>倍内存空间。</li></ul></li><li><p>标记-整理</p><ul><li>此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引<br>用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此<br>算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题</li></ul></li></ul><p>按照分区对待的方式分</p><ul><li>增量搜集：实时垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么<br>原因JDK5.0中的收集器没有使用这种算法的。</li><li>分代收集：基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青<br>代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。</li></ul><p>按照系统线程分</p><ul><li>串行收集:串行收集使用单线程处理所有垃圾回收工作，因为无需多线程交互，实现容易，而且效率比较高。但是，其局限性也比较明显，即无法使用多处理器的优势，所以此收集适合单处理器机器。当然，此收集器也可以用在小数据量（100M左右）情况下的多处理器机器上。</li><li>并行收集:并行收集使用多线程处理垃圾回收工作，因而速度快，效率高。而且理论上CPU数目越多，越能体现出并行收集器的优势。</li><li>并发收集:相对于串行收集和并行收集而言，前面两个在进行垃圾回收工作时，需要暂停整个运行环境，而只有垃圾回收程序在运行，因此，系统在垃圾回收时会有明显的暂停，而且暂停时间会因为堆越大而越长。</li></ul><h5 id="为什么要分代"><a href="#为什么要分代" class="headerlink" title="为什么要分代"></a>为什么要分代</h5><p>分代的垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p>试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</p><h5 id="如何分段"><a href="#如何分段" class="headerlink" title="如何分段"></a>如何分段</h5><p>年轻代、年老代和持久代，其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。</p><ul><li><p>年轻代</p><p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p></li><li><p>年老代</p><p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象</p></li><li><p>持久代</p><p>用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize&#x3D;<N>进行设置。</p></li></ul><h5 id="什么时候触发垃圾回收"><a href="#什么时候触发垃圾回收" class="headerlink" title="什么时候触发垃圾回收"></a>什么时候触发垃圾回收</h5><ul><li><p>Scavenge GC<br>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p></li><li><p>Full GC</p><p>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比ScavengeGC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p><p>· 年老代（Tenured）被写满</p><p>· 持久代（Perm）被写满</p><p>· System.gc()被显示调用</p><p>·上一次GC之后Heap的各域分配策略动态变化</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一记</title>
    <link href="/2025/05/03/java/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    <url>/2025/05/03/java/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>代码方面见git，下面只记录一些知识点</p></blockquote><h5 id="2025-5-4"><a href="#2025-5-4" class="headerlink" title="2025&#x2F;5&#x2F;4"></a>2025&#x2F;5&#x2F;4</h5><ul><li><p>互联网项目一般建议单表查询</p><ul><li>单表查询结果更易缓存，多表连接查询的话，每个表的记录都要引起缓存的变动</li><li>后续有变动的时候，我只需要关注一小部分，而不用关注整个查询</li><li>代码复用性高</li><li>占内存，资源的瓶颈在数据库上</li></ul></li><li><p>left join 和 right join有什么区别</p></li><li><p>加了一个联合索引name_phone，分析下这几个sql会走索引吗？</p><ul><li>select * from user where phone &#x3D; “%130” and name &#x3D; “w”</li><li>select * from user where name &#x3D; “w” and phone like “%130”</li><li>select * from user where name like “w%” and phone like “130”</li><li>select * from user where name like “%w%” and phone like “130”</li></ul></li><li><p>怎么计算数据量会占用多大内存，从mysql查出来数据有看过占用多大内存吗</p></li><li><p>java中，线程池中有哪些参数？</p><ul><li>核心线程数：线程池长期保持存活的线程数量</li><li>最大线程数：当任务队列已满，且当前线程数小于 maximumPoolSize 时，线程池会创建新的线程来处理任务，直到达到 maximumPoolSize</li><li>拒绝策略<code>handler</code>：</li><li>workQueue：用于存储待执行任务的阻塞队列。当提交的任务数超过 corePoolSize 时，新任务会被放入这个队列中等待处理。</li><li>等待时间<code>keepAliveTime</code>：线程池中的线程数量超过 corePoolSize 时，多余的空闲线程在被销毁之前等待新任务的最长时间。</li><li>线程池</li></ul></li><li><p>为什么线程池里面要设置一个队列呢？</p></li><li><p>无界队列一直往里面放，是会先达到最大线程数还是会先内存溢出呢？救急线程？</p><ul><li><p>创建救急线程的前提是队列满</p></li><li><p>线程数会一直维持在核心线程数，不会达到最大线程数</p></li><li><p>随着任务持续加入队列，队列会不断占用内存。若任务生成速度远超核心线程处理速度，最终会因队列占用过多内存而导致内存溢出</p></li></ul></li><li><p>mysql执行的很慢，如何排查</p></li><li><p>索引失效的场景</p><ul><li><p>索引列使用了函数</p></li><li><p>使用 OR 导致索引失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">ELECT <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">OR</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">-- 若 b 无索引，全表扫描</span><br><span class="hljs-comment">--MySQL 无法对 OR 条件合并索引。</span><br><span class="hljs-comment">--拆分为 UNION ALL 或为 b 添加索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></li><li><p>模糊查询以 % 开头</p></li><li><p>索引列与查询值类型不一致</p></li><li><p>非等值查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;active&#x27;</span>; <span class="hljs-comment">-- 可能全表扫描</span><br><span class="hljs-comment">-- 非等值操作符难以通过索引快速定位数据</span><br></code></pre></td></tr></table></figure></li><li><p>查询索引列的 <code>NULL</code> 值</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>; <span class="hljs-comment">-- 若 NULL 值极少，可能走索引</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>; <span class="hljs-comment">-- 可能全表扫描</span><br></code></pre></td></tr></table></figure></li><li><p>数据量过小，优化器认为全表扫描比索引更快</p></li><li><p>范围查询后的索引列失效</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 联合索引 (age, name)</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">18</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;John&#x27;</span>; <span class="hljs-comment">-- name 无法使用索引</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>走了索引也很慢，会怎么办</p><p>先判断是不是索引创建的有问题，索引基数小的放在了左边</p><p>是不是没使用覆盖索引，走了回表</p><p>看cpu占用</p><p>看连接数</p></li><li><p>count (*) 和 count（1）有什么区别</p></li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">数据库会将 <span class="hljs-number">1</span> 视为一个常量，作为一个伪列，每行都会生成一个值为 <span class="hljs-number">1</span> 的伪列<br>性能上一般与 COUNT(\*) 接近，但 COUNT<span class="hljs-comment">(*) 在 MySQL 经过了更多优化，因此通常优先选择 COUNT(*)</span>。<br>某些旧版的数据库系统在处理COUNT<span class="hljs-comment">(*)时，可能会去解析整行数据，而COUNT(1)可以直接统计行数，因此会有一些微小的性能差异。</span><br></code></pre></td></tr></table></figure><ul><li><p>有10w条数据，写在一张表里面，怎么写最快，</p><p>多线程插入，其中一个线程插入失败了，怎么办呢？</p></li><li><p>多个线程怎么去用事务控制</p></li><li><p>前端页面要导出一个文件16G，后端应用内存就只有4G，如何导出？</p></li><li><p>设计抖音</p></li><li><p>为什么要设计出编译时异常、运行时异常，还有error</p><ul><li>强制开发者在编译阶段预见并处理可预期的、程序外部的异常情况（如 IO 操作失败、网络连接中断、用户输入错误等）。这类异常通常与程序外部环境相关（如文件不存在、数据库连接失败），而非程序本身的逻辑错误。</li><li>运行时异常表示程序逻辑错误，这类错误应在开发阶段通过代码审查、测试等手段避免，而非强制在运行时处理。例如空指针引用、数组越界、类型转换错误等，本质上是开发者的错误，而非外部环境不可控的问题。</li><li>表示系统级的严重错误，如 JVM 内存溢出、栈溢出、类文件损坏等。这类问题通常超出程序控制范围，即使捕获也无法恢复，强行处理可能导致更严重的后果（如数据不一致）。</li></ul></li></ul><h5 id="2025-5-5"><a href="#2025-5-5" class="headerlink" title="2025&#x2F;5&#x2F;5"></a>2025&#x2F;5&#x2F;5</h5><ul><li><p>n皇后问题</p></li><li><p>dfs bfs</p></li><li><p>单点登录</p><ul><li>系统的登录页放弃原有逻辑（若子系统想保留原有登录页，则需要新建一个前端页面作为登录页），直接在js里window.location跳转到认证中心的授权接口</li><li>用户输入用户名、密码进行验证。认证通过后，生成AuthonrizeCode，认证中心会发送请求到子系统给的redirect_uri，请求参数中包含AuthonrizeCode。</li><li>子系统接收到AuthonrizeCode，根据AuthonrizeCode调用获取Token接口，获取Token。</li><li>子系统根据返回的AccessToken调用获取认证用户接口，获取到用户信息，然后到子系统数据库中校验该用户是否存在，即是否有权限，有则放行，用户就能正常进入子系统。</li></ul></li><li><p>maven是如何加载的，如何load的，假如两个依赖都依赖了log4j，版本不一样，那么加载哪个呢？</p><ul><li><p>最近定义优先，依赖树中路径最短的版本胜出</p></li><li><p>声明顺序优先，假如深度相同，最先声明的依赖版本胜出</p></li><li><p>显示声明版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.14.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 强制指定版本 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mvn dependency:tree -Dincludes=org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.log4j</span>:log4j-core<br></code></pre></td></tr></table></figure></li><li><p>如何打破双亲委派的规则</p></li><li><p>jvm内存分区的概念</p></li><li><p>元注解</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Target</span>(ElementType.ANNOTATION_TYPE)<br></code></pre></td></tr></table></figure></li><li><p>为什么int[3]必须要指定大小？</p></li></ul><h5 id="2025-5-6"><a href="#2025-5-6" class="headerlink" title="2025&#x2F;5&#x2F;6"></a>2025&#x2F;5&#x2F;6</h5><ul><li><p>https</p><ul><li>为什么https下不能使用http</li><li>协商缓存、强制缓存</li></ul></li><li><p>tcp</p><ul><li>粘包</li></ul></li><li><p>Comparable 侵入式    整数、零或正整数，对应对象小于、等于或大于指定对象。</p></li><li><p>Comparator 非侵入性</p></li><li><p>二叉平衡树，前序、中序、后序遍历</p></li></ul><h5 id="2025-5-8"><a href="#2025-5-8" class="headerlink" title="2025&#x2F;5&#x2F;8"></a>2025&#x2F;5&#x2F;8</h5><p>dubbo</p><p>triple协议</p><h5 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h5><ul><li><p>feign中的configuration</p></li><li><p>事件框架</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 继承</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CusEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span> </span><br><br><span class="hljs-comment">// 监听方法</span><br><span class="hljs-meta">@Async</span>(<span class="hljs-string">&quot;指定线程池名称&quot;</span>)<br><span class="hljs-meta">@EventListener</span><br>public void method(<span class="hljs-type">CusEvent</span> cusEvent) &#123;<br>&#125;<br><br><span class="hljs-comment">// 推送消息</span><br>eventPublisher.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-type">CusEvent</span>(xx));<br><br><span class="hljs-comment">// 指定时间框架线程池参数</span><br><span class="hljs-meta">@Bean</span>(<span class="hljs-string">&quot;指定线程池名称&quot;</span>)<br>public <span class="hljs-type">Executor</span> cusExecutor() &#123;<br>    <span class="hljs-type">ThreadPoolTaskExecutor</span> executor = <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolTaskExecutor</span>();<br>    executor.setCorePoolSize(corePoolSize);<br>    executor.setMaxPoolSize(maxPoolSize);<br>    executor.setQueueCapacity(queueCapacity);<br>    executor.setThreadNamePrefix(<span class="hljs-type">DOMAIN_EXECUTOR</span>);<br>    <span class="hljs-comment">// rejection-policy：当pool已经达到max size的时候，如何处理新任务</span><br>    <span class="hljs-comment">// ThreadPoolExecutor#DiscardPolicy：这个策略将会直接丢弃任务</span><br>    <span class="hljs-comment">// ThreadPoolExecutor#CallerRunsPolicy：不在新线程中执行任务，而是有调用者所在的线程来执行策略</span><br>    executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>.<span class="hljs-type">CallerRunsPolicy</span>());<br>    executor.initialize();<br>    <span class="hljs-keyword">return</span> executor;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自定义异常处理器</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">restTemplate.setErrorHandler(new RestTemplateResponseErrorHandler())<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>内存溢出和内存泄漏</p></li><li><p>sql语句的执行过程</p></li><li><p>innodb和myism区别</p></li><li><p>回表的理解</p></li><li><p>ScheduledTaskRegistrar</p></li><li><p>I18nInitListener implements ApplicationListener<ApplicationReadyEvent></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2025/05/02/java/%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2025/05/02/java/%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新中</p></blockquote><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><blockquote><p>偶然间刷到了一个桶排序的视频，这次来实现下加深记忆</p></blockquote><p>​桶排序不是基于比较的排序算法，其效率取决于数据的分布特性，适用于数据均匀分布在某个范围内的场景（如浮点数、整数区间明确的数值数据）。其实现步骤如下：</p><ul><li>划分桶</li><li>桶内排序</li></ul><p>​值得注意的是，如何划分桶，以及数组元素定位到对应桶这两点。</p><p>方式一：</p><p>​假设桶的数量为bucketNum</p><p>​直接使用[max] - [min] &#x2F; bucketNum 确定桶的容量bucketCapacity</p><p>​数组元素进行桶定位的时候，使用当前元素item和数组内最小值的差值除以桶容量，此种情况下，会出现越界问题，必须使用Math.min进行一个辅助。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">bucketIndex</span> <span class="hljs-operator">=</span> Math.min((item - min) / bucketCapacity, bucketNum - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>​为什么会出现越界？比如 8 &#x2F; 3 ，向下取整的到的结果是 2，这里2对应的就是桶的容量，8对应的就是最大元素和最小元素的差值，3代表桶的数量，此时，使用(item - min) &#x2F; bucketCapacity，当item为最大元素时，会变成 8 &#x2F; 2，结果为4，会产生数组越界，现在我们抽象下这个问题</p><ul><li><p>[最大差值] &#x2F; [桶的数量] 向下取整  [桶的容量]</p></li><li><p>[桶的数量] * [桶的容量] &lt;&#x3D; [最大差值]</p></li></ul><p>最坏的情况下， [桶的容量] * [桶的数量] &#x3D; [最大差值] - （[桶的数量] - 1）</p><p>假设  [桶的容量]  &lt;&#x3D; （[桶的数量] - 1），此时会产生越界</p><p>方式二：</p><p>​(item - min) * bucketNum &#x2F; (max - min + 1) 非常巧妙的方式</p><ul><li>​(item - min)  &lt;  (max - min + 1)</li><li>​    (item - min)  * bucketNum &lt;   (max - min + 1) * bucketNum </li><li>(item - min) * bucketNum &#x2F; (max - min + 1) &lt; bucketNum</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> bucketSort(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-type">int</span> bucketNum = <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> min = ArrayUtils.min(arr);<br>        <span class="hljs-type">int</span> max = ArrayUtils.max(arr);<br>//        <span class="hljs-type">int</span> bucketCapacity = (max - min) / bucketNum;<br><br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; bucketList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketNum; i++) &#123;<br>            bucketList.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> item : arr) &#123;<br>//            <span class="hljs-type">int</span> bucketIndex = Math.min((item - min) / bucketCapacity, bucketNum - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> bucketIndex = (item - min) * bucketNum / (max - min + <span class="hljs-number">1</span>);<br>            bucketList.<span class="hljs-keyword">get</span>(bucketIndex).<span class="hljs-keyword">add</span>(item);<br>        &#125;<br><br>        <span class="hljs-type">int</span> indexGap = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketNum; i++) &#123;<br>            List&lt;<span class="hljs-type">Integer</span>&gt; bucket = bucketList.<span class="hljs-keyword">get</span>(i);<br>            <span class="hljs-type">int</span>[] <span class="hljs-keyword">array</span> = bucket.stream().mapToInt(<span class="hljs-type">Integer</span>::intValue).toArray();<br>            selectionSort(<span class="hljs-keyword">array</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">array</span>.length; j++) &#123;<br>                arr[j + indexGap] = <span class="hljs-keyword">array</span>[j];<br>            &#125;<br>            indexGap += <span class="hljs-keyword">array</span>.length;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阻塞队列</title>
    <link href="/2025/05/02/java/%E5%9F%BA%E7%A1%80/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <url>/2025/05/02/java/%E5%9F%BA%E7%A1%80/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新中</p></blockquote><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>​BlockingQueue是一个接口，它属于 Java 并发包java.util.concurrent，其用途是在多线程环境下实现线程安全的队列操作。</p><ul><li>线程安全：BlockingQueue自身实现了线程安全，多个线程能够同时对队列进行读写操作，无需额外的同步机制。</li><li>阻塞操作：定义了若干阻塞方法，当队列满时进行入队操作，或者队列空时进行出队操作，这些方法会让线程进入阻塞状态，直至满足操作条件。</li><li>容量限制：部分BlockingQueue的实现类具备容量限制，当队列达到最大容量时，再进行入队操作会被阻塞。</li></ul><h5 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h5><ul><li>add(E e)：若队列未满，将元素插入队列尾部，成功则返回true；若队列已满，会抛出IllegalStateException异常。</li><li>offer(E e)：若队列未满，将元素插入队列尾部，成功则返回true；若队列已满，返回false。</li><li>offer(E e, long timeout, TimeUnit unit)：在指定时间内尝试将元素插入队列尾部，若成功则返回true；若超时仍未成功，返回false。</li><li>put(E e)：若队列未满，将元素插入队列尾部；若队列已满，线程会阻塞直至队列有空间。</li></ul><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><ul><li>remove()：若队列不为空，移除并返回队列头部元素；若队列为空，抛出NoSuchElementException异常。</li><li>poll()：若队列不为空，移除并返回队列头部元素；若队列为空，返回null。</li><li>poll(long timeout, TimeUnit unit)：在指定时间内尝试移除并返回队列头部元素，若成功则返回元素；若超时仍未成功，返回null。</li><li>take()：若队列不为空，移除并返回队列头部元素；若队列为空，线程会阻塞直至队列中有元素。</li></ul><h5 id="检查元素"><a href="#检查元素" class="headerlink" title="检查元素"></a>检查元素</h5><ul><li>element()：若队列不为空，返回队列头部元素，但不移除；若队列为空，抛出NoSuchElementException异常。</li><li>peek()：若队列不为空，返回队列头部元素，但不移除；若队列为空，返回null。</li></ul><h5 id="常见实现类"><a href="#常见实现类" class="headerlink" title="常见实现类"></a>常见实现类</h5><ul><li>ArrayBlockingQueue：基于数组实现的有界阻塞队列，在创建时需指定容量，且可选择是否使用公平锁。</li><li>LinkedBlockingQueue：基于链表实现的阻塞队列，可指定容量，若不指定则默认为Integer.MAX_VALUE，被视为无界队列。</li><li>PriorityBlockingQueue：基于优先级堆实现的无界阻塞队列，队列中的元素会按照自然顺序或者指定的比较器进行排序。</li><li>SynchronousQueue：一种特殊的阻塞队列，它不存储元素，每个插入操作必须等待另一个线程的移除操作，反之亦然。</li></ul><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ArrayBlockingQueue;<br><span class="hljs-keyword">import</span> java.util.concurrent.BlockingQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueueExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 生产者线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    queue.put(i);<br>                    System.out.println(<span class="hljs-string">&quot;Produced: &quot;</span> + i);<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 消费者线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> queue.take();<br>                    System.out.println(<span class="hljs-string">&quot;Consumed: &quot;</span> + item);<br>                    Thread.sleep(<span class="hljs-number">200</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;);<br><br>        producer.start();<br>        consumer.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            producer.join();<br>            consumer.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis篇</title>
    <link href="/2025/05/01/java/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"/>
    <url>/2025/05/01/java/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/</url>
    
    <content type="html"><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>缓存</li><li>分布式锁</li><li>消息队列、延时队列</li><li>…</li></ul><p>ps：结合项目业务回答</p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>redis单线程为什么还执行那么快？</p><ul><li><p>纯内存操作，执行速度快</p></li><li><p>采用单线程，避免不必要的上下文切换可竞争条件，无需考虑线程安全问题，大key慢，scan等问题…</p></li><li><p>使用I&#x2F;O多路复用模型，非阻塞io</p><p>其瓶颈主要是网络延迟而不是执行速度</p></li></ul><h5 id="内核空间和用户空间"><a href="#内核空间和用户空间" class="headerlink" title="内核空间和用户空间"></a>内核空间和用户空间</h5><ul><li><p>用户空间：只能执行受限的命令(Ring3)，而不能直接调用系统资源，必须提供内核提供的接口来访问</p></li><li><p>内核空间：可以执行特权命令(Ring0)，调用系统资源</p><p>linux为了提高IO效率，会在二者都加入缓冲区</p><ul><li>写数据时，要把用户数据从用户缓冲区拷贝到内核缓冲区，然后写入设备</li><li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li></ul><p>想办法减少无效等待和频繁拷贝，recvfrom：从内核获取数据</p><ul><li>非阻塞io，recvfrom会立即返回结果而不是阻塞用户进程，但是会频繁访问，忙等，耗费cpu，直到数据就绪，但是数据就绪后，拷贝数据到用户空间的过程还是阻塞的。</li><li>io多路复用：单个线程同时兼容多个socket，使用select函数，监听多个socker，当内核数据就绪时，触发回调，客户端处理数据。</li><li>select、poll、epoll：前面二者只会通知用户进程有socker就绪，但不确定具体是哪个socker，需要用户进程逐个遍历，epoll会在 通知用户进程socker就绪的同时，把已就绪的socker写入用户空间</li></ul></li></ul><h5 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1.缓存穿透"></a>1.缓存穿透</h5><p>​查询<strong>不存在的数据</strong>，每次请求都会落到数据库，每次都查不到结果，redis不会缓存。</p><ul><li><p>缓存空数据，查不到结果，仍把空数据进行缓存</p><p>简单，但消耗内存，有可能会存在数据库不一致的问题。</p></li><li><p>布隆过滤器</p><ul><li>在查询redis缓存前，在<strong>前面加了一层</strong>布隆过滤器，如果布隆过滤器中，不存在，直接返回，存在在继续往下走</li><li>缓存预热时，预热布隆过滤器</li><li>基于bitmap实现<ul><li>存数据时，对key进行<strong>多次hash</strong>计算获取hash值，根据这一个个值，将数组对应位置改为1</li><li>查数据时，使用<strong>相同hash</strong>函数获取hash值，判断对应位置是否为1，都是1表示存在</li><li>有可能会存在误判，某个key hash后的值与存在的多个key的hash后的值重合，数组越小误判率越大，越大误判率越小。 </li><li>redisson和guava都实现了布隆过滤器，其可以设置误判率</li></ul></li></ul></li></ul><h5 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2.缓存击穿"></a>2.缓存击穿</h5><p>​某个时间点某个key突然有大量的并发过来，而且此时在redis中这个数据没有缓存(也许是到期了)，在第一次将数据库返回写入缓存这个过程中，其余大量请求直接到数据库可能会把数据库压垮。</p><ul><li>添加互斥锁（强一致性、性能差）<ul><li>第一次查询缓存未命中，在查询数据库之前，先要获取锁</li></ul></li><li>逻辑过期（高可用）<ul><li>不设置过期时间</li><li>查询缓存未命中，获取锁，新开了一个线程更新缓存，然后返回过期数据</li></ul></li></ul><h5 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3.缓存雪崩"></a>3.缓存雪崩</h5><p>​同一时段内，大量的缓存key同时失效或者redis服务宕机，大量请求到达数据库</p><ul><li><p>给不同的key设置不同的过期时间</p></li><li><p>利用redis集群提高服务的可用性</p></li><li><p>给缓存业务添加降级限流策略 nginx 网关限制</p></li><li><p>添加多级缓存 Guava或者Caffeine</p></li></ul><h5 id="4-mysql和redis数据同步，双写一致性"><a href="#4-mysql和redis数据同步，双写一致性" class="headerlink" title="4.mysql和redis数据同步，双写一致性"></a>4.mysql和redis数据同步，双写一致性</h5><p>​修改了数据库的数据，也要同时更新缓存的数据，缓存和数据库的数据要保持一致。</p><ul><li><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存</p></li><li><p>写操作：延迟双删</p><p>删除缓存——&gt;修改数据库——&gt;延时删除缓存</p><p>传统方案：</p><ul><li>先删除缓存，在修改数据库：在删除缓存和更新数据库之间，又来了一个线程，查询缓存查询数据库，写入旧的数据到了缓存。</li><li>先操作数据库，再删除缓存：在更新数据库之前，先前有一个线程，查询缓存查不到，查数据库、更新缓存，这个线程更新缓存的操作在当前线程删除缓存之后。</li></ul><p>为什么要延时？</p><p>mysql一般都是主从的，主节点同步到从节点也需要时间。</p></li><li><p>一般放入缓存中的数据都是读多写少，可以使用读写锁</p></li><li><p>异步通知保证数据的最终一致性，写入到数据库后，发布消息到mq去更新缓存</p></li><li><p>使用canal，写入到数据库后，canal会监听mysql的binlog，变更时通知缓存服务更新缓存</p></li></ul><h5 id="5-redis的持久化"><a href="#5-redis的持久化" class="headerlink" title="5.redis的持久化"></a>5.redis的持久化</h5><ul><li><p>RDB</p><p>把内存中的所有数据都记录到磁盘中，当redis实例故障重启后，从磁盘读取快照文件，恢复数据</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">save</span> <span class="hljs-meta">#redis主进程执行rdb，会阻塞所有命令</span><br>bgsave <span class="hljs-meta">#开启子进程执行rdb，避免主进程受到影响</span><br></code></pre></td></tr></table></figure><p>redis内部有触发RDB的机制，可以在redis.conf中找到，格式为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 900s内，如果至少有一个key被修改，则执行bgsave</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>bgsave开始时会fork主进程得到子进程，复制页表到子线程，对实际指向内存中的物理地址写入到rdb文件中放到磁盘。</p><p>假如这期间，主进程在修改数据，fork采用的是copy-on-write技术，当主进程在写的时候，会拷贝一份数据，执行写操作。</p><p>页表：记录虚拟地址和物理地址的映射关系</p></li><li><p>AOF（append only file）</p><p>redis处理的每一个写命令都会记录在aof文件中，可以看作是命令日志文件</p><ul><li><p>aof默认是关闭的，需要修改redis.conf配置文件来开启aof</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 是否开启aof 默认是no</span><br><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span><br><span class="hljs-comment"># aof文件的名称</span><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>频率，刷盘策略</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appendfsync</span> always <span class="hljs-comment"># 立即记录到aof文件，性能影响大</span><br>appendfsync everysec <span class="hljs-comment"># 写完后放入aof缓冲区，每隔1秒将缓冲区数据写到aof，默认方案，最多丢失1s数据</span><br>appendfsync <span class="hljs-literal">no</span> <span class="hljs-comment">#写入aof缓冲区，由操作系统决定何时写回磁盘</span><br></code></pre></td></tr></table></figure></li><li><p>存在问题：</p><ul><li><p>记录命令，文件大</p></li><li><p>记录多次写操作，只有最后一次写才有意义，可以使用bgrewriteaof执行重写，用最少的命令达到相同的效果</p></li><li><p>配置</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">auto</span>-aof-rewrite-percentage <span class="hljs-number">100</span> <span class="hljs-meta"># aof比上次文件增长超过多少百分比触发重写</span><br><span class="hljs-keyword">auto</span>-aof-rewrite-min-size <span class="hljs-number">64</span>mb <span class="hljs-meta"># aof文件体积最小多少大以上触发重写</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>对比</p><p>aof相对完整，取决于刷盘策略</p><p>aof数据恢复优先级高，因为其数据完整性更高</p></li></ul><p>​恢复速度rdb更快</p><p>​rdb耗费性能高，大量cpu和内存消耗</p><p>​aof追加命令，主要占用的是磁盘io资源，但aof重写的时候会占用大量的cpu和内存资源。</p><h5 id="6-数据过期策略"><a href="#6-数据过期策略" class="headerlink" title="6.数据过期策略"></a>6.数据过期策略</h5><ul><li>惰性删除：设置过期时间后，过期不会主动删除，当需要该key的时候，检查是否过期，过期就删掉，反之返回。<ul><li>对cpu友好，不用进行过期检查</li><li>内存中不会释放，占用内存</li></ul></li><li>定期删除：每隔一段时间，对key进行检查，删除过期的key（检查：从一定数量的数据库中取出一定数量的随机key进行检查）<ul><li>slow模式：定时任务，频率为10hz（每秒执行10次，即执行周期是100ms），每次不超过25ms，通过修改配置文件redis.conf的hz选项来调整</li><li>fast模式，执行频率不固定，但两次间隔不低于2ms，每次执行耗时不超过1ms</li><li>优点：有效释放了过期数据占用的内存，同时，其可以以限制执行时长和频率来减少删除操作对cpu的影响</li><li>缺点：执行时长和频率不好确定</li></ul></li></ul><p>​redis过期策略是两者结合使用</p><h5 id="7-数据淘汰策略"><a href="#7-数据淘汰策略" class="headerlink" title="7.数据淘汰策略"></a>7.数据淘汰策略</h5><p>​内存被占用满了怎么办？</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">maxmemory-<span class="hljs-keyword">policy</span> noeviction<br></code></pre></td></tr></table></figure><ul><li><p>noeviction：不会淘汰任何key，内存满了不允许写入新数据，默认</p></li><li><p>volatile-ttl：对设置了ttl的key，比较剩余ttl，ttl越小先被淘汰</p></li><li><p>allkeys-random：对全体key，随机进行淘汰</p></li><li><p>volatile-random：对设置了ttl的key，随机进行淘汰</p></li><li><p>allkeys-lru：对全体key，使用lru，最近最少使用</p></li><li><p>volatile-lru：对设置了ttl的key，使用lru，最近最少使用</p></li><li><p>allkeys-lfu：对全体key，使用lru，最近最少频率使用</p></li><li><p>volatile-lfu：对设置了ttl的key，使用lfu，最近最少使用</p></li></ul><p>优先使用lru，实际使用中，lfu不一定比lru实用，某一个key，一段时间内访问频率高，另外一段时间内访问频率不一定高</p><p>有置顶的需求，可以使用volatile-lru，同时置顶数据不设置过期时间</p><p>有短时高频访问的数据，使用lfu</p><h5 id="8-redis分布式锁"><a href="#8-redis分布式锁" class="headerlink" title="8.redis分布式锁"></a>8.redis分布式锁</h5><p>​setnx，有效时长，lua脚本</p><p>​redlock红锁：不能只在一个reids实例上创建锁，应该是在多个redis实例上创建锁(n&#x2F;2 +1)，实现复杂，性能差，运维繁琐。</p><p>​redis是ap思想，高可用</p><p>​如果要保证强一致性可以使用zookeeper，cp思想</p><h5 id="9-集群"><a href="#9-集群" class="headerlink" title="9.集群"></a>9.集群</h5><ul><li><p>主从：读写分离，主写，从读，解决高并发</p><ul><li><p>全量同步</p><table><thead><tr><th>主</th><th>从</th></tr></thead><tbody><tr><td></td><td>执行replicaof命令</td></tr><tr><td></td><td>请求数据同步，将自己的replid、offset发送</td></tr><tr><td>拿replid和自己判断，判断是否第一次同步</td><td></td></tr><tr><td>是第一次，返回master数据版本信息repliid、offset，第二次，就会直接发送repl_baklog给从</td><td></td></tr><tr><td></td><td>保存版本信息</td></tr><tr><td>执行bgsave，生成rdb，发送rdb到从</td><td></td></tr><tr><td></td><td>清空本地文件，加载rdb文件</td></tr><tr><td>记录rdb期间的所有命令到repl_baklog中,发送给从</td><td></td></tr><tr><td></td><td>执行repl_baklog</td></tr></tbody></table></li><li><p>增量同步，slave重启或后期数据变化</p><p>即上面的表格中第二次部分，从repl_baklog发送offset后的命令到从</p></li></ul></li><li><p>哨兵（sentinel）：实现主从集群的自动故障恢复，解决高可用</p><ul><li>sentinel会不断检查主从是否按照预期工作</li><li>自动故障恢复：master故障后，sentinel会将一个slave提升为master，故障实例恢复后也以新的master为主</li><li>通知：sentinel充当redis客户端的服务发现来源，集群发生故障转移时，会将最新的信息推送给redis客户端</li></ul><p>其基于心跳机制检测服务状态，每隔1s向集群的每个实例发送ping命令：</p><ul><li>主观下线：如果某个实例未在规定时间内响应，主观下线</li><li>客观下线，超过指定数量的sentinel都认为该实例主观下线，则该实例客观下线，指定数量quorum值最好超过sentinel的一半。</li></ul><p>选主规则</p><ul><li>判断主节点和从节点断开时间长短，断开时间太长了就代表数据旧</li><li>判断从节点的slave-priority值，越小优先级越高</li><li>如果slave-priority一样，则判断slave的offset值，越大优先级越高</li><li>判断slave节点的运行id大小，越小优先级越高</li></ul><p>脑裂</p><ul><li><p>主节点网络和sentinel分区了，sentinel选出了新的主，同时客户端也在往旧的主节点写数据，当主节点网络和sentinel恢复到一个分区后，会把旧的主节点当成从节点，此时数据丢失</p></li><li><p>解决</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-replicas-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 表示主节点最少的salve节点为1个，否则拒绝请求</span><br><span class="hljs-built_in">min</span>-replicas-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">5</span> <span class="hljs-comment"># 表示数据复制和同步的延迟不超过5s，否则拒绝客户端连接</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>分片集群，解决海量数据存储以及高并发写的问题</p><ul><li>集群中有多个master，每个master保存不同内存</li><li>每个master都可以有多个slave节点</li><li>master之间通过ping检测彼此健康状态，这样就不要哨兵了</li><li>客户端可以访问集群任意节点，最终都会被转发到正确节点</li></ul><p>hash槽，redis集群中有16384个hash槽，每个key通过CRC16校验后对16384取模来决定防止哪个槽，集群的每个节点负责一部分hash槽。</p><p>可以使用set[aaa] name value 指定取模来源，redis会根据aaa来进行取模，而不是name了。</p></li></ul><h5 id="redis集群如何扛住百万级别的热点key的访问"><a href="#redis集群如何扛住百万级别的热点key的访问" class="headerlink" title="redis集群如何扛住百万级别的热点key的访问"></a>redis集群如何扛住百万级别的热点key的访问</h5><p>redis单片的写入瓶颈在2万左右，读瓶颈在10w左右</p><ul><li><p>对热点key进行拆分成几个小key</p><p>如何保证各个key在不同节点上，CRC16插槽</p></li></ul><h5 id="基于list结构模拟消息队列"><a href="#基于list结构模拟消息队列" class="headerlink" title="基于list结构模拟消息队列"></a>基于list结构模拟消息队列</h5><ul><li>生产者使用LPUSH向redis队列中存入一条数据</li><li>消费者使用RPOP后进先出、LPOP先进先出、BRPOP、BLPOP</li></ul><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"># 向列表 mylist 中依次添加元素 a、b、c<br><span class="hljs-number">127.0.0.1:6379</span>&gt; RPUSH mylist a b c<br>(integer) <span class="hljs-number">3</span><br><br># 使用 RPOP 从列表右侧（尾部）移除并返回元素<br><span class="hljs-number">127.0.0.1:6379</span>&gt; RPOP mylist<br><span class="hljs-string">&quot;c&quot;</span><br><br># 此时列表中剩余元素为 a、b<br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE mylist <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;b&quot;</span><br><br># 使用 LPOP 从列表左侧（头部）移除并返回元素<br><span class="hljs-number">127.0.0.1:6379</span>&gt; LPOP mylist<br><span class="hljs-string">&quot;a&quot;</span><br><br># 此时列表中剩余元素为 b<br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE mylist <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;b&quot;</span><br></code></pre></td></tr></table></figure><h5 id="基于Pubsub的消息队列"><a href="#基于Pubsub的消息队列" class="headerlink" title="基于Pubsub的消息队列"></a>基于Pubsub的消息队列</h5><p>​消费者可以订阅一个或多个channel，生产者向对应的channel发送消息后，所有的订阅者都能收到相关消息。</p><ul><li>SUBSCRIBE xxx.q1</li><li>PUBLISH xxx.q1</li></ul><h5 id="Stream的消息队列"><a href="#Stream的消息队列" class="headerlink" title="Stream的消息队列"></a>Stream的消息队列</h5><p>​redis5.0后引入的新的数据类型，可以实现功能完善的消息队列。</p><h5 id="feed流"><a href="#feed流" class="headerlink" title="feed流"></a>feed流</h5><ul><li>拉模式：读扩散，数据存储在来源方，每次都查询</li><li>推模式：写扩散，数据推送到接收方，假如有多个接收方，就会存储多份，延迟低，但是内存占用高</li><li>推拉结合模式：读写混合，假如接收方比较少，就写扩散，或者有几个活跃的接收方，就使用这种模式，而那些僵尸粉，就使用拉模式。</li></ul><h5 id="GEO数据结构"><a href="#GEO数据结构" class="headerlink" title="GEO数据结构"></a>GEO数据结构</h5><p>3.2版本后，加入了对GEO的支持，允许存储地理坐标信息，经度、纬度、值。</p><h5 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h5><p>​redis是利用string数据类型实现的bitmap，最大上限是512M</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"># 给<span class="hljs-keyword">key</span>上dayOfMonth - <span class="hljs-number">1</span>索引的值置为<span class="hljs-literal">true</span><br>stringRedisTemplate.opsForValue().setBit(<span class="hljs-keyword">key</span>, dayOfMonth - <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br><br># 查询从第<span class="hljs-number">0</span>个索引到dayOfMonth索引的值<br>List&lt;<span class="hljs-type">Long</span>&gt; longs = stringRedisTemplate.opsForValue().bitField(<br>                <span class="hljs-keyword">key</span>,<br>              BitFieldSubCommands.create().<span class="hljs-keyword">get</span>(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="hljs-number">0</span>)<br>        );<br></code></pre></td></tr></table></figure><h5 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h5><ul><li>UV：unique visitor 独立访客量，一天内同一个用户多次访问，只记录一次</li><li>PV：page view，页面访问量或点击量，用户访问网站的一个页面，记录一次PV，用户多次打开页面，则记录多次PV。</li></ul><p>底层也是基于基于string实现的，单个HLL的内存永远小于16kb，其测量结果是概率性的，有小于0.81%的误差，对于UV来说，完全可以忽略。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">info</span> memory <span class="hljs-comment"># 查看redis内存值</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql篇</title>
    <link href="/2025/05/01/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    <url>/2025/05/01/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/</url>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h5 id="如何定位慢查询"><a href="#如何定位慢查询" class="headerlink" title="如何定位慢查询"></a>如何定位慢查询</h5><ul><li>mysql慢日志</li><li>压力测试的时候可以看接口耗时，运维工具</li></ul><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>MySQL的默认存储引擎InnoDB使用的是B+树作为索引的存储结构。</p><p>选择B+树的原因包括：</p><ul><li><p>节点可以有更多子节点，路径更短；</p></li><li><p>磁盘读写代价更低，非叶子节点只存储键值和指针，叶子节点存储数据；</p></li><li><p>B+树适合范围查询和扫描，因为叶子节点形成了一个双向链表。</p></li></ul><p>聚簇索引：聚簇索引是指数据与索引放在一起，B+树的叶子节点保存了整行数据，通常只有一个聚簇索引，一般是由主键构成。</p><p>非聚簇索引：数据与索引分开存储，B+树的叶子节点保存的是主键值</p><p>覆盖索引：SELECT查询中，返回的列全部能在索引中找到，避免了回表查询，提高了性能。使用覆盖索引可以减少对主键索引的查询次数，提高查询效率。</p><p>回表查询：通过二级索引找到对应的主键值，然后再通过主键值查询聚簇索引中对应的整行数据的过程。</p><p>索引创建原则：</p><ul><li>表中的数据量超过10万以上时考虑创建索引。</li><li>选择查询频繁的字段作为索引，如查询条件、排序字段或分组字段。</li><li>尽量使用复合索引，覆盖SQL的返回值。</li><li>如果字段区分度不高，可以将其放在组合索引的后面。</li><li>对于内容较长的字段，考虑使用前缀索引。</li><li>控制索引数量，因为索引虽然可以提高查询速度，但也会影响插入、更新的速度。</li></ul><p>前缀索引：是指对字符串类型（如CHAR、VARCHAR、TEXT）的字段，仅对其前N个字符建立索引，而非整个字段。例如，对VARCHAR(255)字段的前10个字符建立索引。</p><p>索引失效</p><ul><li>没有遵循最左匹配原则。</li><li>使用了模糊查询且%号在前面。</li><li>在索引字段上进行了运算或类型转换。</li><li>使用了复合索引但在中间使用了范围查询，导致右边的条件索引失效。</li></ul><h5 id="explain命令"><a href="#explain命令" class="headerlink" title="explain命令"></a>explain命令</h5><ul><li>possible_key 当前sql可能会用到的索引</li><li>key 当前sql实际命中的索引</li><li>key_len 索引占用的大小</li><li>extra 额外的优化建议<ul><li>using where; using index 查询使用了索引，需要的数据都在索引列中能找到，不需要回表查询数据</li><li>using index condition 查询使用了索引，但是需要回表查询数据</li></ul></li><li>type sql的连接类型，null、system、const、eq_ref、ref、range、index、all<ul><li>null 没有使用到表</li><li>system 查询系统中的表</li><li>const 根据主键查询</li><li>eq_ref 主键索引查询或者唯一索引查询</li><li>ref 索引查询</li><li>range 范围查询</li><li>index 索引树扫描</li><li>all 全表扫描</li></ul></li></ul><h5 id="优化经验"><a href="#优化经验" class="headerlink" title="优化经验"></a>优化经验</h5><ul><li>建表时选择合适的字段类型。</li><li>使用索引，遵循创建索引的原则。</li><li>编写高效的SQL语句，比如避免使用SELECT *，尽量使用UNION ALL代替UNION，以及在表关联时使用INNER JOIN。</li><li>采用主从复制和读写分离提高性能。</li><li>在数据量大时考虑分库分表。</li></ul><h5 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h5><p>脏读、不可重复读、幻读</p><ul><li>缓冲池（Buffer pool）：主内存中的区域，缓存磁盘上经常操作的真实数据，执行增删改查操作的时候，先操作缓冲池中的数据（若缓冲池中没有，则从磁盘中加载并缓存），以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</li><li>数据页：是innodb存储引擎磁盘管理的最小单元，每个页的大小默认为16KB，页中存储的是行数据</li></ul><p><strong>redo log</strong>（记录的是物理日志）：重做日志，记录的是事务提交时对物理页的物理修改，是用来实现事务的持久性，由重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）组成，前者在内存中，后者在磁盘中。</p><p>当事务提交后，Buffer pool变化，redo log buffer会记录变化，同时会把所有的修改信息都记录到该日志文件中，用于刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p><p>为什么不把Buffer pool中的数据直接存在对应表磁盘文件ibd文件中呢？因为这个过程io耗时久，由buffer pool交给redo log buffer后，对redo log file的记录是<strong>顺序的磁盘io</strong>，性能高，这种机制又叫WAL（write ahead logging）</p><p>保证了事务的持久性</p><p><strong>undo log</strong>（记录的是逻辑日志）：回滚日志，记录数据被修改前的信息，提供回滚和MVCC</p><ul><li>delete数据的时候，undo log中会记录一条对应的insert记录</li><li>update一条数据时，会记录一条对应相反的update记录</li></ul><p>保证了事务的原子性和一致性</p><h5 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h5><p>隐藏字段</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务id，记录最后操作这条记录的事务id</td></tr><tr><td>DB_ROLL_PTR</td><td>执行这条记录的上一个版本</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td></tr></tbody></table><ul><li>undo log版本链</li></ul><p><strong>readview</strong> </p><ul><li><p>readview 读视图是快照读sql执行时mvcc提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id</p></li><li><p>当前读：读取的是记录的最新版本，读取时还要保证其他事务不能修改当前记录，会对读取的记录加锁，比如select … lock in share mode(共享锁)、select … for update、insert、update、delete(排他锁)都是一种当前读</p></li><li><p>快照读：简单的select，不加锁，读取的是可见版本，有可能是历史数据，非阻塞读</p><ul><li>读已提交：每次select 都生成一个快照读</li><li>可重复读：开启事务后第一个select语句才是快照读的的地方</li></ul></li></ul><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务id集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务id</td></tr><tr><td>max_trx_id</td><td>预分配事务id，当前最大事务id+1</td></tr><tr><td>creator_trx_id</td><td>readview 创建者的事务id</td></tr></tbody></table><h5 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h5><pre><code class="hljs">核心是binlog文件，记录了所有的ddl（数据定义语言）和dml（数据操纵语言），但不包括select和show语句</code></pre><ul><li>主库事务提交，记录变更到binlog</li><li>从库读取主库binlog，写入到从库的中继日志relay log</li><li>从库重做中继日志中的事件</li></ul><h5 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h5><p>垂直分库：以表为依据，根据业务将不同表拆分到不同库中</p><p>垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中，冷热数据分离，减少io</p><ul><li><p>把不常用的字段单独放在一张表</p></li><li><p>把text、blob等大字段拆分出来放在附表中</p></li></ul><p>水平分库：将一个库的数据拆分到多个库，解决了单库大数据量，高并发的性能瓶颈问题，提高了系统的稳定性和可用性</p><p>路由规则</p><ul><li>根据id节点取模</li><li>按id也就是范围路由</li></ul><p>水平分表：将一个表的数据拆分到多个表中，优化单表数据量过大而产生的性能问题，避免io争抢而减少锁表的几率。</p><p>分库之后的问题：</p><ul><li>分布式事务一致性问题</li><li>跨节点关联查询</li><li>跨节点分页、排序函数</li><li>主键避重</li></ul><p>中间件：sharding-sphere mycat</p><h5 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h5><p>InnoDB 默认工作在自动提交模式（autocommit&#x3D;1），此时每条独立的 SQL 语句（如 INSERT&#x2F;UPDATE&#x2F;DELETE）会被自动包裹在一个隐式事务中。</p><h5 id="死锁排查"><a href="#死锁排查" class="headerlink" title="死锁排查"></a>死锁排查</h5><p>​开启两个事务，对应sql为</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br><span class="hljs-keyword">UPDATE</span> emp <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = &quot;灿2&quot; <span class="hljs-keyword">where</span> id = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">UPDATE</span> `<span class="hljs-keyword">user</span>` <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = &quot;uzii&quot; <span class="hljs-keyword">where</span> id = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br><span class="hljs-keyword">UPDATE</span> `<span class="hljs-keyword">user</span>` <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = &quot;uzii&quot; <span class="hljs-keyword">where</span> id = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">UPDATE</span> emp <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = &quot;灿2&quot; <span class="hljs-keyword">where</span> id = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><ul><li><p>查看&#x2F;开启记录</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;innodb_print_all_deadlocks&#x27;</span>;<br><span class="hljs-keyword">SET</span> GLOBAL <span class="hljs-comment">innodb_print_all_deadlocks = 1</span>;<br></code></pre></td></tr></table></figure></li><li><p>查看死锁日志</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">SHOW ENGINE INNODB STATUS<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br></code></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">*** (2) HOLDS THE LOCK(S):</span><br><span class="hljs-comment">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br></code></pre></td></tr></table></figure><p>事务1、2都执行了前两行sql，此时继续往下执行，事务1等待事务2释放user的锁，事务2持有user的锁，同时，等待事务1释放emp表的锁。</p></li></ul><p>​</p><ul><li><p>其他查看日志的方式</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;log_error&#x27;</span>;<br></code></pre></td></tr></table></figure><p>结果为：log_error    stderr</p><p>MySQL 服务器会将错误日志输出到标准错误输出（stderr）</p><p>若想修改，修改配置文件</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 修改my.cnf文件</span><br>log_error = /var/<span class="hljs-built_in">log</span>/mysql/<span class="hljs-keyword">error</span>.<span class="hljs-built_in">log</span><br><br><span class="hljs-comment"># 重启mysql服务</span><br>sudo systemctl restart mysql<br></code></pre></td></tr></table></figure><p>扩展，查找my.cnf位置</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">find</span> -name my.<span class="hljs-keyword">cnf</span><br>./etc/my.<span class="hljs-keyword">cnf</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机备份</title>
    <link href="/2025/04/27/%E8%99%9A%E6%8B%9F%E6%9C%BA/vmware/%E5%A4%87%E4%BB%BD/"/>
    <url>/2025/04/27/%E8%99%9A%E6%8B%9F%E6%9C%BA/vmware/%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="一、直接复制文件夹"><a href="#一、直接复制文件夹" class="headerlink" title="一、直接复制文件夹"></a>一、直接复制文件夹</h3><ul><li><p>右键虚拟机，打开所在目录，备份此目录内容</p></li><li><p>在新环境下的vmware文件，选择打开虚拟机，选择刚刚目录下的vmx文件即可</p></li></ul><h3 id="二、通过虚拟机导入导出"><a href="#二、通过虚拟机导入导出" class="headerlink" title="二、通过虚拟机导入导出"></a>二、通过虚拟机导入导出</h3><ul><li><p>文件-&gt;导出为OVF文件</p></li><li><p>打开-&gt;选择OVF文件</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>虚拟机</category>
      
      <category>vmware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备份</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows命令行操作</title>
    <link href="/2025/04/24/windows/cmd/"/>
    <url>/2025/04/24/windows/cmd/</url>
    
    <content type="html"><![CDATA[<h5 id="找出某个端口正在使用的进程"><a href="#找出某个端口正在使用的进程" class="headerlink" title="找出某个端口正在使用的进程"></a>找出某个端口正在使用的进程</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">netstat <span class="hljs-punctuation">-</span>ano <span class="hljs-string">| findstr :8080</span><br></code></pre></td></tr></table></figure><p><strong>根据 PID 查找对应的进程</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">tasklist <span class="hljs-string">| findstr 10156</span><br></code></pre></td></tr></table></figure><h5 id="结束指定-PID-的进程"><a href="#结束指定-PID-的进程" class="headerlink" title="结束指定 PID 的进程"></a><strong>结束指定 PID 的进程</strong></h5><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">taskkill <span class="hljs-string">/F</span> <span class="hljs-string">/PID</span> 1234<br></code></pre></td></tr></table></figure><ul><li><code>/F</code>：表示强制终止进程。</li><li><code>/PID</code>：用于指定要终止的进程的 ID。</li></ul>]]></content>
    
    
    <categories>
      
      <category>windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jdbc</title>
    <link href="/2025/04/24/java/spring/jdbc/"/>
    <url>/2025/04/24/java/spring/jdbc/</url>
    
    <content type="html"><![CDATA[<p>todo</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring基础知识</title>
    <link href="/2025/04/24/java/spring/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2025/04/24/java/spring/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>ApplicationContext 、BeanFactory二者都可以获取bean，但是ApplicationContext 更全面，解析配置类，注册beanDefinition。</p><ul><li>实例化bean，早期bean</li><li>属性注入，@Autowried</li><li>初始化前 BeanPostProcessor（postProcessBeforeInitialization）、Aware</li><li>初始化  @PostConstruct 、InitializingBean（afterPropertiesSet）</li><li>初始化后  BeanPostProcessor（postProcessAfterInitialization）</li></ul><p>spring使用class.newInstance()创建对象</p><ul><li><p>默认情况下调用无参构造函数进行构造</p></li><li><p>假如有两个构造函数，也是有无参构造函数优先。</p></li><li><p>没有无参构造函数，有多个有参构造函数，会报错</p></li></ul><h5 id="springmvc的执行流程"><a href="#springmvc的执行流程" class="headerlink" title="springmvc的执行流程"></a>springmvc的执行流程</h5><ul><li><p>视图阶段（老旧jsp等）</p></li><li><p>前后端分离阶段（接口开发、异步）</p></li></ul><h5 id="springboot自动配置原理"><a href="#springboot自动配置原理" class="headerlink" title="springboot自动配置原理"></a>springboot自动配置原理</h5><pre><code class="hljs">Spring Boot的自动配置原理基于@SpringBootApplication注解，它封装了@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan。</code></pre><p>​@EnableAutoConfiguration是核心，它通过@Import导入配置选择器，读取META-INF&#x2F;spring.factories文件中的类名，根据条件注解决定是否将配置类中的Bean导入到Spring容器中。</p><h5 id="nacos和eureka的区别"><a href="#nacos和eureka的区别" class="headerlink" title="nacos和eureka的区别"></a>nacos和eureka的区别</h5><p>共同点：都支持服务注册和服务拉取，都支持服务提供者心跳方式做健康检测</p><p>不同点：</p><ul><li>nacos平时创建的都是临时实例，采用心跳检测，通过配置文件ephemeral控制，如果是非临时实例，nacos会<strong>主动询问</strong>提供者状态是否还存活。</li><li>nacos可以主动推送变更消息到服务消费者</li><li>临时实例不正常会被剔除，非临时实例则不会删除</li><li>nacos集群默认采用ap方式，当集群中存在非临时实例时，采用cp模式; eureka采用ap方式</li><li>nacos还提供了注册中心</li></ul><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>Ribbon，发起远程调用feign就会使用ribbon</p><ul><li>RoundRobinRule：简单的轮询策略。</li><li>WeightedResponseTimeRule：根据响应时间加权选择服务器。</li><li>RandomRule：随机选择服务器。</li><li>ZoneAvoidanceRule：区域感知的负载均衡，优先选择同一区域中可用的服务器。</li></ul><h5 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h5><p>服务雪崩是指一个服务的失败导致整个链路的服务相继失败。我们通常通过服务降级和服务熔断来解决这个问题：</p><ul><li>服务降级：在请求量突增时，主动降低服务的级别，确保核心服务可用。</li><li>服务熔断：当服务调用失败率达到一定阈值时，熔断机制会启动，防止系统过载。</li></ul><p>在Feign客户端启用熔断，定义降级逻辑处理异常：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">&quot;service-name&quot;</span>, fallback = FallbackService.class)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFeignClient</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/endpoint&quot;</span>)<br>    <span class="hljs-keyword">String</span> someMethod();<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">FallbackService</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">MyFeignClient</span></span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> someMethod() &#123;<br>        <span class="hljs-comment">// 返回默认值或抛出降级异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span><span class="hljs-type"></span> ServiceUnavailableException(<span class="hljs-string">&quot;服务暂不可用&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="skywalking"><a href="#skywalking" class="headerlink" title="skywalking"></a>skywalking</h5><p>application performance managment</p><ul><li>服务：微服务</li><li>端点：接口</li><li>实例：物理机</li></ul><h5 id="CAP-和-BASE"><a href="#CAP-和-BASE" class="headerlink" title="CAP 和 BASE"></a>CAP 和 BASE</h5><p>CAP理论是分布式系统设计的基础理论，包含一致性(Consistency)、可用性(Availability)和分区容错性(Partition tolerance)。在网络分区发生时，系统只能在一致性和可用性之间选择其一。</p><ul><li>C：用户访问分布式系统中的任意节点，得到的数据必须一致，即多个节点间数据要及时同步</li><li>A：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或者拒绝</li><li>P：因为网络故障或其他原因导致分布式系统中部分节点与其他节点失去连接，形成独立分区，tolerance是指集群出现分区的时候，整个系统也要持续对外提供服务</li></ul><p>分布式系统节点之间肯定时需要网络连接的，分区是必然存在的</p><p>AP 保证访问的高可用性，可以持续对外提供服务，但不是保证数据的强一致性。</p><p>CP 保证数据的强一致性，放弃高可用性。</p><p>BASE理论是分布式系统设计中对CAP理论中AP方案的延伸，强调通过基本可用、软状态和最终一致性来实现系统设计。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用命令</title>
    <link href="/2025/04/23/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2025/04/23/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h5 id="查找是否存在对应文件"><a href="#查找是否存在对应文件" class="headerlink" title="查找是否存在对应文件"></a>查找是否存在对应文件</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> [文件夹路径] --name <span class="hljs-string">&quot;文件名&quot;</span><br>例如：在当前文件夹下面查找main.dic的文件<br><span class="hljs-built_in">find</span> -name main.dic<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>es部署相关</title>
    <link href="/2025/04/23/docker/es/"/>
    <url>/2025/04/23/docker/es/</url>
    
    <content type="html"><![CDATA[<h3 id="docker部署es"><a href="#docker部署es" class="headerlink" title="docker部署es"></a>docker部署es</h3><h5 id="es部署docker命令"><a href="#es部署docker命令" class="headerlink" title="es部署docker命令"></a>es部署docker命令</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  --name es <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -e <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -v es-data:/usr/share/elasticsearch/data <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -v es-plugins:/usr/share/elasticsearch/plugins <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  --privileged <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  elasticsearch:<span class="hljs-number">7</span>.<span class="hljs-number">12</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>访问如下地址，出现响应即可</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.30.130:9200</span><br></code></pre></td></tr></table></figure><h5 id="Kibana部署docker命令"><a href="#Kibana部署docker命令" class="headerlink" title="Kibana部署docker命令"></a>Kibana部署docker命令</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>--name kibana <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>-e ELASTICSEARCH_HOSTS=http://<span class="hljs-number">192.168.30.130:9200</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>-p <span class="hljs-number">5601</span>:<span class="hljs-number">5601</span>  <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>kibana:<span class="hljs-number">7</span>.<span class="hljs-number">12</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>访问如下地址</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.30.130:5601</span><br></code></pre></td></tr></table></figure><p>出现初始化界面，选择选择<code>Explore on my own</code>之后，进入主页面选择<a href="http://192.168.30.130:5601/app/dev_tools#/">Dev Tools</a></p><h5 id="IK分词器安装"><a href="#IK分词器安装" class="headerlink" title="IK分词器安装"></a>IK分词器安装</h5><ul><li>docker进入es容器</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> es bash<br></code></pre></td></tr></table></figure><ul><li>进入后使用如下连接安装，发现过期了，只能手动下载安装包，安装包从网络获取</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">[root@<span class="hljs-number">4</span>f0ed4099320 bin]<span class="hljs-meta"># elasticsearch-plugin install https:<span class="hljs-comment">//github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip</span></span><br></code></pre></td></tr></table></figure><ul><li>安装包连接</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">通过网盘分享的文件：elasticsearch-analysis-ik-<span class="hljs-number">7.12</span>.<span class="hljs-number">1</span>.jar<br>链接: https:<span class="hljs-regexp">//</span>pan.baidu.com<span class="hljs-regexp">/s/</span><span class="hljs-number">19</span>cKTeNDevnjJxxfIOiTicA?pwd=xqnv 提取码: xqnv<br></code></pre></td></tr></table></figure><p><img src="/../../images/es%E9%83%A8%E7%BD%B2_ik%E5%88%86%E8%AF%8D%E5%99%A8_%E8%B7%AF%E5%BE%84.png"></p><ul><li>下载安装包，复制到docker中</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker cp 待复制文件路径 <span class="hljs-comment">[容器名]</span>:<span class="hljs-comment">[容器内路径]</span><br></code></pre></td></tr></table></figure><ul><li>此处是通过查看挂载卷的方式，直接传输到挂载卷，无需使用docker手动cp</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">volume</span><span class="language-bash"> inspect es-plugins</span><br></code></pre></td></tr></table></figure><ul><li>一切正常后，添加自定义分词，进入config目录，IKAnalyzer.cfg.xml指定了自定义分词读取 ext.dic文件，首先，我们创建一个 ext.dic文件，然后编辑文件，添加分词即可。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> ext.dic<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>es</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务项目-报错记录</title>
    <link href="/2025/04/21/java/%E9%A1%B9%E7%9B%AE/%E9%BB%91%E9%A9%AC%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/04/21/java/%E9%A1%B9%E7%9B%AE/%E9%BB%91%E9%A9%AC%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><h5 id="gateway启动报错"><a href="#gateway启动报错" class="headerlink" title="gateway启动报错"></a>gateway启动报错</h5><p>启动的时候，构造器中找不到对应的类，</p><ul><li>使用命令查看使用到错误类的jar包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plain">mvn dependency:tree -Dincludes=io.projectreactor.netty:reactor-netty<br></code></pre></td></tr></table></figure><ul><li>百度，查找spring微服务之间的版本关系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plain">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E<br></code></pre></td></tr></table></figure><p>最终替换版本解决问题</p><h5 id="maven中nacos自动配置依赖引不进来"><a href="#maven中nacos自动配置依赖引不进来" class="headerlink" title="maven中nacos自动配置依赖引不进来"></a>maven中nacos自动配置依赖引不进来</h5><p>一开始没加版本号，上网查了，特定版本的springcloud，需要指定版本号才行，其父pom中没有此依赖版本配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>项目</category>
      
      <category>黑马微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务项目-黑马商城</title>
    <link href="/2025/04/21/java/%E9%A1%B9%E7%9B%AE/%E9%BB%91%E9%A9%AC%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/"/>
    <url>/2025/04/21/java/%E9%A1%B9%E7%9B%AE/%E9%BB%91%E9%A9%AC%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="网关-gateway部分"><a href="#网关-gateway部分" class="headerlink" title="网关-gateway部分"></a>网关-gateway部分</h3><p>​todo</p><h3 id="nacos部分"><a href="#nacos部分" class="headerlink" title="nacos部分"></a>nacos部分</h3><h5 id="自动配置报错记录"><a href="#自动配置报错记录" class="headerlink" title="自动配置报错记录"></a>自动配置报错记录</h5><p>配置了bootstrap.yaml文件，指定了nacos中的共享配置，但是，本地启动的时候，<br>报错：spring 加载HikariDataSource的时候，如下代码找不到数据库配置导致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HikariDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> (HikariDataSource)DataSourceConfiguration.createDataSource(properties, HikariDataSource.class);<br></code></pre></td></tr></table></figure><p><strong>为什么？</strong></p><p>​一开始以为是这部分的执行顺序在nacos的自动配置之前。</p><p>​先把数据库配置写了一个必要的url在原始配置文件中，结果真的能启动，查看启动日志，发现后续也启动了bootstrap.yaml，但是跑接口的时候发现，启动并没有把我在nacos中的共享配置加载进来。</p><p>​最后实在没办法了，想着总不会是我名字没对上吧，结果还真是，nacos中的配置文件，是我几个月前建立好的共享配置，但是，今天的代码中bootstrap中的共享配置是我直接粘贴的文档内容，还真没对上，有福了，看了半个小时。</p><p>后续问题，在第二个模块中，引入如下依赖的时候，没有指定版本号，但是没报错，项目启动不会启动nacos的自动配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>项目</category>
      
      <category>黑马微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注解使用</title>
    <link href="/2025/04/21/java/spring/%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/04/21/java/spring/%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h5 id="ConditionalOnProperty-根据配置文件决定是否创建类"><a href="#ConditionalOnProperty-根据配置文件决定是否创建类" class="headerlink" title="@ConditionalOnProperty 根据配置文件决定是否创建类"></a>@ConditionalOnProperty 根据配置文件决定是否创建类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(&quot;xdap.sql.connector&quot;)</span><br><span class="hljs-meta">@ConditionalOnProperty(name = &quot;xdap.sql.connector.enable&quot;, havingValue = &quot;true&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApaasSqlConnectorProperties</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">existConnector</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/&quot;</span>;<br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        SqlStringUtil.initExistConnector(existConnector);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署github</title>
    <link href="/2025/04/21/hexo/%E9%83%A8%E7%BD%B2github/"/>
    <url>/2025/04/21/hexo/%E9%83%A8%E7%BD%B2github/</url>
    
    <content type="html"><![CDATA[<h5 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">https</span>://hexo.io/zh-cn/docs/<span class="hljs-literal">one</span>-<span class="hljs-keyword">command</span><span class="hljs-title">-deployment</span>.<span class="hljs-title">html</span><br></code></pre></td></tr></table></figure><ol><li><p>安装工具</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure></li><li><p>编辑**_config.yml**配置文件，前置条件，GitHub中创建对应仓库</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> <span class="hljs-params">&lt;repository url&gt;</span> <span class="hljs-meta"># https:<span class="hljs-comment">//bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span></span><br><span class="hljs-symbol">  branch:</span> [branch]<br><span class="hljs-symbol">  message:</span> [message]<br></code></pre></td></tr></table></figure></li><li><p>执行部署命令</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">hexo <span class="hljs-selector-tag">g</span>（生成）<br>hexo d（上传）<br></code></pre></td></tr></table></figure></li><li><p>访问<a href="https://lzc3.github.io/%E5%8D%B3%E5%8F%AF">https://lzc3.github.io/即可</a></p></li></ol><p>Github创建仓库</p><p>1.仓库名固定格式   [用户名]github.io   例如，lzc3.github.io </p><p>2.仓库需要公开</p><p>3.添加readme</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主题替换</title>
    <link href="/2025/04/20/hexo/%E4%B8%BB%E9%A2%98%E6%9B%BF%E6%8D%A2/"/>
    <url>/2025/04/20/hexo/%E4%B8%BB%E9%A2%98%E6%9B%BF%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h5 id="GitHub地址"><a href="#GitHub地址" class="headerlink" title="GitHub地址"></a>GitHub地址</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">https</span>://github.com/fluid-dev/hexo-theme-fluid?<span class="hljs-literal">tab</span>=readme-ov-<span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><h5 id="用户手册"><a href="#用户手册" class="headerlink" title="用户手册"></a>用户手册</h5><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">https:</span>//hexo.fluid-dev.com/docs/guide/#<span class="hljs-variable">%E5</span><span class="hljs-variable">%85</span><span class="hljs-variable">%B3</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%87</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%97</span><br></code></pre></td></tr></table></figure><h5 id="自定义配置修改"><a href="#自定义配置修改" class="headerlink" title="自定义配置修改"></a>自定义配置修改</h5><p>​修改_config.fluid.yml文件内容</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">slogan：<br><span class="hljs-built_in">text</span>：界面主题介绍文字<br></code></pre></td></tr></table></figure><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">navbar:</span><br>blog_title：导航栏左侧文字<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>主题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo</title>
    <link href="/2025/04/20/hexo/use/"/>
    <url>/2025/04/20/hexo/use/</url>
    
    <content type="html"><![CDATA[<h5 id="hexo使用文档"><a href="#hexo使用文档" class="headerlink" title="hexo使用文档"></a>hexo使用文档</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://hexo.io/zh-cn/docs/commands<br></code></pre></td></tr></table></figure><h5 id="新建md文件"><a href="#新建md文件" class="headerlink" title="新建md文件"></a>新建md文件</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">npx hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> <span class="hljs-comment">--path hexo/use &quot;使用hexo&quot;</span><br>npx hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> <span class="hljs-comment">--path hexo/主题替换 &quot;主题替换&quot;</span><br>npx hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> <span class="hljs-comment">--path java/spring/基础知识 &quot;spring基础知识&quot;</span><br></code></pre></td></tr></table></figure><h5 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">npx hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">npx hexo s</span><br></code></pre></td></tr></table></figure><h5 id="常用的格式"><a href="#常用的格式" class="headerlink" title="常用的格式"></a>常用的格式</h5><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">categories:<br>  - [Java, spring]<br>  - [Java, 项目]<br><span class="hljs-keyword">tags:</span><br>  - 注解<br>  - 报错<br></code></pre></td></tr></table></figure><h5 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h5><ul><li>在hexo项目根目录下安装上传本地图片插件</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save<br></code></pre></td></tr></table></figure><ul><li>绝对路径引用</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[]</span>(../images/xx.png)<br></code></pre></td></tr></table></figure><ul><li>相对路径本地引用，修改hexo目录下的配置文件_config.yml中</li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/qq_43401552/article/details/104805466">https://blog.csdn.net/qq_43401552/article/details/104805466</a></p><h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><ul><li>区分source下的post、自定义、draft模式</li><li>自定义主题<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid: :ocean: 一款 Material Design 风格的 Hexo 主题 &#x2F; An elegant Material-Design theme for Hexo</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/04/20/hello-world/"/>
    <url>/2025/04/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p><img src="/../images/test1.png"></p><p>jetcache</p><p><a href="https://github.com/alibaba/jetcache/blob/master/docs/CN/Readme.md">jetcache&#x2F;docs&#x2F;CN&#x2F;Readme.md at master · alibaba&#x2F;jetcache</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
