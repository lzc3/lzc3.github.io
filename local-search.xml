<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring AI的JsonSchema</title>
    <link href="/2025/11/18/%E9%9A%8F%E7%AC%94/Spring%20AI%E7%9A%84JsonSchema/"/>
    <url>/2025/11/18/%E9%9A%8F%E7%AC%94/Spring%20AI%E7%9A%84JsonSchema/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>使用Spring AI调用大模型时，JSON Schema不规范导致报错，报错内容为Grammar error: Pointer ‘&#x2F;$defs&#x2F;ResourceTypeEnum’ does not exist</p></blockquote><p><img src="/../../images/%E6%B6%A6%E7%94%B5%E6%8A%A5%E9%94%99.jpg"></p><h2 id="JSON-Schema规范"><a href="#JSON-Schema规范" class="headerlink" title="JSON Schema规范"></a>JSON Schema规范</h2><p>正确的JSON Schema，其$defs应该在参数中的最外层</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;<span class="hljs-variable">$id</span>&quot;</span>: <span class="hljs-string">&quot;https://example.com/schemas/customer&quot;</span>,<br><br>  <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,<br>  <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;first_name&quot;</span>: &#123; <span class="hljs-string">&quot;<span class="hljs-variable">$ref</span>&quot;</span>: <span class="hljs-string">&quot;#/<span class="hljs-variable">$defs</span>/name&quot;</span> &#125;,<br>    <span class="hljs-string">&quot;last_name&quot;</span>: &#123; <span class="hljs-string">&quot;<span class="hljs-variable">$ref</span>&quot;</span>: <span class="hljs-string">&quot;#/<span class="hljs-variable">$defs</span>/name&quot;</span> &#125;,<br>    <span class="hljs-string">&quot;shipping_address&quot;</span>: &#123; <span class="hljs-string">&quot;<span class="hljs-variable">$ref</span>&quot;</span>: <span class="hljs-string">&quot;/schemas/address&quot;</span> &#125;,<br>    <span class="hljs-string">&quot;billing_address&quot;</span>: &#123; <span class="hljs-string">&quot;<span class="hljs-variable">$ref</span>&quot;</span>: <span class="hljs-string">&quot;/schemas/address&quot;</span> &#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;required&quot;</span>: [<span class="hljs-string">&quot;first_name&quot;</span>, <span class="hljs-string">&quot;last_name&quot;</span>, <span class="hljs-string">&quot;shipping_address&quot;</span>, <span class="hljs-string">&quot;billing_address&quot;</span>],<br><br>  <span class="hljs-string">&quot;<span class="hljs-variable">$defs</span>&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span> &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>参考地址 <a href="https://json-schema.apifox.cn/#defs">JSON Schema 规范（中文版） - JSON Schema 规范（中文版）</a></p></blockquote><h2 id="Spring-AI中的JSON-Schema"><a href="#Spring-AI中的JSON-Schema" class="headerlink" title="Spring AI中的JSON Schema"></a>Spring AI中的JSON Schema</h2><h3 id="问题溯源"><a href="#问题溯源" class="headerlink" title="问题溯源"></a>问题溯源</h3><p>原始代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">chatClient.prompt(...)<br>                .options(...)<br>                .tools()<br>                .call()<br>                .entity(DashboardDesignDto.class);<br></code></pre></td></tr></table></figure><p>其中，chatClient为DefaultChatClient实例，使用tools时，ToolCallbacks.from会将传入的对象转换成ToolCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ChatClient.ChatClientRequestSpec <span class="hljs-title function_">tools</span><span class="hljs-params">(Object... toolObjects)</span> &#123;<br>    Assert.notNull(toolObjects, <span class="hljs-string">&quot;toolObjects cannot be null&quot;</span>);<br>    Assert.noNullElements(toolObjects, <span class="hljs-string">&quot;toolObjects cannot contain null elements&quot;</span>);<br>    <span class="hljs-built_in">this</span>.toolCallbacks.addAll(Arrays.asList(ToolCallbacks.from(toolObjects)));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其通过如下代码getToolCallbacks()转换ToolCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">MethodToolCallbackProvider.builder().toolObjects(sources).build().getToolCallbacks();<br></code></pre></td></tr></table></figure><p>getToolCallbacks()中核心逻辑如下，通过ToolDefinitions.from(toolMethod)构建了toolDefinition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">MethodToolCallback.builder()<br>    .toolDefinition(ToolDefinitions.from(toolMethod))<br>    .toolMetadata(ToolMetadata.from(toolMethod))<br>    .toolMethod(toolMethod)<br>    .toolObject(toolObject)<br>    .toolCallResultConverter(ToolUtils.getToolCallResultConverter(toolMethod)).build();<br></code></pre></td></tr></table></figure><p>最终使用JsonSchemaGenerator.generateForMethodInput构建inputSchema，其即为拼接在最终请求的tool中的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">DefaultToolDefinition.builder()<br>    .name(ToolUtils.getToolName(method))<br>    .description(ToolUtils.getToolDescription(method))<br>    .inputSchema(JsonSchemaGenerator.generateForMethodInput(method, <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonSchemaGenerator</span>.SchemaOption[<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure><p>获取一个schema Node</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ObjectNode schema <span class="hljs-operator">=</span> JsonParser.getObjectMapper().createObjectNode()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>在其中创建一个对象properties</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ObjectNode properties <span class="hljs-operator">=</span> schema.putObject(<span class="hljs-string">&quot;properties&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>生成参数Node，在生成的properties中放入参数值</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">ObjectNode parameterNode = SUBTYPE_SCHEMA_GENERATOR.generateSchema(parameterType, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Type</span>[<span class="hljs-number">0</span>]);<br>...<br>properties.<span class="hljs-keyword">set</span>(parameterName, parameterNode);<br></code></pre></td></tr></table></figure><p>最终生成的”$defs”嵌在了properties内，正常来说应该和properties同级别</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;tools&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;function&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;function&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;方法描述&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;方法名称&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;parameters&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;$schema&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://json-schema.org/draft/2020-12/schema&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;additionalProperties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;object&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                        <span class="hljs-attr">&quot;methodParam1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                            <span class="hljs-attr">&quot;$defs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;object&quot;</span><span class="hljs-punctuation">,</span><br>                            <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                            <span class="hljs-attr">&quot;required&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>                        <span class="hljs-punctuation">&#125;</span><br>                    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;required&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>JsonSchema</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口-协议</title>
    <link href="/2025/11/17/java/%E5%9F%BA%E7%A1%80/%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE/%E6%8E%A5%E5%8F%A3-%E5%8D%8F%E8%AE%AE/"/>
    <url>/2025/11/17/java/%E5%9F%BA%E7%A1%80/%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE/%E6%8E%A5%E5%8F%A3-%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h3><ul><li>REST，表述性状态转换，他是一种软件架构风格</li></ul><p>REST是风格，是约定方式，约定不是规定，可以打破。</p><p>描述模块的功能通常使用复数，也就是加s的格式来描述，表示此类资源，而非单个资源。如：users、emps、books…</p><h3 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h3><ul><li>会话：用户打开浏览器，访问web服务器的资源，会话建立，知道有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。</li><li>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次的会话的多次请求间共享数据。</li></ul><p>会话跟踪的方案：</p><ul><li>客户端会话跟踪技术：Cookie</li><li>服务端会话跟踪技术：Session</li><li>令牌技术</li></ul><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>优点：是http协议中支持的技术，浏览器会自动支持</p><p>缺点：</p><ul><li>移动端app无法使用cookie</li><li>不安全，用户可以自己禁用cookie</li><li>cookie不能跨域</li></ul><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>session，底层基于cookie实现的</p><p>优点：存储在服务端，安全</p><p>缺点：</p><ul><li>服务器集群环境下无法直接使用session</li><li>cookie的所有缺点</li></ul><h4 id="令牌技术"><a href="#令牌技术" class="headerlink" title="令牌技术"></a>令牌技术</h4><p>优点：</p><ul><li>支持pc端，移动端</li><li>解决集群环境下的认证问题</li><li>减轻服务器存储压力</li></ul><p>缺点：需要我们自己实现</p><p><strong>JWT令牌</strong></p><p>JSON WEB TOKEN</p><p>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。</p><p>由于数字签名的存在，这些信息是可靠的。</p><p>组成：</p><ul><li>第一部分：header头，记录令牌类型、签名算法。base64编码</li><li>第二部分：payload(有效载荷)，携带一些自定义信息、默认信息等。base64编码</li><li>第三部分：signature(签名)，防止token被篡改、确保安全性。将header、payload，加入指定密钥，通过指定签名算法计算而来。</li></ul><p>（为什么签名算法不会被篡改？）</p><p>因为.signWith(SignatureAlgorithm.<em>HS256</em>, SIGN_STRING) &#x2F;&#x2F; s太短会报错</p><p>SIGN_STRING是在服务端指定的，别人无法拿到，就无法生成对应的签名</p>]]></content>
    
    
    <categories>
      
      <category>接口-协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口-协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>训练</title>
    <link href="/2025/11/17/%E9%9A%8F%E7%AC%94/%E8%AE%AD%E7%BB%83/"/>
    <url>/2025/11/17/%E9%9A%8F%E7%AC%94/%E8%AE%AD%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><ul><li>innodb myisam区别</li></ul><p>innodb支持事务，支持表级锁行级锁、外键，myisam支持表级锁，</p><p>二者都用B+树作为索引结构</p><ul><li>B+ B-树的区别</li></ul><p>双向链表、范围查询</p><p>叶子节点：IO次数更少，查询更稳定</p><ul><li>聚簇索引和非聚簇索引</li></ul><p>一张表只能有一个聚簇索引，非聚簇索引叶子节点存的主键id，执行实际的数据</p><p>innodb表中一定会有一聚簇个索引，其表数据本身就是按照索引数据组织的，有主键用主键、无主键使用第一个unique字段、都无生成隐藏字段</p><ul><li>默认隔离级别</li></ul><p>PP，不能解决幻读问题</p><p>MVCC、临隙锁很大程度上解决了幻读问题 </p><p>MVCC在不加锁的情况下，让不同操作的读写可以同时进行</p><ul><li>EXPLAIN</li></ul><p>type 类型 system const ref range index all</p><p>key 实际使用的索引</p><p>extra 额外信息</p><p>rows 估算的扫描行 B数</p><ul><li>主从复制</li></ul><p>binlog，从库，写入本地relay_log，重放操作</p><p>主库写，从库读</p><p>数据备份</p><p>主库故障时，快速切换到从库 高可用</p><h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ensureCapacity(int minCapacity)</p><p>扩容1.5倍</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> </span>&#123;<br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-type">int</span> oldCapacity = elementData.length;<br>        <span class="hljs-type">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = <span class="hljs-built_in">hugeCapacity</span>(minCapacity);<br>        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>        elementData = Arrays.<span class="hljs-built_in">copyOf</span>(elementData, newCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>快速失败</li></ul><h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p>HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</p><p>HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。</p><p>HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。</p><p>LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。</p><p>TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。底层数据结构不同又导致这三者的应用场景不同。</p><p>HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景</p><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>PriorityQueue 是在 JDK1.5 中被引入的, 其与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><p>这里列举其相关的一些要点：PriorityQueue 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据。</p><p>PriorityQueue 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</p><p>PriorityQueue 是非线程安全的，且不支持存储 NULL 和 non-comparable 的对象。</p><p>PriorityQueue 默认是小顶堆，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。</p><p>PriorityQueue 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul><li>扰动</li></ul><p><code>HashMap</code> 中的扰动函数（<code>hash</code> 方法）是用来优化哈希值的分布。通过对原始的 <code>hashCode()</code> 进行额外处理，扰动函数可以减小由于糟糕的 <code>hashCode()</code> 实现导致的碰撞，从而提高数据的分布均匀性。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-title function_">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Hash冲突</li></ul><p>JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树</p><p>1.数据扩容能减少哈希冲突的概率</p><p>2.过早引入红黑树反而会增加复杂度</p><p>3.泊松分布，数组长度到达64后，hash冲突会更高；链表长度达到 8 的概率极低（小于千万分之一）。在绝大多数情况下，链表长度都不会超过 8。阈值设置为 8，可以保证性能和空间效率的平衡</p><ul><li>长度为什么是2的n次幂</li></ul><p>1.获取数组位置可以使用位运算，效率更高</p><p>2.扩容后，只需要判断最高位即可辨别是否需要移动到新位置，同时，可以保证数据尽量均匀分布。</p><ul><li>HashMap死循环问题</li></ul><p>1.7及以前，扩容使用头插法进行迁移，每次都会把当前进行到的元素插入到新链表头部，假如插入前，另外一个线程扩容完毕，插入元素就会指向其前一个元素，进而引起当前线程插入的错乱。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>1.7  分段的数组+链表 分段锁 </p><p>在 JDK1.7 的时候，ConcurrentHashMap 对整个桶数组进行了分割分段(Segment，分段锁)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p><p>到了 JDK1.8 的时候，ConcurrentHashMap 已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；Hashtable(同一把锁) </p><p>使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p><p>Java 8 中，锁粒度更细，synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p><p><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p><p><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p><p><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p><h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><ul><li>线程安全，后者使用synchronized 保证线程安全</li><li>容量，HashMap初始大小为16，扩容为2倍，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小</li><li>底层数据结构，JDK1.8后，HashMap底层会使用数组加红黑树，在解决哈希冲突时，单个table长度超过8且整体容量大于64，会使用红黑树。</li><li>哈希函数的实现：HashMap 对哈希值进行了高位和低位的混合扰动处理以减少冲突，而 Hashtable 直接使用键的 hashCode() 值</li></ul><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>​其就是基于HashMap实现的</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul><li>红黑树</li><li><code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力</li><li><code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力，默认是按 key 的升序排序</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><p>cursor内置规则</p><p>设置团队代码规范 <a href="https://zhuanlan.zhihu.com/p/1906795650714146104">(58 封私信 &#x2F; 21 条消息) Cursor Rules 详细教程，花5分钟写规则，让Cursor不再瞎改代码，AI编程必备 - 知乎</a></p><h3 id="Docker以及Kubernetes"><a href="#Docker以及Kubernetes" class="headerlink" title="Docker以及Kubernetes"></a>Docker以及Kubernetes</h3>]]></content>
    
    
    <categories>
      
      <category>训练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>训练</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2025/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>​运行中的程序，进程是资源分配的基本单位，操作系统通过进程操作计算机的资源，例如CPU、磁盘、内存等，每个进程都有一个唯一的进程标识符PID。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>​一个进程可以存在多个线程，其共享进程的资源，每个线程都可以独立执行不同的任务。</p><ul><li>与CPU核心的关系：一一对应，例如一个8核心的CPU，可以同时执行8个线程</li></ul><h4 id="协程（对应Java19虚拟线程）"><a href="#协程（对应Java19虚拟线程）" class="headerlink" title="协程（对应Java19虚拟线程）"></a>协程（对应Java19虚拟线程）</h4><p>​可以在一个线程内部创建多个协程，其共享线程的资源。</p><p>​协程是在进程内部运行的，不需要操作系统的介入，可以在用户空间内实现多任务管理。因此协程的创建和开销很小，可以更有效地利用系统资源。</p><ul><li>如果线程是饭店的饭桌的话，协程就是座椅</li></ul><h4 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h4><p><strong>1. 运行一个程序的时候，可能会有多个进程吗？</strong></p><p>​一个程序（一个可执行文件）在运行时，并不总是只对应一个进程。以下是几种常见的情况：</p><ul><li><p>设计上就是多进程的应用程序</p><p>Google Chrome &#x2F; Microsoft Edge： 这是最经典的例子。你打开浏览器，感觉是一个“程序”，但实际上它为你打开的每个标签页、每个扩展程序都创建了独立的进程。这样做的最大好处是稳定性和安全性。如果一个标签页崩溃了，不会导致整个浏览器崩溃。</p><p>Adobe Photoshop： 在处理复杂任务（如滤镜、保存）时，可能会启动单独的进程来处理，以避免阻塞主界面的响应。</p><p>数据库系统（如MySQL， PostgreSQL）： 通常采用“连接池”或“进程池”模型。每一个客户端连接进来，服务器端可能会为其分配一个独立的进程（或线程）来处理请求。</p></li><li><p>程序自身“自我复制”</p><p>程序在运行中，可以通过系统调用（如 fork()）来创建一个与自己一模一样的子进程。这个子进程可以继续执行不同的任务。这在服务器端程序中很常见。</p></li><li><p>你主动启动了多个实例</p><p>最简单地，你可以同时打开两个记事本（Notepad）窗口。每个窗口都是一个独立的 notepad.exe 进程。你在任务管理器里可以看到多个同名的进程。</p></li></ul><p><strong>2.执行一个JAVAWeb服务端程序的多个线程，最终对应的是一个进程还是多个进程？</strong></p><p>​通常情况下，这些线程都运行在同一个Java虚拟机进程内</p><ul><li><p>一个JVM就是一个进程</p><p>当你运行 java -jar your-web-app.jar 命令时，操作系统会启动一个新的进程，这个进程就是 Java虚拟机。你的所有Java代码都在这个JVM进程的“沙箱”里运行。</p></li><li><p>线程是进程内的执行单元</p><p>JVM进程启动后，它会创建多个线程。其中一定有一个 主线程（Main Thread） 来执行你的 main 方法。对于JavaWeb服务（如使用Spring Boot, Tomcat等），主线程会启动一个Web容器（如内嵌的Tomcat）。</p></li><li><p>Web容器管理线程池</p><p>这个Web容器内部维护了一个线程池。当有HTTP请求到达服务器时，容器（运行在主线程或另一个监听线程上）会从线程池中分配一个工作线程来处理这个请求。</p></li></ul><p>所有这些工作线程（Thread A, B, C…）、主线程、以及JVM自己的垃圾回收线程等，都共享同一个JVM进程的内存空间和系统资源。</p><p>3.为什么采用单进程多线程模型？</p><ul><li><p>创建开销小： 在进程内创建和销毁线程的开销，远小于创建和销毁进程。</p></li><li><p>通信简单高效： 线程共享内存，可以非常方便地共享数据（例如，共享一个静态变量、一个单例对象）。而进程间通信（IPC）则需要借助管道、消息队列、共享内存等更复杂的方式。</p></li><li><p>资源利用： 可以更充分地利用多核CPU。一个进程的多个线程可以被操作系统调度到不同的CPU核心上并行执行。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSE与普通Flux流式响应在同一接口并存</title>
    <link href="/2025/11/10/%E9%9A%8F%E7%AC%94/SSE%E4%B8%8E%E6%99%AE%E9%80%9AFlux%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94/"/>
    <url>/2025/11/10/%E9%9A%8F%E7%AC%94/SSE%E4%B8%8E%E6%99%AE%E9%80%9AFlux%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<p>1.使用produces &#x3D; MediaType.TEXT_EVENT_STREAM_VALUE指定了SSE协议</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * CUI交互</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">@PostMapping</span>(value = <span class="hljs-string">&quot;/stream/system/cui&quot;</span>, produces = MediaType.TEXT_EVENT_STREAM_VALUE)<br>    public Flux&lt;AiChatResponse&gt; <span class="hljs-built_in">streamSystemCUI</span>(<span class="hljs-variable">@RequestBody</span> CUIDto cuiDto,<br>                                                   HttpServletResponse response) throws JsonProcessingException &#123;<br>        <span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.setCharacterEncoding</span>(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">apaasChatClientService</span><span class="hljs-selector-class">.streamSystemCUI</span>(cuiDto);<br>    &#125;<br></code></pre></td></tr></table></figure><p>2.需求，需要根据不同业务场景，在同一个接口返回SSE响应与普通FLux响应</p><p>3.原始方案，直接修改response设置content-type，返回响应的时候找不到对应的响应解析器</p><p>4.最终解决</p><p>脑子抽风了改到了response，判断是根据request中的属性来判断的</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> org.springframework.web.servlet.mvc.method.annotation.ReactiveTypeHandler.handleValue<br>request.<span class="hljs-keyword">set</span>Attribute<span class="hljs-params">(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, List.of(MediaType.TEXT_EVENT_STREAM)</span>);<br></code></pre></td></tr></table></figure><p>5.衍生问题，参数响应Flux<Object> 与 Flux<String> 返回的respone中的Content-Type不一致</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis数据结构及类型</title>
    <link href="/2025/11/09/java/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"/>
    <url>/2025/11/09/java/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/</url>
    
    <content type="html"><![CDATA[<h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><ul><li>为什么不用c自带的字符串？</li></ul><p>​其本质是字符数组，获取长度需要遍历、以\0作为结束符，不安全，不能存储图片、音频…</p><p>Sds优势</p><ul><li>长度获取速度为O(1)</li><li>动态扩容</li><li>减少内存分配次数(扩容的时候内存预分配，一版扩大为原来的两倍+1.大于1M的情况下就是 + 1M + 1)</li><li>二进制安全</li></ul><p>组成：</p><ul><li>len 说明当前字符串大小</li><li>alloc 申请的内存空间</li><li>flag 标识是那种动态字符串(长度为 255 ..)</li><li>字符数组</li></ul><h4 id="IntSet"><a href="#IntSet" class="headerlink" title="IntSet"></a>IntSet</h4><p>​Set的一种实现，基于整数数组来实现，并且具备长度可变、有序的特征</p><p><img src="/../../../images/IntSet.png"></p><p>连续内存，寻址方便</p><p>超出当前编码范围，全部使用新的编码</p><p>特性</p><ul><li>redis保证其元素唯一、有序</li><li>类型升级，可节省空间</li><li>底层使用二分查找来查询</li></ul><h4 id="Dcit"><a href="#Dcit" class="headerlink" title="Dcit"></a>Dcit</h4><p><img src="/../../../images/redis-dict.png"></p><p>扩容</p><p>负载因子 &gt;&#x3D; 1，并且服务器没有执行bgsave或者bgweiteaof等后台进程</p><p>负载因子 &gt; 5</p><h4 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h4><p><img src="/../../../images/ZipList.png"></p><p><img src="/../../../images/ZipListEntry.png"></p><p>连锁更新问题</p><p><img src="/../../../images/ZipList%E8%BF%9E%E7%BB%AD%E6%9B%B4%E6%96%B0.png"></p><ul><li><p>申请的内存是连续空间(因此要限制其大小)</p></li><li><p>压缩列表可以看作一种连续内存空间的双向链表</p></li><li><p>列表的节点之间不是通过指针连接，而是记录上一节点和本节点的长度来寻址，内存占用较低</p></li><li><p>如果列表数据过多，导致长度过长，可能影响查询性能</p></li><li><p>增或删较大数据的时候有可能发生连续更新问题</p></li></ul><h4 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h4><p><img src="/../../../images/QucikList.png"></p><p>为了避免QuickList中每个ZipList的entry过多，Redis提供了一个配置项：list-max-ziplist-size</p><ul><li>值为正，代表ziplist的允许的entry个数的最大值</li><li>值为负，代表ziplist的最大内存大小，默认值为-2，代表每个zipList不能超过8kb</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># config get list-max-ziplist-size</span><br></code></pre></td></tr></table></figure><p>除了控制ZipList的大小，QuickList还可以对节点的ZipList做压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># config get list-compress-depth</span><br></code></pre></td></tr></table></figure><p>因为链表一般都是从首尾访问较多，所以首尾是不压缩的，这个参数是控制首尾不压缩的节点个数：</p><ul><li><p>0 不压缩 默认</p></li><li><p>1首尾各有1个节点不压缩</p></li><li><p>2首尾各有2个节点不压缩</p><p>…</p></li><li><p>是一个节点为ZipList的双端链表</p></li><li><p>节点采用ZipList，解决了传统链表的内存占用问题</p></li><li><p>控制了ZipList大小，解决了连续内存空间申请效率问题</p></li><li><p>中间节点可以压缩，进一步节省了内存</p></li></ul><h4 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h4><ul><li>双向链表，每个节点包含score和ele值</li><li>节点按照score排序，score值一样按照ele字典排序</li><li>每个节点都可以包含多层指针，层数是1~32之间的随机数</li><li>不同层指针到下一节点的跨度不同，层级越高，跨度越大</li><li>增删改查效率于红黑树基本一致，实现却更简单</li></ul><p><img src="/../../../images/SkipLIist.png"></p><p><img src="/../../../images/SkipList-example.png"></p><h4 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h4><p>​Redis中的任意数据类型的键和值都会被封装成一个RedisObject，也叫做Redis对象。</p><p><img src="/../../../images/RedisObject.png"></p><p><img src="/../../../images/Redis-struct.png"></p><h3 id="基础数据类型-1"><a href="#基础数据类型-1" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul><li>基本编码为RAW，基于SDS实现，存储上限为512mb</li><li>如果存储的SDS长度小于44字节，则会采用EMBSTR编码，此时object head于SDS是一段连续的空间，只需要调用一次内存分配函数</li><li>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码，直接将数据保存在RedisObject的ptr指针位置(刚好8字节)，不需要SDS了</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> name lzc<br><br>object encoding name<br></code></pre></td></tr></table></figure><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">LPUSH</span> l1 e3 e2 e1<br><br><span class="hljs-attribute">RPUSH</span> l1 e4 e5 e6<br><br><span class="hljs-attribute">LRANGE</span> l1 <span class="hljs-number">0</span> <span class="hljs-number">6</span> <br><br><span class="hljs-attribute">LPOP</span> l1 <span class="hljs-number">1</span><br><br><span class="hljs-attribute">RPOP</span> l1 <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>可以使用的数据结构</p><ul><li>LinkedList</li><li>ZipList</li><li>QuickList</li></ul><p>3.2版本前，使用LinkedList和ZipList实现，之后使用QuickList</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">SADD</span> <span class="hljs-built_in">s1</span> m1 m2 m3<br><span class="hljs-keyword">SADD</span> <span class="hljs-built_in">s2</span> m2 m3 m4<br><span class="hljs-symbol">SISMEMBER</span> <span class="hljs-built_in">s1</span> m1<br><span class="hljs-symbol">SINERT</span> <span class="hljs-built_in">s1</span> <span class="hljs-built_in">s2</span> <span class="hljs-comment">// 交集</span><br></code></pre></td></tr></table></figure><ul><li>不保证有序性</li><li>保证元素唯一</li><li>交集、并集、差集</li></ul><p>可以使用的数据结构</p><ul><li>Dict  key用来存储元素，value统一为null</li><li>当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，会采用IntSet编码，已节省内存</li></ul><p><img src="/../../../images/Redis-Set.png"></p><h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ZADD</span> z1 <span class="hljs-number">10</span> m1 <span class="hljs-number">20</span> m2 <span class="hljs-number">30</span> m3<br><span class="hljs-attribute">ZSCORE</span> z1 m1<br></code></pre></td></tr></table></figure><ul><li>member必须唯一</li><li>可以根据member查询值</li><li>可以根据score排序</li></ul><p>其数据结构必须满足键值存储、键必须唯一、可以排序</p><ul><li>SkipList满足了排序和存储键值</li><li>HT(Dict)：可以键值存储，并且可以根据key查找value</li></ul><p><img src="/../../../images/Redis-Zset.png"></p><p>当元素不多的时候，HT和skipList的优势不明显，而且更占用内存，因此zset还会采用ziplist结构来节省内存，不过需要满足两个条件</p><ul><li>元素数量小与zset_max_ziplist_entries 默认128</li><li>每个元素都小于zset_max_ziplist_value字节，默认64</li></ul><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>Hash结构与Redis中的Zset非常类似</p><ul><li>都是键值存储</li><li>都需要根据键获取值</li><li>键必须唯一</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">hset <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> <span class="hljs-type">name</span> Jack age <span class="hljs-number">21</span><br>hget <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> <span class="hljs-type">name</span><br></code></pre></td></tr></table></figure><p>不同点：</p><p>Zset的值时score，需要排序</p><p><img src="/../../../images/Redis-Hash.png"></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring事务管理</title>
    <link href="/2025/11/09/java/spring/%E4%BA%8B%E5%8A%A1/"/>
    <url>/2025/11/09/java/spring/%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h3><p><strong>@Transactional</strong></p><p>位置：业务service层的方法、类、接口上</p><p>作用：将当前方法交给spring进行事务管理，方法执行前，开启事务，成功执行完毕，提交事务，回滚事务。</p><p><strong>RollbackFor</strong></p><p>默认情况下，只会出现RuntimeException才回滚异常。rollbackFor属性用于控制出现何种异常类型，回滚事务</p><p>以下方式出现所有异常都会回滚。</p><p>@Transactional(rollbackFor &#x3D; Exception.class)</p><p><strong>propagation</strong></p><p>事务传播行为：指的是当一个事务方法被另外一个事务方法调用时，这个事务方法应该如何进行事务控制。</p><table><thead><tr><th>属性值</th><th>含义</th></tr></thead><tbody><tr><td>REQUIRED</td><td>默认值，有则加入，无则创建新事务</td></tr><tr><td>REQUIRES_NEW</td><td>需要新事务，无论有无，总是创建新事务（有则挂起上一个事务，当新当前创建的事务完成后，再继续上一个事务）</td></tr><tr><td>SUPPORTS</td><td>支持事务，有则加入，无则在事务状态中运行</td></tr><tr><td>NOT_SUPPORTED</td><td>不支持事务，在无事务状态下运行，如果当前已存在事务，则挂起当前事务</td></tr><tr><td>MANDATORY</td><td>必须有事务，否则抛异常</td></tr><tr><td>NEVER</td><td>必须无事务，否则抛异常</td></tr><tr><td>…</td><td></td></tr></tbody></table><p>（有则加入，指的是调用此方法的上级方法有没有事务）</p><p><a href="https://developer.aliyun.com/article/1610960">Spring事务传播机制（最全示例）-阿里云开发者社区</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring事务管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring事务管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker概念</title>
    <link href="/2025/08/30/docker/Docker%E6%A6%82%E5%BF%B5/"/>
    <url>/2025/08/30/docker/Docker%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker概念"><a href="#Docker概念" class="headerlink" title="Docker概念"></a>Docker概念</h2><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>这个问题问到了 Docker 的核心底层逻辑，很关键！Docker 的实现核心是<strong>基于 Linux 内核的三大核心技术</strong>，通过对系统资源的隔离、限制和分层管理，模拟出独立的运行环境。</p><h4 id="核心实现技术"><a href="#核心实现技术" class="headerlink" title="核心实现技术"></a>核心实现技术</h4><ol><li>Namespace（命名空间）：实现资源隔离。Linux 提供 PID（进程）、Network（网络）、Mount（文件系统）等多种 Namespace，让容器内的进程看不到宿主机其他进程、网络设备等，形成 “独立视角”。</li><li>Cgroups（控制组）：实现资源限制。限制容器能使用的 CPU、内存、磁盘 IO 等资源上限，避免单个容器占用过多资源影响其他容器或宿主机。</li><li>UnionFS（联合文件系统）：实现分层存储。镜像由多个只读层叠加而成，容器启动时会在顶部添加一个可写层，所有修改都只作用于该层，既节省空间又能实现镜像复用。</li></ol><hr><h4 id="简单运行逻辑"><a href="#简单运行逻辑" class="headerlink" title="简单运行逻辑"></a>简单运行逻辑</h4><p>Docker 镜像先通过 UnionFS 加载分层文件系统，再通过 Namespace 为容器分配独立的资源视图，最后用 Cgroups 限定资源使用额度，最终让容器在隔离且受限的环境中运行，同时共享宿主机内核，启动速度远快于虚拟机。</p><h3 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker compose"></a>Docker compose</h3><p>​通过一个单独的docker-compose.yaml来定义一组关联的容器，帮助我们实现多个容器的一键部署。</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/09/cartoon/"/>
    <url>/2025/07/09/cartoon/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="zh-CN"><head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>卡通元素展示</title>  <style>    body {      background: #f8f8f5;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', 'STKaiti', serif;      color: #222;      margin: 0;      padding: 0;    }    h1 {      text-align: center;      color: #222;      margin-top: 32px;      font-size: 2.5em;      letter-spacing: 2px;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;      font-weight: bold;      text-shadow: 0 2px 0 #e5e5e0;    }    .cartoon-container {      display: flex;      flex-wrap: wrap;      justify-content: center;      gap: 32px;      margin: 40px auto;      max-width: 1000px;    }    .cartoon-card {      background: #fff;      border: none;      border-radius: 0;      box-shadow: none;      padding: 28px 18px 18px 18px;      display: flex;      flex-direction: column;      align-items: center;      width: 220px;      transition: transform 0.2s;      position: relative;      overflow: hidden;    }    .cartoon-card::before {      content: '';      position: absolute;      left: 0; top: 0; right: 0; bottom: 0;      background: url('https://cdn.jsdelivr.net/gh/zh-lx/pic-repo/ink-smudge.png') repeat;      opacity: 0.08;      pointer-events: none;      z-index: 0;    }    .cartoon-card > * { position: relative; z-index: 1; }    .cartoon-card:hover {      transform: translateY(-4px) scale(1.01);      box-shadow: 0 4px 16px rgba(80,80,80,0.08);    }    .cartoon-svg {      width: 100px;      height: 100px;      margin-bottom: 16px;      filter: grayscale(0.7) contrast(0.8);    }    .cartoon-title {      font-size: 1.2em;      color: #2d3a4b;      margin-bottom: 8px;      font-weight: bold;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;    }    .cartoon-desc {      color: #444;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;      font-size: 1em;      text-align: center;    }    /* 轮播图样式 */    .carousel {      position: relative;      width: 100vw;      max-width: 100vw;      min-width: 0;      height: 340px;      margin: 0 auto 32px auto;      background: #f5f5f2;      border-radius: 0;      border: none;      box-shadow: none;      overflow: hidden;      display: flex;      align-items: center;      justify-content: center;    }    .carousel-track {      display: flex;      width: 100%;      height: 100%;      transition: transform 0.5s cubic-bezier(.4,2,.6,1);    }    .carousel-slide {      min-width: 100vw;      height: 100%;      display: flex;      align-items: center;      justify-content: center;      opacity: 0;      transition: opacity 0.5s;      position: absolute;      left: 0; top: 0;    }    .carousel-slide.active {      opacity: 1;      position: relative;    }    .carousel-slide img {      max-width: 320px;      max-height: 320px;      width: auto;      height: auto;      object-fit: contain;      user-select: none;      filter: grayscale(1) contrast(0.7);      display: block;      margin: 0 auto;    }    .carousel-btn {      position: absolute;      top: 50%;      transform: translateY(-50%);      background: rgba(0,0,0,0.08);      border: none;      border-radius: 0;      width: 44px;      height: 44px;      font-size: 2em;      color: #222;      cursor: pointer;      z-index: 2;      transition: background 0.2s;    }    .carousel-btn:hover {      background: #e5e5e0;    }    .carousel-btn.prev { left: 24px; }    .carousel-btn.next { right: 24px; }    .carousel-dots {      position: absolute;      bottom: 18px;      left: 50%;      transform: translateX(-50%);      display: flex;      gap: 12px;    }    .carousel-dots .dot {      width: 10px;      height: 10px;      border-radius: 50%;      background: #bbb;      border: none;      opacity: 0.5;      cursor: pointer;      transition: background 0.2s, opacity 0.2s;    }    .carousel-dots .dot.active {      background: #222;      opacity: 1;    }    /* 水墨竹叶装饰样式 */    .grass {      position: fixed;      width: 80px;      height: 54px;      pointer-events: none;      z-index: 10;      opacity: 0.7;      filter: grayscale(1) contrast(0.7);    }    .grass-bl { left: 0; bottom: 0; transform: scale(1.1) rotate(-3deg); }    .grass-br { right: 0; bottom: 0; transform: scale(1.1) rotate(3deg); }    .grass-tl { left: 0; top: 0; transform: scale(0.9) rotate(-8deg); }    .grass-tr { right: 0; top: 0; transform: scale(0.9) rotate(8deg); }    /* 公告板样式 */    .notice-board {      margin: 24px auto 0 auto;      max-width: 480px;      background: #f5f5f2;      border-radius: 0;      box-shadow: none;      border: none;      padding: 18px 28px 18px 28px;      position: relative;      z-index: 1;      text-align: center;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;    }    .notice-title {      font-size: 1.25em;      color: #222;      font-weight: bold;      margin-bottom: 10px;      letter-spacing: 1px;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;    }    .notice-list {      list-style: none;      padding: 0;      margin: 0;    }    .notice-list li {      color: #444;      font-size: 1.08em;      margin: 8px 0;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;      letter-spacing: 1px;    }    .top-flex {      display: flex;      justify-content: center;      align-items: flex-start;      gap: 40px;      margin: 32px auto 0 auto;      max-width: 900px;      flex-wrap: wrap;    }    .top-flex .notice-board {      margin: 0;      flex: 1 1 320px;      min-width: 240px;      max-width: 420px;    }    .top-flex .carousel {      margin: 0;      flex: 1 1 320px;      min-width: 240px;      max-width: 380px;    }    @media (max-width: 900px) {      .top-flex {        flex-direction: column;        align-items: center;        gap: 24px;      }      .top-flex .notice-board, .top-flex .carousel {        max-width: 95vw;      }    }    @media (max-width: 900px) {      .carousel {        height: 200px;      }      .carousel-slide img {        max-width: 140px;        max-height: 140px;      }    }    .cartoon-container {      margin-top: 32px;    }    .page-subtitle {      text-align: center;      color: #888;      font-size: 1.1em;      margin: 16px auto 32px auto;      max-width: 600px;      line-height: 1.6;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;    }    /* 浮动装饰图标 */    .floating-icons {      position: fixed;      top: 0;      left: 0;      width: 100%;      height: 100%;      pointer-events: none;      z-index: 5;    }    .floating-icon {      position: absolute;      font-size: 24px;      opacity: 0.3;      color: #222;      filter: grayscale(1) contrast(0.7);      animation: float 6s ease-in-out infinite;    }    .floating-icon:nth-child(1) { top: 15%; left: 10%; animation-delay: 0s; }    .floating-icon:nth-child(2) { top: 25%; right: 15%; animation-delay: 1s; }    .floating-icon:nth-child(3) { top: 60%; left: 5%; animation-delay: 2s; }    .floating-icon:nth-child(4) { top: 70%; right: 10%; animation-delay: 3s; }    .floating-icon:nth-child(5) { top: 85%; left: 20%; animation-delay: 4s; }    .floating-icon:nth-child(6) { top: 40%; right: 5%; animation-delay: 5s; }    @keyframes float {      0%, 100% { transform: translateY(0px) rotate(0deg); }      50% { transform: translateY(-20px) rotate(10deg); }    }    /* 今日推荐区域 */    .recommendation-section {      margin: 48px auto 32px auto;      max-width: 1000px;      padding: 0 20px;    }    .section-title {      text-align: center;      color: #222;      font-size: 2em;      margin-bottom: 32px;      letter-spacing: 1px;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;    }    .recommendation-grid {      display: grid;      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));      gap: 24px;    }    .recommendation-item {      background: #fff;      border-radius: 0;      border: none;      padding: 24px;      text-align: center;      box-shadow: none;      transition: transform 0.2s, box-shadow 0.2s;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;      position: relative;      overflow: hidden;    }    .recommendation-item::before {      content: '';      position: absolute;      left: 0; top: 0; right: 0; bottom: 0;      background: url('https://cdn.jsdelivr.net/gh/zh-lx/pic-repo/ink-smudge.png') repeat;      opacity: 0.08;      pointer-events: none;      z-index: 0;    }    .recommendation-item > * { position: relative; z-index: 1; }    .recommendation-item:hover {      transform: translateY(-2px);      box-shadow: 0 4px 12px rgba(80,80,80,0.06);    }    .rec-icon {      font-size: 2.5em;      margin-bottom: 16px;      color: #222;      filter: grayscale(1) contrast(0.7);    }    .recommendation-item h3 {      color: #2d3a4b;      margin-bottom: 12px;      font-size: 1.3em;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;    }    .recommendation-item p {      color: #444;      line-height: 1.5;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;    }    /* 页脚 */    .page-footer {      background: #f5f5f2;      margin-top: 48px;      padding: 32px 20px;      text-align: center;      border-top: none;    }    .footer-content p {      color: #888;      margin: 8px 0;      font-size: 1.1em;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;    }    .side-ink {      position: fixed;      top: 0;      width: 80px;      height: 100vh;      z-index: 2;      pointer-events: none;    }    .side-ink-left {      left: 0;    }    .side-ink-right {      right: 0;      transform: scaleX(-1);    }    @media (max-width: 900px) {      .side-ink { display: none; }    }    .xuan-bg {      position: fixed;      left: 0; top: 0; width: 100vw; height: 100vh;      z-index: 0;      pointer-events: none;      background: url('https://cdn.jsdelivr.net/gh/zh-lx/pic-repo/xuan-paper-light.png') repeat;      opacity: 0.18;    }    .vertical-poem {      position: fixed;      left: 12px;      top: 30%;      writing-mode: vertical-rl;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;      color: #b91c1c;      font-size: 1.2em;      opacity: 0.7;      z-index: 10;      letter-spacing: 0.2em;      pointer-events: none;    }    .seal-stamp {      position: fixed;      right: 32px;      bottom: 32px;      width: 60px;      height: 60px;      z-index: 20;      pointer-events: none;    }    @media (max-width: 900px) {      .seal-stamp, .vertical-poem { display: none; }    }    /* 主要元素淡入动画 */    .carousel, .cartoon-container, .recommendation-section, .notice-board, .page-footer, h1, .page-subtitle {      opacity: 0;      animation: fadein 1.2s ease forwards;    }    .carousel { animation-delay: 0.1s; }    h1 { animation-delay: 0.3s; }    .page-subtitle { animation-delay: 0.5s; }    .cartoon-container { animation-delay: 0.7s; }    .recommendation-section { animation-delay: 0.9s; }    .notice-board { animation-delay: 1.1s; }    .page-footer { animation-delay: 1.3s; }    @keyframes fadein {      from { opacity: 0; transform: translateY(24px); }      to { opacity: 1; transform: none; }    }    .poem-banner {      position: fixed;      top: 0; left: 0; width: 100vw;      z-index: 100;      background: rgba(255,255,255,0.7);      border-bottom: 1.5px solid #e5e5e0;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;      color: #222;      font-size: 1.18em;      letter-spacing: 0.1em;      text-align: center;      padding: 12px 0 8px 0;      box-shadow: 0 2px 12px rgba(80,80,80,0.04);      opacity: 0.95;      user-select: none;      pointer-events: none;      animation: fadein 1.2s ease forwards;      animation-delay: 0s;    }    @media (max-width: 900px) {      .poem-banner { font-size: 1em; padding: 8px 0 6px 0; }    }    /* 推荐区和卡片悬停墨晕 */    .cartoon-card, .recommendation-item {      transition: box-shadow 0.2s, transform 0.2s;    }    .cartoon-card:hover::after, .recommendation-item:hover::after {      content: '';      position: absolute;      left: 50%; top: 50%;      transform: translate(-50%, -50%);      width: 120%; height: 80%;      pointer-events: none;      border-radius: 50%;      background: radial-gradient(circle, rgba(34,34,34,0.13) 0%, rgba(34,34,34,0.04) 70%, transparent 100%);      z-index: 2;      opacity: 1;      animation: inkfade 0.7s;    }    .cartoon-card::after, .recommendation-item::after {      content: '';      position: absolute;      left: 50%; top: 50%;      transform: translate(-50%, -50%);      width: 120%; height: 80%;      pointer-events: none;      border-radius: 50%;      background: radial-gradient(circle, rgba(34,34,34,0.13) 0%, rgba(34,34,34,0.04) 70%, transparent 100%);      z-index: 2;      opacity: 0;      transition: opacity 0.3s;    }    @keyframes inkfade {      from { opacity: 0; }      to { opacity: 1; }    }    /* 两侧竹叶轻微摆动动画 */    .grass {      animation: bamboo-sway 5s ease-in-out infinite alternate;      transform-origin: 50% 100%;    }    .grass-tl, .grass-tr {      animation-delay: 2s;    }    @keyframes bamboo-sway {      0% { transform: rotate(-2deg) scale(1.1); }      50% { transform: rotate(4deg) scale(1.13); }      100% { transform: rotate(-2deg) scale(1.1); }    }    /* 轮播图下方水墨分割线 */    .ink-divider {      width: 220px;      max-width: 40vw;      margin: 0 auto 24px auto;      display: block;      opacity: 0.22;    }    /* 竖排诗句墨迹背景 */    .vertical-poem {      position: fixed;      left: 12px;      top: 30%;      writing-mode: vertical-rl;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;      color: #b91c1c;      font-size: 1.2em;      opacity: 0.7;      z-index: 10;      letter-spacing: 0.2em;      pointer-events: none;      padding: 12px 8px 12px 8px;    }    .vertical-poem::before {      content: '';      position: absolute;      left: 0; top: 0; right: 0; bottom: 0;      background: url('https://cdn.jsdelivr.net/gh/zh-lx/pic-repo/ink-smudge2.png') center/cover no-repeat;      opacity: 0.13;      z-index: -1;      border-radius: 12px;    }    /* 页脚小字版权 */    .footer-copyright {      color: #bbb;      font-size: 0.95em;      margin-top: 18px;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;      letter-spacing: 0.1em;    }    .title-row {      display: flex;      align-items: center;      justify-content: center;      gap: 18px;      margin-top: 48px;      margin-bottom: 0;    }    .main-seal {      width: 48px; height: 48px;      margin-left: 8px;      vertical-align: middle;      box-shadow: 0 2px 8px rgba(185,28,28,0.08);    }    .cartoon-card, .recommendation-item, .notice-board {      background: #fff;      border-radius: 0;      box-shadow: none;      position: relative;      overflow: hidden;    }    .cartoon-card::before, .recommendation-item::before, .notice-board::before {      content: '';      position: absolute;      left: 0; top: 0; right: 0; bottom: 0;      background: url('https://cdn.jsdelivr.net/gh/zh-lx/pic-repo/ink-smudge2.png') center/cover no-repeat;      opacity: 0.10;      pointer-events: none;      z-index: 0;    }    .cartoon-card > *, .recommendation-item > *, .notice-board > * { position: relative; z-index: 1; }    .rec-ink-icon {      width: 38px; height: 38px; margin-bottom: 12px; display: block;    }    .notice-title {      font-size: 1.25em;      color: #222;      font-weight: bold;      margin-bottom: 10px;      letter-spacing: 1px;      font-family: 'FZKai-Z03', '楷体', 'KaiTi', serif;      display: inline-block;      padding: 4px 18px;      border-radius: 8px;      background: rgba(185,28,28,0.08);      box-shadow: 0 2px 8px rgba(185,28,28,0.04);    }    .carousel-bg-ink {      position: relative;      width: 100vw;      max-width: 100vw;      min-width: 0;      height: 340px;      margin: 0 auto 32px auto;      display: flex;      align-items: center;      justify-content: center;      z-index: 1;    }    .carousel-ink-svg {      position: absolute;      left: 0; top: 0; width: 100vw; height: 340px;      z-index: 0;      pointer-events: none;    }    .carousel {      position: relative;      width: 100vw;      max-width: 100vw;      min-width: 0;      height: 340px;      margin: 0 auto;      background: transparent;      border-radius: 0;      border: none;      box-shadow: none;      overflow: hidden;      display: flex;      align-items: center;      justify-content: center;      z-index: 1;    }    .main-content {      max-width: 820px;      margin: 0 auto;      padding: 0 16px;    }    .title-row {      margin-top: 64px;      margin-bottom: 0;    }    .carousel-bg-ink {      margin: 48px auto 32px auto;      max-width: 820px;      width: 100%;      border-radius: 18px;      background: #fff;      box-shadow: 0 4px 32px rgba(34,34,34,0.04);      position: relative;      overflow: hidden;      display: flex;      align-items: center;      justify-content: center;      min-height: 320px;    }    .carousel {      width: 100%;      height: 100%;      min-height: 320px;      display: flex;      align-items: center;      justify-content: center;      background: transparent;      position: relative;    }    .carousel-track {      width: 100%;      height: 100%;      display: flex;      align-items: center;      justify-content: center;      position: relative;    }    .carousel-slide {      width: 100%;      height: 100%;      display: flex;      align-items: center;      justify-content: center;      position: absolute;      left: 0; top: 0;      opacity: 0;      transition: opacity 0.5s;    }    .carousel-slide.active {      opacity: 1;      position: relative;    }    .carousel-slide svg {      max-width: 90%;      max-height: 90%;      display: block;      margin: 0 auto;    }    .carousel-btn {      position: absolute;      top: 50%;      transform: translateY(-50%);      background: rgba(0,0,0,0.08);      border: none;      border-radius: 0;      width: 44px;      height: 44px;      font-size: 2em;      color: #222;      cursor: pointer;      z-index: 2;      transition: background 0.2s;    }    .carousel-btn.prev { left: 16px; }    .carousel-btn.next { right: 16px; }    .carousel-dots {      position: absolute;      bottom: 18px;      left: 50%;      transform: translateX(-50%);      display: flex;      gap: 12px;      z-index: 2;    }    .carousel-dots .dot {      width: 10px;      height: 10px;      border-radius: 50%;      background: #bbb;      border: none;      opacity: 0.5;      cursor: pointer;      transition: background 0.2s, opacity 0.2s;    }    .carousel-dots .dot.active {      background: #222;      opacity: 1;    }    @media (max-width: 900px) {      .carousel-bg-ink, .carousel {        min-height: 160px;        max-width: 98vw;      }      .carousel-btn {        width: 32px;        height: 32px;        font-size: 1.2em;      }      .carousel-btn.prev { left: 4px; }      .carousel-btn.next { right: 4px; }      .carousel-dots { bottom: 8px; gap: 6px; }    }    .cartoon-container {      max-width: 820px;      margin: 0 auto 56px auto;      gap: 40px;      justify-content: center;    }    .cartoon-card {      background: #fff;      border-radius: 0;      box-shadow: none;      position: relative;      overflow: hidden;      margin-bottom: 0;      min-height: 220px;    }    .cartoon-card::before {      background: url('https://cdn.jsdelivr.net/gh/zh-lx/pic-repo/ink-smudge2.png') center/cover no-repeat;      opacity: 0.08;    }    .recommendation-section {      max-width: 820px;      margin: 0 auto 56px auto;      padding: 0 16px;    }    .recommendation-grid {      gap: 40px;    }    .recommendation-item {      background: #fff;      border-radius: 0;      box-shadow: none;      position: relative;      overflow: hidden;      min-height: 180px;    }    .recommendation-item::before {      background: url('https://cdn.jsdelivr.net/gh/zh-lx/pic-repo/ink-smudge2.png') center/cover no-repeat;      opacity: 0.08;    }    .notice-board {      max-width: 600px;      margin: 64px auto 0 auto;      background: #fff;      border-radius: 0;      box-shadow: none;      position: relative;      overflow: hidden;      padding: 32px 32px 24px 32px;    }    .notice-board::before {      background: url('https://cdn.jsdelivr.net/gh/zh-lx/pic-repo/ink-smudge2.png') center/cover no-repeat;      opacity: 0.08;    }    /* 去除所有SVG椭圆灰色背景 */    .cartoon-svg ellipse,    .cartoon-svg .ellipse,    .rec-ink-icon ellipse {      display: none;    }    .ink-divider ellipse { display: none; }    /* 竖排诗句位置微调 */    .vertical-poem {      left: 2vw;      top: 32%;    }    @media (max-width: 900px) {      .main-content, .cartoon-container, .recommendation-section, .carousel-bg-ink, .carousel {        max-width: 98vw;        padding: 0 2vw;      }      .notice-board {        max-width: 98vw;        padding: 18px 6vw 12px 6vw;      }      .vertical-poem { left: 0.5vw; }    }  </style></head><body>  <div class="xuan-bg"></div>  <div class="poem-banner" id="poemBanner"></div>  <!-- 竖排诗句装饰 -->  <div class="vertical-poem">山高水长<br>墨韵悠扬</div>  <!-- 主内容区 -->  <div class="main-content">    <div class="title-row">      <h1>水墨意境集</h1>      <svg class="main-seal" viewBox="0 0 48 48">        <circle cx="24" cy="24" r="22" fill="#b91c1c" opacity="0.85"/>        <text x="24" y="31" text-anchor="middle" font-size="18" fill="#fff" font-family="FZKai-Z03, KaiTi, serif">墨韵</text>      </svg>    </div>    <p class="page-subtitle">一纸素心，半壶清茶。墨染山川，风雅自来。<br>在这里，感受东方水墨的静谧与诗意。</p>    <!-- 轮播图 -->    <div class="carousel-bg-ink">      <div class="carousel">        <div class="carousel-track">          <div class="carousel-slide active">            <!-- 水墨熊猫SVG（无ellipse） -->            <svg viewBox="0 0 200 200" style="width:90%;height:90%;max-width:320px;max-height:320px;">              <ellipse cx="60" cy="70" rx="22" ry="18" fill="#222" opacity="0.18"/>              <ellipse cx="140" cy="70" rx="22" ry="18" fill="#222" opacity="0.18"/>              <ellipse cx="100" cy="120" rx="45" ry="40" fill="#fff" stroke="#222" stroke-width="4"/>              <ellipse cx="75" cy="110" rx="8" ry="10" fill="#222"/>              <ellipse cx="125" cy="110" rx="8" ry="10" fill="#222"/>              <ellipse cx="75" cy="110" rx="3" ry="4" fill="#fff" opacity="0.7"/>              <ellipse cx="125" cy="110" rx="3" ry="4" fill="#fff" opacity="0.7"/>              <ellipse cx="100" cy="140" rx="12" ry="6" fill="#fff"/>              <ellipse cx="100" cy="150" rx="8" ry="3" fill="#222" opacity="0.18"/>            </svg>          </div>          <div class="carousel-slide">            <!-- 水墨兔子SVG（无ellipse） -->            <svg viewBox="0 0 200 200" style="width:90%;height:90%;max-width:320px;max-height:320px;">              <ellipse cx="100" cy="130" rx="55" ry="45" fill="#fff" stroke="#222" stroke-width="4"/>              <ellipse cx="70" cy="70" rx="16" ry="38" fill="#fff" stroke="#222" stroke-width="3"/>              <ellipse cx="130" cy="70" rx="16" ry="38" fill="#fff" stroke="#222" stroke-width="3"/>              <ellipse cx="85" cy="130" rx="8" ry="10" fill="#222"/>              <ellipse cx="115" cy="130" rx="8" ry="10" fill="#222"/>              <ellipse cx="85" cy="130" rx="3" ry="4" fill="#fff" opacity="0.7"/>              <ellipse cx="115" cy="130" rx="3" ry="4" fill="#fff" opacity="0.7"/>              <ellipse cx="100" cy="155" rx="10" ry="4" fill="#fff"/>            </svg>          </div>          <div class="carousel-slide">            <!-- 水墨星星SVG（无ellipse） -->            <svg viewBox="0 0 200 200" style="width:90%;height:90%;max-width:320px;max-height:320px;">              <polygon points="100,40 120,90 175,90 130,125 145,180 100,150 55,180 70,125 25,90 80,90" fill="#fff" stroke="#222" stroke-width="5" opacity="0.95"/>              <ellipse cx="100" cy="110" rx="10" ry="5" fill="#fff" opacity="0.7"/>            </svg>          </div>        </div>        <button class="carousel-btn prev">&#8592;</button>        <button class="carousel-btn next">&#8594;</button>        <div class="carousel-dots">          <span class="dot active"></span>          <span class="dot"></span>          <span class="dot"></span>        </div>      </div>    </div>    <svg class="ink-divider" viewBox="0 0 220 12">      <path d="M10,8 Q60,2 110,8 Q160,14 210,8" stroke="#222" stroke-width="2" fill="none" opacity="0.5"/>    </svg>    <div class="cartoon-container">      <!-- 卡片1：竹叶 -->      <div class="cartoon-card">        <svg class="cartoon-svg" viewBox="0 0 100 100">          <path d="M20,80 Q50,10 80,80" stroke="#222" stroke-width="4" fill="none" opacity="0.7"/>        </svg>        <div class="cartoon-title">竹影清风</div>        <div class="cartoon-desc">一叶竹影，清风徐来，心归自然。</div>      </div>      <!-- 卡片2：山石 -->      <div class="cartoon-card">        <svg class="cartoon-svg" viewBox="0 0 100 100">          <path d="M20,70 Q40,30 60,70 Q80,50 90,70" stroke="#222" stroke-width="3" fill="none" opacity="0.7"/>        </svg>        <div class="cartoon-title">山高水长</div>        <div class="cartoon-desc">山色有无，水流不息，意境悠远。</div>      </div>      <!-- 卡片3：扇子 -->      <div class="cartoon-card">        <svg class="cartoon-svg" viewBox="0 0 100 100">          <path d="M20,80 Q50,30 80,80" stroke="#222" stroke-width="3" fill="none" opacity="0.7"/>          <path d="M35,80 Q50,60 65,80" stroke="#222" stroke-width="2" fill="none" opacity="0.5"/>        </svg>        <div class="cartoon-title">素扇生风</div>        <div class="cartoon-desc">素扇轻摇，清风自来，雅致人生。</div>      </div>      <!-- 卡片4：梅花 -->      <div class="cartoon-card">        <svg class="cartoon-svg" viewBox="0 0 100 100">          <circle cx="50" cy="50" r="12" fill="#fff" stroke="#222" stroke-width="2"/>          <circle cx="50" cy="38" r="4" fill="#222" opacity="0.7"/>          <circle cx="62" cy="54" r="3" fill="#222" opacity="0.7"/>          <circle cx="38" cy="54" r="3" fill="#222" opacity="0.7"/>          <circle cx="56" cy="62" r="2.5" fill="#222" opacity="0.7"/>          <circle cx="44" cy="62" r="2.5" fill="#222" opacity="0.7"/>        </svg>        <div class="cartoon-title">暗香疏影</div>        <div class="cartoon-desc">梅花点点，暗香浮动，清雅自持。</div>      </div>    </div>    <div class="recommendation-section">      <h2 class="section-title">今日雅荐</h2>      <div class="recommendation-grid">        <div class="recommendation-item">          <svg class="rec-ink-icon" viewBox="0 0 40 40">            <path d="M10,30 Q20,10 30,30" stroke="#222" stroke-width="2" fill="none" opacity="0.7"/>          </svg>          <h3>墨韵丹青</h3>          <p>挥毫泼墨，写意山水，感受笔下的灵动与空灵。</p>        </div>        <div class="recommendation-item">          <svg class="rec-ink-icon" viewBox="0 0 40 40">            <path d="M10,30 Q20,10 30,30" stroke="#222" stroke-width="2" fill="none" opacity="0.7"/>          </svg>          <h3>古韵清音</h3>          <p>聆听古筝、箫声，心随音律，静享片刻安然。</p>        </div>        <div class="recommendation-item">          <svg class="rec-ink-icon" viewBox="0 0 40 40">            <circle cx="20" cy="20" r="8" fill="#fff" stroke="#222" stroke-width="2"/>          </svg>          <h3>诗书茶香</h3>          <p>品茗读诗，字里行间皆是风雅与悠远。</p>        </div>        <div class="recommendation-item">          <svg class="rec-ink-icon" viewBox="0 0 40 40">            <path d="M20,10 Q22,18 28,18" stroke="#222" stroke-width="2" fill="none" opacity="0.7"/>          </svg>          <h3>竹影清风</h3>          <p>观竹听风，心归自然，体味一份清幽与自在。</p>        </div>      </div>    </div>    <div class="notice-board">      <div class="notice-title">墨语流芳 · 古韵今风</div>      <ul class="notice-list">        <li>疏影横斜水清浅，暗香浮动月黄昏。</li>        <li>一蓑烟雨任平生，竹杖芒鞋轻胜马。</li>        <li>采菊东篱下，悠然见南山。</li>        <li>明月松间照，清泉石上流。</li>        <li>山色有无中，烟霞淡泊里。</li>      </ul>    </div>    <footer class="page-footer">      <div class="footer-content">        <p>感谢驻足水墨世界</p>        <p>愿你心如止水，岁月安然。</p>        <div class="footer-copyright">© 2024 水墨意境集 All Rights Reserved.</div>      </div>    </footer>  </div>  <!-- 右下角印章装饰 -->  <svg class="seal-stamp" viewBox="0 0 60 60">    <circle cx="30" cy="30" r="28" fill="#b91c1c" opacity="0.85"/>    <text x="30" y="38" text-anchor="middle" font-size="22" fill="#fff" font-family="FZKai-Z03, KaiTi, serif">雅集</text>  </svg>  <script>    // 轮播图JS    const slides = document.querySelectorAll('.carousel-slide');    const prevBtn = document.querySelector('.carousel-btn.prev');    const nextBtn = document.querySelector('.carousel-btn.next');    const dots = document.querySelectorAll('.carousel-dots .dot');    let current = 0;    let timer = null;    function showSlide(idx) {      slides.forEach((slide, i) => {        slide.classList.toggle('active', i === idx);        dots[i].classList.toggle('active', i === idx);      });      current = idx;    }    function nextSlide() {      showSlide((current + 1) % slides.length);    }    function prevSlide() {      showSlide((current - 1 + slides.length) % slides.length);    }    function startAuto() {      timer = setInterval(nextSlide, 3000);    }    function stopAuto() {      clearInterval(timer);    }    prevBtn.addEventListener('click', () => { prevSlide(); stopAuto(); startAuto(); });    nextBtn.addEventListener('click', () => { nextSlide(); stopAuto(); startAuto(); });    dots.forEach((dot, i) => {      dot.addEventListener('click', () => { showSlide(i); stopAuto(); startAuto(); });    });    showSlide(0);    startAuto();    // 一言古诗词自动轮播    const poemList = [      '云想衣裳花想容，春风拂槛露华浓。',      '疏影横斜水清浅，暗香浮动月黄昏。',      '明月松间照，清泉石上流。',      '采菊东篱下，悠然见南山。',      '一蓑烟雨任平生，竹杖芒鞋轻胜马。',      '山色有无中，烟霞淡泊里。',      '落霞与孤鹜齐飞，秋水共长天一色。',      '人生若只如初见，何事秋风悲画扇。',      '小楼一夜听春雨，深巷明朝卖杏花。',      '江流天地外，山色有无中。'    ];    let poemIdx = 0;    const poemBanner = document.getElementById('poemBanner');    function showPoem(idx) {      poemBanner.style.opacity = 0;      setTimeout(() => {        poemBanner.textContent = poemList[idx];        poemBanner.style.opacity = 0.95;      }, 400);    }    showPoem(poemIdx);    setInterval(() => {      poemIdx = (poemIdx + 1) % poemList.length;      showPoem(poemIdx);    }, 4200);  </script>  <!-- 左侧竖排诗句 -->  <svg class="vertical-poem" viewBox="0 0 100 100">    <path d="M50,50 Q50,10 50,50 Q50,90 50,50" stroke="#222" stroke-width="2" fill="none" opacity="0.7"/>    <ellipse cx="50" cy="50" rx="18" ry="3" fill="#222" opacity="0.13"/>  </svg>  <!-- 右侧水墨山水装饰 -->  <svg class="side-ink side-ink-right" viewBox="0 0 80 600" preserveAspectRatio="none">    <path d="M70,550 Q50,500 60,400 Q70,300 40,200 Q20,100 60,50" stroke="#222" stroke-width="2" fill="none" opacity="0.13"/>    <ellipse cx="50" cy="500" rx="18" ry="8" fill="#222" opacity="0.08"/>    <ellipse cx="30" cy="300" rx="22" ry="10" fill="#222" opacity="0.06"/>    <path d="M60,400 Q50,390 40,400" stroke="#222" stroke-width="1.2" fill="none" opacity="0.18"/>    <ellipse cx="50" cy="395" rx="7" ry="2" fill="#222" opacity="0.12"/>  </svg>  <!-- 草装饰 开始 -->  <svg class="grass grass-bl" viewBox="0 0 60 40">    <path d="M10 40 Q15 10 20 40 Q25 20 30 40 Q35 10 40 40 Q45 25 50 40" fill="none" stroke="#22c55e" stroke-width="4"/>    <ellipse cx="15" cy="38" rx="6" ry="3" fill="#4ade80"/>    <ellipse cx="30" cy="38" rx="7" ry="3.5" fill="#4ade80"/>    <ellipse cx="45" cy="38" rx="6" ry="3" fill="#4ade80"/>  </svg>  <svg class="grass grass-br" viewBox="0 0 60 40">    <path d="M10 40 Q15 10 20 40 Q25 20 30 40 Q35 10 40 40 Q45 25 50 40" fill="none" stroke="#22c55e" stroke-width="4"/>    <ellipse cx="15" cy="38" rx="6" ry="3" fill="#4ade80"/>    <ellipse cx="30" cy="38" rx="7" ry="3.5" fill="#4ade80"/>    <ellipse cx="45" cy="38" rx="6" ry="3" fill="#4ade80"/>  </svg>  <svg class="grass grass-tl" viewBox="0 0 60 40">    <path d="M10 40 Q15 10 20 40 Q25 20 30 40 Q35 10 40 40 Q45 25 50 40" fill="none" stroke="#22c55e" stroke-width="4"/>    <ellipse cx="15" cy="38" rx="6" ry="3" fill="#4ade80"/>    <ellipse cx="30" cy="38" rx="7" ry="3.5" fill="#4ade80"/>    <ellipse cx="45" cy="38" rx="6" ry="3" fill="#4ade80"/>  </svg>  <svg class="grass grass-tr" viewBox="0 0 60 40">    <path d="M10 40 Q15 10 20 40 Q25 20 30 40 Q35 10 40 40 Q45 25 50 40" fill="none" stroke="#22c55e" stroke-width="4"/>    <ellipse cx="15" cy="38" rx="6" ry="3" fill="#4ade80"/>    <ellipse cx="30" cy="38" rx="7" ry="3.5" fill="#4ade80"/>    <ellipse cx="45" cy="38" rx="6" ry="3" fill="#4ade80"/>  </svg>  <!-- 草装饰 结束 -->  <!-- 装饰性小图标 -->  <div class="floating-icons">    <span class="floating-icon">🌸</span>    <span class="floating-icon">🍀</span>    <span class="floating-icon">⭐</span>    <span class="floating-icon">🎈</span>    <span class="floating-icon">🌈</span>    <span class="floating-icon">🎉</span>  </div></body></html> ]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>修改 Spring Boot 项目中 Tomcat 的最大连接数</title>
    <link href="/2025/07/08/java/%E4%BF%AE%E6%94%B9SpringBoot%E9%A1%B9%E7%9B%AETomcat%E8%BF%9E%E6%8E%A5%E6%95%B0/"/>
    <url>/2025/07/08/java/%E4%BF%AE%E6%94%B9SpringBoot%E9%A1%B9%E7%9B%AETomcat%E8%BF%9E%E6%8E%A5%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="🚀-Spring-Boot-修改-Tomcat-最大连接数指南"><a href="#🚀-Spring-Boot-修改-Tomcat-最大连接数指南" class="headerlink" title="🚀 Spring Boot 修改 Tomcat 最大连接数指南"></a>🚀 Spring Boot 修改 Tomcat 最大连接数指南</h1><p>Spring Boot 内置了 Tomcat 作为默认的 Web 服务器。默认情况下，Tomcat 的最大连接数（maxConnections）有一定限制。若并发量较大，建议根据实际需求调整该参数。</p><hr><h2 id="1️⃣-通过-application-properties-配置"><a href="#1️⃣-通过-application-properties-配置" class="headerlink" title="1️⃣ 通过 application.properties 配置"></a>1️⃣ 通过 application.properties 配置</h2><p>在 <code>src/main/resources/application.properties</code> 文件中添加或修改如下配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 设置 Tomcat 最大连接数（默认为 8192）</span><br><span class="hljs-attr">spring.servlet.multipart.max-file-size</span>=<span class="hljs-string">10MB</span><br><span class="hljs-attr">spring.servlet.multipart.max-request-size</span>=<span class="hljs-string">10MB</span><br><span class="hljs-attr">server.tomcat.max-connections</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">server.tomcat.threads.max</span>=<span class="hljs-string">500</span><br></code></pre></td></tr></table></figure><ul><li><code>server.tomcat.max-connections</code>：设置最大连接数（如 2000）。</li><li><code>server.tomcat.threads.max</code>：设置最大工作线程数（如 500）。</li></ul><hr><h2 id="2️⃣-通过-application-yml-配置"><a href="#2️⃣-通过-application-yml-配置" class="headerlink" title="2️⃣ 通过 application.yml 配置"></a>2️⃣ 通过 application.yml 配置</h2><p>在 <code>src/main/resources/application.yml</code> 文件中添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">tomcat:</span><br>    <span class="hljs-attr">max-connections:</span> <span class="hljs-number">2000</span>   <span class="hljs-comment"># 最大连接数</span><br>    <span class="hljs-attr">threads:</span><br>      <span class="hljs-attr">max:</span> <span class="hljs-number">500</span>              <span class="hljs-comment"># 最大工作线程数</span><br></code></pre></td></tr></table></figure><hr><h2 id="3️⃣-通过-Java-代码方式自定义-Tomcat-Connector"><a href="#3️⃣-通过-Java-代码方式自定义-Tomcat-Connector" class="headerlink" title="3️⃣ 通过 Java 代码方式自定义 Tomcat Connector"></a>3️⃣ 通过 Java 代码方式自定义 Tomcat Connector</h2><p>如果需要更灵活的配置，可以通过 Java 代码自定义 Tomcat Connector：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;<br><span class="hljs-keyword">import</span> org.springframework.boot.web.server.WebServerFactoryCustomizer;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TomcatConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; <span class="hljs-title function_">customizer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> factory -&gt; factory.addConnectorCustomizers(connector -&gt; &#123;<br>            connector.setProperty(<span class="hljs-string">&quot;maxConnections&quot;</span>, <span class="hljs-string">&quot;2000&quot;</span>);<br>            connector.setProperty(<span class="hljs-string">&quot;maxThreads&quot;</span>, <span class="hljs-string">&quot;500&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="⚠️-注意事项"><a href="#⚠️-注意事项" class="headerlink" title="⚠️ 注意事项"></a>⚠️ 注意事项</h2><ul><li>增大连接数和线程数会增加服务器资源消耗，请根据服务器硬件配置合理设置。</li><li>若部署在云服务器或容器环境，需同步调整操作系统的最大文件句柄数（ulimit）等参数。</li><li>修改配置后需重启 Spring Boot 服务以生效。</li></ul><hr><blockquote><p>参考文档：</p><ul><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties.server.server.tomcat.max-connections">Spring Boot 官方文档 - Tomcat 配置</a></li><li><a href="https://tomcat.apache.org/tomcat-9.0-doc/config/http.html">Tomcat 官方文档</a></li></ul></blockquote><hr><h2 id="4️⃣-在-Kubernetes-k8s-环境下的配置方法"><a href="#4️⃣-在-Kubernetes-k8s-环境下的配置方法" class="headerlink" title="4️⃣ 在 Kubernetes (k8s) 环境下的配置方法"></a>4️⃣ 在 Kubernetes (k8s) 环境下的配置方法</h2><p>在 Kubernetes 部署 Spring Boot 项目时，Tomcat 最大连接数的配置同样重要。常见做法如下：</p><h3 id="4-1-通过-ConfigMap-挂载配置文件"><a href="#4-1-通过-ConfigMap-挂载配置文件" class="headerlink" title="4.1 通过 ConfigMap 挂载配置文件"></a>4.1 通过 ConfigMap 挂载配置文件</h3><p>可以将 <code>application.properties</code> 或 <code>application.yml</code> 配置通过 ConfigMap 挂载到容器内，实现参数灵活管理。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-config</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">application.yml:</span> <span class="hljs-string">|</span><br><span class="hljs-string">    server:</span><br><span class="hljs-string">      tomcat:</span><br><span class="hljs-string">        max-connections: 2000</span><br><span class="hljs-string">        threads:</span><br><span class="hljs-string">          max: 500</span><br></code></pre></td></tr></table></figure><p>在 Deployment 中挂载 ConfigMap：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-app</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">your-image:latest</span><br>          <span class="hljs-attr">volumeMounts:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>              <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/app/config/application.yml</span><br>              <span class="hljs-attr">subPath:</span> <span class="hljs-string">application.yml</span><br>      <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>          <span class="hljs-attr">configMap:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-config</span><br></code></pre></td></tr></table></figure><h3 id="4-2-通过环境变量注入"><a href="#4-2-通过环境变量注入" class="headerlink" title="4.2 通过环境变量注入"></a>4.2 通过环境变量注入</h3><p>Spring Boot 支持通过环境变量覆盖配置。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">env:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">SERVER_TOMCAT_MAX_CONNECTIONS</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;2000&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">SERVER_TOMCAT_THREADS_MAX</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;500&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-3-资源限制与最佳实践"><a href="#4-3-资源限制与最佳实践" class="headerlink" title="4.3 资源限制与最佳实践"></a>4.3 资源限制与最佳实践</h3><ul><li><strong>合理设置 Pod 资源限制</strong>：<ul><li>Tomcat 连接数和线程数受限于容器的 CPU&#x2F;内存资源，建议结合实际负载设置 <code>resources.limits</code> 和 <code>resources.requests</code>。</li></ul></li><li><strong>多副本横向扩展</strong>：<ul><li>若单 Pod 资源有限，可通过增加副本数（Replica）提升整体并发能力。</li></ul></li><li><strong>健康检查</strong>：<ul><li>配置 <code>readinessProbe</code> 和 <code>livenessProbe</code>，确保服务健康。</li></ul></li></ul><h3 id="4-4-注意事项"><a href="#4-4-注意事项" class="headerlink" title="4.4 注意事项"></a>4.4 注意事项</h3><ul><li>配置变更后需重启 Pod 以生效。</li><li>云原生环境下，建议将连接数和线程数设置为适合单 Pod 的合理值，避免单实例资源耗尽。</li><li>结合 HPA（Horizontal Pod Autoscaler）实现弹性伸缩。</li></ul><hr><blockquote><p>参考文档：</p><ul><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties.server.server.tomcat.max-connections">Spring Boot 官方文档 - Kubernetes 配置</a></li><li><a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/configmap/">Kubernetes ConfigMap 官方文档</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/inject-data-application/environment-variable-expose-pod-information/">Kubernetes 环境变量配置</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
      <tag>Tomcat</tag>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见操作</title>
    <link href="/2025/07/06/windows/%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
    <url>/2025/07/06/windows/%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="Windows-常见操作"><a href="#Windows-常见操作" class="headerlink" title="Windows 常见操作"></a>Windows 常见操作</h1><h2 id="1-Win11-搜索栏搜索磁盘清理"><a href="#1-Win11-搜索栏搜索磁盘清理" class="headerlink" title="1. Win11 搜索栏搜索磁盘清理"></a>1. Win11 搜索栏搜索磁盘清理</h2><blockquote><p>可以清除一些系统文件，释放磁盘空间。</p></blockquote><hr><h2 id="2-剪切板历史记录"><a href="#2-剪切板历史记录" class="headerlink" title="2. 剪切板历史记录"></a>2. 剪切板历史记录</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>按下以下组合键可调出剪切板历史记录：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Win + V<br></code></pre></td></tr></table></figure><hr><h3 id="如何开启剪切板历史记录？"><a href="#如何开启剪切板历史记录？" class="headerlink" title="如何开启剪切板历史记录？"></a>如何开启剪切板历史记录？</h3><p>依次进入：</p><ul><li><strong>系统</strong> → <strong>剪切板</strong></li><li>开启 <strong>剪切板历史记录</strong></li></ul><hr><h3 id="常见问题及解决方法"><a href="#常见问题及解决方法" class="headerlink" title="常见问题及解决方法"></a>常见问题及解决方法</h3><h4 id="1-Win-键被锁定导致不能使用"><a href="#1-Win-键被锁定导致不能使用" class="headerlink" title="1. Win 键被锁定导致不能使用"></a>1. Win 键被锁定导致不能使用</h4><ul><li><p>同时按下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Fn + Win<br></code></pre></td></tr></table></figure><p>即可解锁。</p></li></ul><h4 id="2-explorer-exe-程序占用了-Win-V-键"><a href="#2-explorer-exe-程序占用了-Win-V-键" class="headerlink" title="2. explorer.exe 程序占用了 Win+V 键"></a>2. explorer.exe 程序占用了 Win+V 键</h4><ul><li><p>重启资源管理器：</p><p>以管理员模式打开命令行，执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">taskkill /f /im explorer.exe &amp; <span class="hljs-built_in">start</span> explorer.exe<br></code></pre></td></tr></table></figure></li></ul><hr><h1 id="Windows-命令行操作"><a href="#Windows-命令行操作" class="headerlink" title="Windows 命令行操作"></a>Windows 命令行操作</h1><blockquote><p>常用 Windows CMD 操作命令整理，便于日常排查和管理。</p></blockquote><hr><h2 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">systeminfo<br></code></pre></td></tr></table></figure><ul><li>示例输出：<ul><li>系统类型:         x64-based PC</li></ul></li></ul><hr><h2 id="测试网络是否联通"><a href="#测试网络是否联通" class="headerlink" title="测试网络是否联通"></a>测试网络是否联通</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">ping</span> <span class="hljs-number">39</span>.<span class="hljs-number">98</span>.<span class="hljs-number">49</span>.<span class="hljs-number">95</span><br></code></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">telnet <span class="hljs-number">39</span>.<span class="hljs-number">98</span>.<span class="hljs-number">49</span>.<span class="hljs-number">95</span> <span class="hljs-number">7700</span><br></code></pre></td></tr></table></figure><hr><h2 id="查看处理器架构"><a href="#查看处理器架构" class="headerlink" title="查看处理器架构"></a>查看处理器架构</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">echo</span> <span class="hljs-variable">%PROCESSOR_ARCHITECTURE%</span><br></code></pre></td></tr></table></figure><ul><li><p>输出说明：</p><ul><li>ARM：ARM 架构 （精简指令集）（手机、平板）低功耗、可扩展性</li><li>AMD64：x86 架构（复杂指令集）（AMD 或 Intel 处理器）  高性能、丰富的指令集、兼容性强</li></ul><p>二者是不同的指令集架构，相当于不同的设计规范</p></li></ul><hr><h2 id="查找端口占用进程"><a href="#查找端口占用进程" class="headerlink" title="查找端口占用进程"></a>查找端口占用进程</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">netstat -ano | <span class="hljs-built_in">findstr</span> :<span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><hr><h2 id="根据-PID-查找进程"><a href="#根据-PID-查找进程" class="headerlink" title="根据 PID 查找进程"></a>根据 PID 查找进程</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">tasklist | <span class="hljs-built_in">findstr</span> <span class="hljs-number">10156</span><br></code></pre></td></tr></table></figure><hr><h2 id="结束指定-PID-的进程"><a href="#结束指定-PID-的进程" class="headerlink" title="结束指定 PID 的进程"></a>结束指定 PID 的进程</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">taskkill</span> /F /PID <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><ul><li>参数说明：<ul><li><code>/F</code>：强制终止进程</li><li><code>/PID</code>：指定要终止的进程 ID</li></ul></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常见操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo</title>
    <link href="/2025/06/22/java/%E4%B8%AD%E9%97%B4%E4%BB%B6/Dubbo/"/>
    <url>/2025/06/22/java/%E4%B8%AD%E9%97%B4%E4%BB%B6/Dubbo/</url>
    
    <content type="html"><![CDATA[<p>alibaba开源的rpc框架</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库三大范式</title>
    <link href="/2025/06/19/%E9%9A%8F%E7%AC%94/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/"/>
    <url>/2025/06/19/%E9%9A%8F%E7%AC%94/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前前后后刷到过许多次三大范式的文章，每次都会忘记，此次专门写篇笔记加深记忆</p></blockquote><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><blockquote><p>数据库中的列需要是不可分割的，需要具备原子性</p></blockquote><p>比如入职信息表，学校这一列，填入了学校名称、地址、电话三部分内容，这就是违反了第一范式。</p><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><blockquote><p>表中非主键字段必须完全依赖于主键，而不是部分依赖。</p></blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">学号 课程号 课程名称 课程分数 教师<span class="hljs-built_in">id</span> 教师名称<br>主键(学号、课程号)<br>课程名称只依赖于主键中的课程号，部分依赖<br></code></pre></td></tr></table></figure><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><blockquote><p>非主键字段之间不能存在传递依赖</p></blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">课程号 课程名称 教师<span class="hljs-built_in">id</span> 教师名称<br>主键(课程号)<br></code></pre></td></tr></table></figure><p>主要是为了减小数据的冗余</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>范式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装各种中间件</title>
    <link href="/2025/05/22/docker/Docker%E5%AE%89%E8%A3%85%E5%90%84%E7%A7%8D%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2025/05/22/docker/Docker%E5%AE%89%E8%A3%85%E5%90%84%E7%A7%8D%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p><strong>拉取镜像</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull mysql:<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>启动容器</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>--name mysql8.<span class="hljs-number">0</span>.<span class="hljs-number">30</span>-txsql <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>-e MYSQL_ROOT_PASSWORD=welcome1 <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>-p <span class="hljs-number">30600</span>:<span class="hljs-number">3306</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>-v /etc/localtime:/etc/localtime <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>-v ./data:/var/lib/mysql <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>-v ./conf.d:/etc/mysql/conf.d <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>mysql5<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; 本地目录挂载必须以 &#x2F; 或者 .&#x2F;开头，否则会被识别为数据卷</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff">docker run 创建并运行一个容器<br><span class="hljs-deletion">-d 在后台允许</span><br><span class="hljs-deletion">--name xxx 给容器起名字，需要唯一</span><br><span class="hljs-deletion">-p 30600:3306 端口映射 </span><br></code></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://blog.csdn.net/a772304419/article/details/142459098?spm=1001.2014.3001.5506">docker安装及运行MySQL 5.7容器完整脚本及解释-CSDN博客</a></p><h2 id="docker部署es"><a href="#docker部署es" class="headerlink" title="docker部署es"></a>docker部署es</h2><h5 id="es部署docker命令"><a href="#es部署docker命令" class="headerlink" title="es部署docker命令"></a>es部署docker命令</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  --name es <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -e <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -v es-data:/usr/share/elasticsearch/data <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -v es-plugins:/usr/share/elasticsearch/plugins <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  --privileged <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  elasticsearch:<span class="hljs-number">7</span>.<span class="hljs-number">12</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>访问如下地址，出现响应即可</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.30.130:9200</span><br></code></pre></td></tr></table></figure><h5 id="Kibana部署docker命令"><a href="#Kibana部署docker命令" class="headerlink" title="Kibana部署docker命令"></a>Kibana部署docker命令</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>--name kibana <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>-e ELASTICSEARCH_HOSTS=http://<span class="hljs-number">192.168.30.130:9200</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>-p <span class="hljs-number">5601</span>:<span class="hljs-number">5601</span>  <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>kibana:<span class="hljs-number">7</span>.<span class="hljs-number">12</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>访问如下地址</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.30.130:5601</span><br></code></pre></td></tr></table></figure><p>出现初始化界面，选择选择<code>Explore on my own</code>之后，进入主页面选择<a href="http://192.168.30.130:5601/app/dev_tools#/">Dev Tools</a></p><h5 id="IK分词器安装"><a href="#IK分词器安装" class="headerlink" title="IK分词器安装"></a>IK分词器安装</h5><ul><li>docker进入es容器</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> es bash<br></code></pre></td></tr></table></figure><ul><li>进入后使用如下连接安装，发现过期了，只能手动下载安装包，安装包从网络获取</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">[root@<span class="hljs-number">4</span>f0ed4099320 bin]<span class="hljs-meta"># elasticsearch-plugin install https:<span class="hljs-comment">//github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip</span></span><br></code></pre></td></tr></table></figure><ul><li>安装包连接</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">通过网盘分享的文件：elasticsearch-analysis-ik-<span class="hljs-number">7.12</span>.<span class="hljs-number">1</span>.jar<br>链接: https:<span class="hljs-regexp">//</span>pan.baidu.com<span class="hljs-regexp">/s/</span><span class="hljs-number">19</span>cKTeNDevnjJxxfIOiTicA?pwd=xqnv 提取码: xqnv<br></code></pre></td></tr></table></figure><p><img src="C:/lzc/blog/source/images/es部署_ik分词器_路径.png"></p><ul><li>下载安装包，复制到docker中</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker cp 待复制文件路径 <span class="hljs-comment">[容器名]</span>:<span class="hljs-comment">[容器内路径]</span><br></code></pre></td></tr></table></figure><ul><li>此处是通过查看挂载卷的方式，直接传输到挂载卷，无需使用docker手动cp</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">volume</span><span class="language-bash"> inspect es-plugins</span><br></code></pre></td></tr></table></figure><ul><li>一切正常后，添加自定义分词，进入config目录，IKAnalyzer.cfg.xml指定了自定义分词读取 ext.dic文件，首先，我们创建一个 ext.dic文件，然后编辑文件，添加分词即可。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> ext.dic<br></code></pre></td></tr></table></figure><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><p>把nacos、redis、es等迁移，并使用docker-compose.yaml编排</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常</title>
    <link href="/2025/05/21/java/%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8/"/>
    <url>/2025/05/21/java/%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="一、关系图"><a href="#一、关系图" class="headerlink" title="一、关系图"></a>一、关系图</h3><div><!--块级封装-->    <center><!--将图片和文字居中-->    <img src="../../../images/java_异常_类关系图.jpg"         alt="图片无法显示"         style="zoom:100%;"/>    <br><!--换行-->    图：Java异常体系结构<!--标题-->    </center></div><h3 id="二、各自含义"><a href="#二、各自含义" class="headerlink" title="二、各自含义"></a>二、各自含义</h3><blockquote><p><strong>Throwable</strong></p></blockquote><p>​Throwable类是 Java 语言中所有错误或异常的超类，只有当对象是此类（或其子类之一）的实例时，才能通过 Java 虚拟机或者 Java throw 语句抛出。</p><blockquote><p><strong>Error</strong></p></blockquote><p>​系统错误（System Error) 是由 Java 虚拟机抛出的，用 Error 类表示。Error 类描述的是内部系统错误。这样的错误很少发生。如果发生，除了通知用户以及尽量稳妥地终止程序外，几乎什么也不能做。</p><ul><li>OutOfMemoryError ：内存耗尽</li><li>NoClassDefFoundError ：无法加载某个Class </li><li>StackOverflowError ：栈溢出</li></ul><blockquote><p><strong>Exception</strong></p></blockquote><p>​Exception及其子类(除了RuntimeException)，在编译时期抛出的异常，在编译期间检查程序是否可能会出现问题，如果可能会有，则预先防范：捕获 声明。</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golo">/**<br> * <span class="hljs-keyword">try</span>中<span class="hljs-keyword">return</span>的返回值会被放入局部变量表，假如是基本数据类型，在<span class="hljs-keyword">finally</span>块中修改不会生效 &lt;br/&gt;<br> * <span class="hljs-keyword">finally</span>执行逻辑就是在<span class="hljs-keyword">try</span>快<span class="hljs-keyword">return</span>之前，执行逻辑，假如<span class="hljs-keyword">finally</span>中有<span class="hljs-keyword">return</span>语句，将会直接返回<br> * <br> * <span class="hljs-meta">@return</span> <span class="hljs-keyword">map</span><br> */<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2025/05/20/Git/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2025/05/20/Git/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><h5 id="与远程仓库建立连接"><a href="#与远程仓库建立连接" class="headerlink" title="与远程仓库建立连接"></a>与远程仓库建立连接</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin git@github.com:lzc3/lzc3.git<br></code></pre></td></tr></table></figure><h5 id="拉取项目代码"><a href="#拉取项目代码" class="headerlink" title="拉取项目代码"></a>拉取项目代码</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@xxx<br></code></pre></td></tr></table></figure><h5 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git submodule foreach git branch -D [branch_name]<br></code></pre></td></tr></table></figure><h5 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git submodule foreach git push origin --delete [branch_name]<br></code></pre></td></tr></table></figure><h5 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 使用git add 后<br>git reset HEAD src/main/java/com/xdap/manage/init/InitDatasource.java<br>git reset HEAD .<br><br>// 已经使用git commit提交的了代码，回退上一次commit的状态<br>git reset --hard HEAD^ <br><br>// 还原错误push到远程分支的代码 <br>// git revert 会创建一个新的提交，该提交会撤销指定提交的更改，而不会更改历史记录。适用于需要撤销某次提交，但又不希望修改提交历史的场景。<br>git revert &lt;commit_hash&gt;<br>git push origin &lt;branch_name&gt;<br><br>//git reset + 强制推送<br>git reset --hard &lt;commit_hash&gt;  <span class="hljs-comment"># 重置到某个提交</span><br>git push origin &lt;branch_name&gt; --force<br><br>// git reset --soft 如果你不想丢失文件的修改，而只想重置提交历史，这会将历史回退到某个提交，但保留修改，并将其放入暂存区。<br><br>参考https://www.cnblogs.com/Will-Chang/p/18576714<br></code></pre></td></tr></table></figure><h5 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> submodule foreach git push --set-upstream origin release/papaas-<span class="hljs-number">4</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>-rc-dev6-bak<br></code></pre></td></tr></table></figure><h5 id="工作用"><a href="#工作用" class="headerlink" title="工作用"></a>工作用</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">duoji bugfix start issue-2025042462755 -b release/papaas-4.0.8<br>duoji bugfix start issue-2025031361259 -b papaas-3.2.20-lts<br>duoji bugfix start issue-2025042962925 -b release/papaas-4.1.1<br><br>duoji feature start us-006050 -b release/papaas-4.1.1<br>duoji feature start us-003761-411 -b release/papaas-4.0.8<br><br>duoji ka start chervon -t v4.0.8-rc-20240927.1<br>duoji bugfix start issue-2025012459729 -b ka/papaas-3.2.19.7-jlqc<br><br>git defineflow utils delete branch ka/papaas-4.1.1-4.1.1-wej<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
      <category>常用命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2025/05/20/Git/Git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2025/05/20/Git/Git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h5 id="Git推送身份信息相关时，推送失败"><a href="#Git推送身份信息相关时，推送失败" class="headerlink" title="Git推送身份信息相关时，推送失败"></a>Git推送身份信息相关时，推送失败</h5><p>!refs&#x2F;heads&#x2F;mybatis-branch:refs&#x2F;heads&#x2F;mybatis-branch[remote rejected] (push declined due to repository rule violations)<br>Done</p><p>[解决 git 推送push代码出现github远程分支拒绝[remote rejected] (push declined due to repository rule violations）-CSDN博客](<a href="https://blog.csdn.net/2201_76122930/article/details/140858662#:~:text=%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">https://blog.csdn.net/2201_76122930/article/details/140858662#:~:text=解决方案</a>. 可以选择)</p><h5 id="SVN和Git的区别"><a href="#SVN和Git的区别" class="headerlink" title="SVN和Git的区别"></a>SVN和Git的区别</h5><ul><li>分布式 vs 集中式：Git 是一种分布式版本控制系统，而 SVN 是一种集中式版本控制系统。在 Git 中，每个开发者都拥有本地代码库的完整副本，可以离线工作并在不同的工作流程之间自由转换。而在 SVN 中，所有开发者共享同一个中央代码库，并且需要有网络连接才能进行版本控制操作。</li><li>分支管理：Git 在分支管理方面比 SVN 更加强大和灵活。Git 的分支非常轻量级，创建和合并分支也很容易，因此可以轻松实现多人协作和并行开发。而在 SVN 中，分支比较重量级（即创建和合并分支需要花费相对更多的时间和资源），因此往往只用于重要的版本分支。</li><li>版本号：Git 使用 SHA-1 哈希值来标识每个提交，而 SVN 采用递增的数字版本号来标识每个提交。SHA-1 哈希值保证了每个提交的唯一性，而递增版本号则简化了版本控制过程。</li><li>整体性：由于 SVN 是一种集中式版本控制系统，因此所有数据都存储在中央代码库中。如果中央代码库损坏或丢失，可能会导致数据丢失或无法恢复。而 Git 是一种分布式版本控制系统，每个开发者都拥有完整的代码库副本，保证了代码的整体性和可靠性。</li><li>性能：Git 比 SVN 更快，特别是在处理大型仓库、分支合并以及比较代码差异时。Git 使用基于内容的哈希算法来检测文件是否修改，而 SVN 则需要检查文件的元数据（如时间戳和文件大小）来确定是否修改。</li></ul><p>​总之，虽然 SVN 和 Git 都是版本控制系统，但它们的设计和实现方式存在较大差异，开发人员应根据自身需求选择最适合的版本控制系统。<br>​原文链接：<a href="https://blog.csdn.net/qq_16027093/article/details/130503317">https://blog.csdn.net/qq_16027093/article/details/130503317</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
      <category>常见问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git常见问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arthas篇</title>
    <link href="/2025/05/20/java/Maven/"/>
    <url>/2025/05/20/java/Maven/</url>
    
    <content type="html"><![CDATA[<h2 id="Maven-生命周期"><a href="#Maven-生命周期" class="headerlink" title="Maven 生命周期"></a>Maven 生命周期</h2><p>三个生命周期，每个生命周期的执行都是有顺序的，后面的指令依赖前面指令</p><p><strong>clean</strong></p><ul><li>clean</li></ul><p><strong>default</strong></p><ul><li>compile</li><li>test</li><li>package</li><li>install</li></ul><p><strong>site</strong></p><ul><li>site</li></ul><h1 id="Maven-依赖-Scope-完整解析"><a href="#Maven-依赖-Scope-完整解析" class="headerlink" title="Maven 依赖 Scope 完整解析"></a>Maven 依赖 Scope 完整解析</h1><blockquote><p>Maven 的完整生命周期包括：validate、compile、test、package、verify、install 和 deploy。</p></blockquote><p>Maven 的 <code>&lt;scope&gt;</code> 决定了依赖在项目构建生命周期中的可见性和作用范围。以下是所有 <code>&lt;scope&gt;</code> 取值的详细说明、示例及解释。</p><h2 id="Scope-类型及含义"><a href="#Scope-类型及含义" class="headerlink" title="Scope 类型及含义"></a>Scope 类型及含义</h2><table><thead><tr><th>Scope 值</th><th>含义与功能</th><th>生命周期中的作用</th></tr></thead><tbody><tr><td>compile</td><td>默认值。表示依赖在<code>编译、测试、运行</code>阶段都可用。</td><td><code>编译</code>时、<code>测试</code>时、<code>运行</code>时均可用，最终会被打包到产物（jar&#x2F;war）中。</td></tr><tr><td>provided</td><td>表示依赖由 JDK 或容器提供，不随项目打包。</td><td><code>编译</code>时可用，<code>测试</code>时可用，但<code>运行时不会</code>被包含在最终包中（例如 Servlet API）。</td></tr><tr><td>runtime</td><td>表示依赖仅在<code>运行</code>和<code>测试</code>时可用，不用于编译。</td><td><code>编译</code>阶段<code>不可用</code>，<code>运行</code>时和<code>测试</code>阶段可用，最终会被打包。</td></tr><tr><td>test</td><td>表示依赖只在<code>测试</code>代码中使用。</td><td><code>仅在测试</code>阶段（如 mvn test）可用，<code>编译</code>和<code>运行</code>阶段<code>不可用</code>，不打包到产物中。</td></tr><tr><td>system</td><td>与 provided 类似，但依赖必须显式指定本地路径。</td><td><code>编译</code>和<code>测试</code>阶段可用，不会自动下载依赖，需要手动指定 <code>&lt;systemPath&gt;</code>，不推荐使用。</td></tr><tr><td>import</td><td>仅用于 dependencyManagement 中，引入其他 POM 的依赖管理。</td><td>不直接作为依赖使用，而是导入一个 BOM（Bill of Materials）进行版本管理。</td></tr></tbody></table><h2 id="各-Scope-示例及解释"><a href="#各-Scope-示例及解释" class="headerlink" title="各 Scope 示例及解释"></a>各 Scope 示例及解释</h2><h3 id="1-compile"><a href="#1-compile" class="headerlink" title="1. compile"></a>1. compile</h3><p><strong>示例</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>解释</strong>: <code>compile</code> 是默认 scope，表示依赖（如 Apache Commons Lang）在编译、测试和运行时都可用。最终会被打包到项目的 jar&#x2F;war 文件中，适用于项目核心功能所需的库。</p><h3 id="2-provided"><a href="#2-provided" class="headerlink" title="2. provided"></a>2. provided</h3><p><strong>示例</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>解释</strong>: <code>provided</code> 表示依赖由 JDK 或运行时容器（如 Tomcat）提供，仅在编译和测试阶段需要。例如，Servlet API 在开发 Web 应用时用于编译，但运行时由容器提供，因此不会打包到最终产物中。</p><h3 id="3-runtime"><a href="#3-runtime" class="headerlink" title="3. runtime"></a>3. runtime</h3><p><strong>示例</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>解释</strong>: <code>runtime</code> 表示依赖仅在运行和测试时需要，不参与编译。例如，MySQL 驱动在运行时连接数据库时使用，但编译时不需要，因此会被打包到最终产物中。</p><h3 id="4-test"><a href="#4-test" class="headerlink" title="4. test"></a>4. test</h3><p><strong>示例</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-params<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>解释</strong>: <code>test</code> 表示依赖仅用于测试阶段（如运行 <code>mvn test</code>）。JUnit 依赖用于单元测试，编译和运行主代码时不可用，也不会打包到最终产物中。</p><h3 id="5-system"><a href="#5-system" class="headerlink" title="5. system"></a>5. system</h3><p><strong>示例</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>custom-lib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>system<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">systemPath</span>&gt;</span>$&#123;project.basedir&#125;/lib/custom-lib.jar<span class="hljs-tag">&lt;/<span class="hljs-name">systemPath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>解释</strong>: <code>system</code> 表示依赖是本地文件，需通过 <code>&lt;systemPath&gt;</code> 指定路径。仅在编译和测试时可用，不会从 Maven 仓库下载。由于维护复杂，不推荐使用。</p><h3 id="6-import"><a href="#6-import" class="headerlink" title="6. import"></a>6. import</h3><p><strong>示例</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>解释</strong>: <code>import</code> 仅用于 <code>&lt;dependencyManagement&gt;</code> 部分，用于导入其他 POM 文件（如 Spring Boot 的 BOM）中的依赖版本管理。它不直接引入依赖，而是统一管理版本号，方便项目中依赖版本一致性。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>arthas</category>
      
    </categories>
    
    
    <tags>
      
      <tag>arthas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arthas篇</title>
    <link href="/2025/05/20/java/arthas/"/>
    <url>/2025/05/20/java/arthas/</url>
    
    <content type="html"><![CDATA[<h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><ul><li>wget下载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://arthas.aliyun.com/arthas-boot.jar<br></code></pre></td></tr></table></figure><ul><li>端口冲突解决</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">pid=1 ;\<br><span class="hljs-built_in">touch</span> /proc/<span class="hljs-variable">$&#123;pid&#125;</span>/cwd/.attach_pid<span class="hljs-variable">$&#123;pid&#125;</span> &amp;&amp; \<br>  <span class="hljs-built_in">kill</span> -SIGQUIT <span class="hljs-variable">$&#123;pid&#125;</span> &amp;&amp; \<br>  <span class="hljs-built_in">sleep</span> 2 &amp;&amp;<br>  <span class="hljs-built_in">ls</span> /proc/<span class="hljs-variable">$&#123;pid&#125;</span>/root/tmp/.java_pid<span class="hljs-variable">$&#123;pid&#125;</span><br><br>watch org.artofsolving.jodconverter.AbstractConversionTask getStoreProperties <span class="hljs-string">&#x27;&#123;returnObj&#125;&#x27;</span>  -n 5  -x 5<br></code></pre></td></tr></table></figure><h5 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h5><ul><li>params过滤</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">watch com<span class="hljs-selector-class">.xdap</span><span class="hljs-selector-class">.processapi</span><span class="hljs-selector-class">.ProcessQueryOperate</span> queryProcInstanceByDocId <span class="hljs-string">&#x27;&#123;params,returnObj&#125;&#x27;</span> <span class="hljs-string">&#x27;params[0].contains(&quot;xxx&quot;)&#x27;</span> -n <span class="hljs-number">5</span>  -<span class="hljs-attribute">x</span> <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><ul><li>returnObj过滤</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">watch com<span class="hljs-selector-class">.definesys</span><span class="hljs-selector-class">.mpaas</span><span class="hljs-selector-class">.query</span><span class="hljs-selector-class">.MpaasQuery</span> buildQuerySql <span class="hljs-string">&#x27;&#123;returnObj&#125;&#x27;</span> <span class="hljs-string">&#x27;returnObj.contains(&quot;distinct xu.phone&quot;)&#x27;</span> -n <span class="hljs-number">10</span>  -<span class="hljs-attribute">x</span> <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><p><strong>trace</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">trace com<span class="hljs-selector-class">.xdap</span><span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.moudle</span><span class="hljs-selector-class">.process</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.ProcessService</span> processBusinessObjectSubmit  -n <span class="hljs-number">5</span> <span class="hljs-attr">--skipJDKMethod</span> false <span class="hljs-string">&#x27;#cost&gt;1000&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="ognl表达式实例"><a href="#ognl表达式实例" class="headerlink" title="ognl表达式实例"></a>ognl表达式实例</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h5 id="删除多余的arthas进程"><a href="#删除多余的arthas进程" class="headerlink" title="删除多余的arthas进程"></a>删除多余的arthas进程</h5><ul><li>查找所有Arthas进程的PID</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> arthas<br></code></pre></td></tr></table></figure><ul><li>假设你找到了一个不需要的进程的PID，例如12345，使用kill命令关闭它</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kill</span> <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>arthas</category>
      
    </categories>
    
    
    <tags>
      
      <tag>arthas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker篇</title>
    <link href="/2025/05/20/docker/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2025/05/20/docker/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h1><hr><h2 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h2><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><ul><li><code>-t</code> 标签指定镜像名:标签</li><li><code>-f</code> 指定 Dockerfile 文件</li><li><code>.</code> 当前目录为构建上下文</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t keking/kkfileview:v4.0.0 -f miss-Dockerfile .<br></code></pre></td></tr></table></figure><p>示例输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">REPOSITORY</span>          TAG       IMAGE ID       CREATED         SIZE<br><span class="hljs-attribute">keking</span>/kkfileview   v4.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>    <span class="hljs-number">49067017</span>aaf1   <span class="hljs-number">8</span> minutes ago   <span class="hljs-number">1</span>.<span class="hljs-number">59</span>GB<br></code></pre></td></tr></table></figure><h3 id="镜像打-tag"><a href="#镜像打-tag" class="headerlink" title="镜像打 tag"></a>镜像打 tag</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker tag keking/kkfileview:v4.0.0 keking/kkfileview:20250325<br></code></pre></td></tr></table></figure><h3 id="导出本地镜像"><a href="#导出本地镜像" class="headerlink" title="导出本地镜像"></a>导出本地镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker save -o [导出镜像文件名].tar [本地镜像]<br></code></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除指定镜像（支持正则过滤）</span><br>docker rmi $(docker images | grep &quot;apaas&quot;) --force<br></code></pre></td></tr></table></figure><hr><h2 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h2><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps<br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止容器</span><br>docker stop 0699d8e34ce9<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行容器（-d 后台，-p 端口映射，-v 挂载）</span><br>docker run -p 8012:8012 -v /data:/data -d hub.dfy.definesys.cn/common/kkfileview:20240723.1<br>docker run -p 8012:8012 -v /data:/data -d keking/kkfileview:v4.0.14<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器</span><br>docker exec -it 4ca043c2068b sh<br></code></pre></td></tr></table></figure><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">// 查看数据卷<span class="hljs-selector-tag">html</span>详情<br>docker volume inspect <span class="hljs-selector-tag">html</span><br></code></pre></td></tr></table></figure><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker network <span class="hljs-comment">--help</span><br></code></pre></td></tr></table></figure><h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs -f --tail=100 [id]/[name]<br></code></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">依稀记得<span class="hljs-built_in">id</span>和name都可以，待测试</span><br>docker rm [id]/[name]<br></code></pre></td></tr></table></figure><h3 id="清理未使用资源"><a href="#清理未使用资源" class="headerlink" title="清理未使用资源"></a>清理未使用资源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除未使用的 Docker 资源，包括：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止的容器、悬空镜像、未使用的网络、构建缓存</span><br>docker system prune<br></code></pre></td></tr></table></figure><hr><h2 id="认证与拉取私有镜像"><a href="#认证与拉取私有镜像" class="headerlink" title="认证与拉取私有镜像"></a>认证与拉取私有镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">拉取私有镜像时如遇 unauthorized 错误：</span><br>docker pull hub.dfy.definesys.cn/common/kkfileview:20240723.1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">登录私有仓库</span><br>docker login hub.dfy.definesys.cn<br><span class="hljs-meta prompt_"># </span><span class="language-bash">登录后再次拉取</span><br>docker pull hub.dfy.definesys.cn/common/kkfileview:20240723.1<br></code></pre></td></tr></table></figure><hr><h2 id="Kubernetes-相关"><a href="#Kubernetes-相关" class="headerlink" title="Kubernetes 相关"></a>Kubernetes 相关</h2><h3 id="获取命名空间下-Pod"><a href="#获取命名空间下-Pod" class="headerlink" title="获取命名空间下 Pod"></a>获取命名空间下 Pod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pods -n apaas<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入 Pod 容器</span><br>kubectl exec -it -n apaas xdap-app-dingxuewei01-nkjx-749b987974-4xnm4 bash<br></code></pre></td></tr></table></figure><h3 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">从 Pod 拷贝到本地</span><br>kubectl cp 命名空间/POD名:/路径/文件名 /本地路径/文件名<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-r 递归复制目录</span><br>kubectl cp -r /本地路径/文件名 命名空间/POD名:/路径/文件名<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
      <category>常用命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqlserver篇</title>
    <link href="/2025/05/20/java/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlserver/"/>
    <url>/2025/05/20/java/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlserver/</url>
    
    <content type="html"><![CDATA[<h3 id="类型不匹配问题"><a href="#类型不匹配问题" class="headerlink" title="类型不匹配问题"></a>类型不匹配问题</h3><blockquote><p>记录一些类型不匹配导致的sql报错</p></blockquote><h5 id="其余类型-字符串-field1-in-“xxx”"><a href="#其余类型-字符串-field1-in-“xxx”" class="headerlink" title="其余类型-&gt;字符串 field1 in (“xxx”)"></a>其余类型-&gt;字符串 field1 in (“xxx”)</h5><p>​形如 field1 in (“xxx”)，其中，xxx为字符串不是数字的话，就会报错</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> QUERY <span class="hljs-keyword">AS</span> (<br><span class="hljs-keyword">SELECT</span><br>inner_query.<span class="hljs-operator">*</span>,<br><span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> ( <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> ) <span class="hljs-operator">-</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> query_num <br><span class="hljs-keyword">FROM</span><br>(<br><span class="hljs-keyword">SELECT</span><br>dbo.sql_server_srp.form_id <span class="hljs-keyword">AS</span> &quot;formId&quot;,<br>dbo.sql_server_srp.OWNER <span class="hljs-keyword">AS</span> &quot;owner&quot;,<br>dbo.sql_server_srp.last_updated_by <span class="hljs-keyword">AS</span> &quot;lastUpdatedBy&quot;,<br>dbo.sql_server_srp.last_update_date <span class="hljs-keyword">AS</span> &quot;lastUpdateDate&quot;,<br>dbo.sql_server_srp.creation_date <span class="hljs-keyword">AS</span> &quot;creationDate&quot;,<br>dbo.sql_server_srp.tab_doc_id <span class="hljs-keyword">AS</span> &quot;tabDocId&quot;,<br>dbo.sql_server_srp.field1 <span class="hljs-keyword">AS</span> &quot;a8e04fd2bee82fb927a5a8a7&quot;,<br>dbo.sql_server_srp.created_by <span class="hljs-keyword">AS</span> &quot;createdBy&quot;,<br>dbo.sql_server_srp.process_id <span class="hljs-keyword">AS</span> &quot;processId&quot;,<br>dbo.sql_server_srp.document_id <span class="hljs-keyword">AS</span> &quot;documentId&quot;,<br>dbo.sql_server_srp.id <span class="hljs-keyword">AS</span> &quot;id&quot;,<br>dbo.sql_server_srp.approver_id <span class="hljs-keyword">AS</span> &quot;approverList&quot;,<br>dbo.sql_server_srp.STATUS <span class="hljs-keyword">AS</span> &quot;status&quot; <br><span class="hljs-keyword">FROM</span><br>dbo.sql_server_srp <br><span class="hljs-keyword">WHERE</span><br>(<br>sql_server_srp.field2 <span class="hljs-keyword">IN</span> ( <span class="hljs-string">&#x27;asdas&#x27;</span> ))) inner_query <br>) <span class="hljs-keyword">SELECT</span><br><span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span><br>QUERY <br><span class="hljs-keyword">WHERE</span><br>query_num <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span> <br><span class="hljs-keyword">AND</span> query_num <span class="hljs-operator">&lt;</span> <span class="hljs-number">1</span><br>[<span class="hljs-number">42000</span>] [Microsoft][ODBC Driver <span class="hljs-number">17</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">SQL</span> Server][<span class="hljs-keyword">SQL</span> Server]Error converting data type <span class="hljs-type">varchar</span> <span class="hljs-keyword">to</span> bigint. (<span class="hljs-number">8114</span>)<br></code></pre></td></tr></table></figure><h3 id="查询删除插入"><a href="#查询删除插入" class="headerlink" title="查询删除插入"></a>查询删除插入</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs txt">SELECT table_name FROM information_schema.tables<br>WHERE table_type = &#x27;BASE TABLE&#x27;<br>AND table_catalog = &#x27;master&#x27;;  -- 替换为你的数据库名称<br><br><br>SELECT * FROM master.dbo.prod_info_server_relatedtable;<br><br><br>SELECT * FROM master.dbo.prod_info_server;<br><br>DELETE FROM master.dbo.prod_info_server;<br><br>INSERT INTO master.dbo.prod_info_server ([prod_id], [prod_name], [prod_price], [prod_name1]) VALUES (1, N&#x27;水杯&#x27;, 50, NULL);<br>INSERT INTO master.dbo.prod_info_server ([prod_id], [prod_name], [prod_price], [prod_name1]) VALUES (2, N&#x27;笔&#x27;, 2, NULL);<br>INSERT INTO master.dbo.prod_info_server ([prod_id], [prod_name], [prod_price], [prod_name1]) VALUES (3, N&#x27;键盘&#x27;, 500, NULL);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>sqlserver</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sqlserver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pg篇</title>
    <link href="/2025/05/20/java/%E6%95%B0%E6%8D%AE%E5%BA%93/pg/"/>
    <url>/2025/05/20/java/%E6%95%B0%E6%8D%AE%E5%BA%93/pg/</url>
    
    <content type="html"><![CDATA[<h2 id="修改自增序列"><a href="#修改自增序列" class="headerlink" title="修改自增序列"></a>修改自增序列</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> pg_get_serial_sequence(<span class="hljs-string">&#x27;public.chat_sessions_content&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>);<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SEQUENCE</span> <span class="hljs-built_in">public</span>.chat_sessions_content_id_seq <span class="hljs-keyword">RESTART</span> <span class="hljs-keyword">WITH</span> <span class="hljs-number">191</span>;<br><span class="hljs-keyword">SELECT</span> setval(<span class="hljs-string">&#x27;public.chat_sessions_content_id_seq&#x27;</span>, <span class="hljs-number">191</span>, <span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>pg</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongo篇</title>
    <link href="/2025/05/20/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/"/>
    <url>/2025/05/20/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/</url>
    
    <content type="html"><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h5 id="命令行下的操作"><a href="#命令行下的操作" class="headerlink" title="命令行下的操作"></a><strong>命令行下的操作</strong></h5><ul><li>进入mongo</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mongo">mongo --host 172.xx.xx.xx --port 37017 --username user --password [password] <br></code></pre></td></tr></table></figure><ul><li>查看&#x2F;使用数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mongo">// 进入对应库<br>use database_xx;<br>// 查看当前库<br>db;<br></code></pre></td></tr></table></figure><h3 id="常用Sql"><a href="#常用Sql" class="headerlink" title="常用Sql"></a>常用Sql</h3><p>查询mongo中query_data_filter表里面tabId、docOwner、filterName一样，出现了两次的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.query_data_filter.aggregate([<br>  &#123; $<span class="hljs-keyword">group</span>: &#123; _id: &#123; A: &quot;$tabId&quot;, B: &quot;$docOwner&quot;, C: &quot;$filterName&quot; &#125;, count: &#123; $sum: <span class="hljs-number">1</span> &#125; &#125; &#125;,<br>  &#123; $<span class="hljs-keyword">match</span>: &#123; count: <span class="hljs-number">2</span> &#125; &#125;,<br>  &#123; $project: &#123;A: &quot;$_id.A&quot;, B: &quot;$_id.B&quot;, C: &quot;$_id.C&quot;&#125; &#125;<br>]);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>mongo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mongo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oracle篇</title>
    <link href="/2025/05/20/java/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle/"/>
    <url>/2025/05/20/java/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle/</url>
    
    <content type="html"><![CDATA[<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>Oracle数据库在12.1版本及以前，对象名（包括表名和列名）的长度限制为30个字符。‌</p><p>​这一限制在Oracle 12.2版本之后得到了调整，对象名的长度限制从30个字节增加到了128个字节，从而允许用户创建更长的对象名，以满足更复杂的数据库设计需求。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> version <span class="hljs-keyword">FROM</span> v$instance;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oracle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生产消息重复问题</title>
    <link href="/2025/05/18/%E9%9A%8F%E7%AC%94/%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98/"/>
    <url>/2025/05/18/%E9%9A%8F%E7%AC%94/%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="客户消息发送重复问题"><a href="#客户消息发送重复问题" class="headerlink" title="客户消息发送重复问题"></a>客户消息发送重复问题</h1><h1 id="特殊Bug记录"><a href="#特殊Bug记录" class="headerlink" title="特殊Bug记录"></a>特殊Bug记录</h1><h2 id="1、客户生产收到了重复消息"><a href="#1、客户生产收到了重复消息" class="headerlink" title="1、客户生产收到了重复消息"></a>1、客户生产收到了重复消息</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​客户提交了一个bug，问题是升级版本后，执行的某个事件，推送消息变成了两条。</p><p>​先说结论，是一次非空判断的遗漏导致了全表数据查询，然后查出了全表数据，对全表数据进行了循环发送mq消息。</p><h4 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h4><ul><li><p>分析执行流程</p><p>执行过程如下，重点关注两种类型，一是发送Mq的过程，二是可能会重复的地方，比如for循环</p><blockquote><p>提交数据触发事件埋点<br>发送Mq执行业务事件<br>业务事件执行完毕后，事件框架推送发送消息<br>消息事件执行，触发Mq实际发送数据<br>消费者执行具体消息 </p></blockquote></li><li><p>分析重复消息记录</p><p>在数据库分析对比两条数据的创建时间，发现消息重复几百次，而且不止一条消息重复。</p></li><li><p>分析Mq执行的过程及状态</p><p>拉取了日志，消息在消费者这边是正常消费，同时，Mq中对应队列状态也正常。</p></li><li><p>分析代码逻辑</p><p>重点关注几个for循环地方，在发版期间无代码改动。</p></li><li><p>分析数据库消息表，</p><p>根据最新消息唯一标识继续查询，消息还在持续不断重复中。</p></li><li><p>继续结合日志分析Mq</p><p>查看Mq对应队列以及消费者pod日志，在不断接收来自Mq的消息。</p><p>查看生产者pod日志，发现无消息推送记录</p><p>排除消息确认机制影响，消费端无报错、生产者无重复推送记录</p></li></ul><p>结论：消息消费者一直在不断消费Mq发送消息，这些消息和客户说明的操作无关系，有可能是其他应用的操作引起的。</p><h4 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h4><ul><li><strong>定位pod</strong></li></ul><p>​   首先，一个一个去应用的pod中查看日志，看哪些应用在对应时刻有发送对应mq的记录，只有一个应用在不断发送mq消息。</p><ul><li><strong>找到不断发送消息的地方</strong></li></ul><p>  消息发送上层有很多调用，使用arthas抓取发送消息的上层调用链路，分析后都是同一个调用链路。</p><p>​   重点关注哪个地方开始重复的，继续使用arthas监听，最终是在一个for循环处，对查出来的documentId列表进行遍历，不断发送消息。结合日志，找到这个for循环对应的事件id，去数据库中找到名字。</p><ul><li><strong>分析此事件</strong></li></ul><p>​查看事件执行记录，入参为空，代码中间某段逻辑处查出了表的全部数据。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>难点：</p><ul><li>客户业务复杂，提供的信息不准确</li><li>表单操作、执行事件、发送系统消息执行链路长</li><li>日志体积大、刷新频率高，客户正在使用，具体排查困难</li></ul><p>学到了什么：</p><ul><li><p>Arthas监听调用栈</p></li><li><p>Mq如果不指定确认策略默认自动开启消费者确认</p></li><li><p>消息发送的时候，最好加个参数，指明消息来源</p></li></ul><h2 id="2、日期保存后-1"><a href="#2、日期保存后-1" class="headerlink" title="2、日期保存后+1"></a>2、日期保存后+1</h2><p>输入时间为：2025-04-04 08:03:02</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-comment">// 前置条件，设置默认时区</span><br>TimeZone.setDefault(TimeZone.getTimeZone(<span class="hljs-string">&quot;America/New_York&quot;</span>));<br><br><span class="hljs-built_in">String</span> s = <span class="hljs-string">&quot;2025-04-04 08:03:02&quot;</span>;<br><span class="hljs-comment">// 按照指定格式格式化日期</span><br>SimpleDateFormat dateTimeFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br><span class="hljs-comment">// 此时date为 Fri Apr 04 08:03:02 EDT 2025</span><br><span class="hljs-built_in">Date</span> <span class="hljs-built_in">date</span> = dateTimeFormat.parse(s)<br><br><span class="hljs-comment">// 转东八区</span><br><span class="hljs-built_in">date</span>.setTime(<span class="hljs-built_in">date</span>.getTime() + xx);<br><br><span class="hljs-comment">// 2025-04-04 21:03:02</span><br><span class="hljs-built_in">Object</span> o = dateTimeFormat.format(<span class="hljs-built_in">date</span>)<br><br><span class="hljs-comment">// afterParseDate值变成了Fri Apr 04 09:03:02 EDT 2025</span><br>dateTimeFormat.setTimeZone(TimeZone.getTimeZone(<span class="hljs-string">&quot;GMT+8&quot;</span>));<br>afterParseDate = dateTimeFormat.parse(<span class="hljs-built_in">String</span>.valueOf(o));<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Fri</span> Apr <span class="hljs-number">04</span> <span class="hljs-number">09</span>:<span class="hljs-number">03</span>:<span class="hljs-number">02</span> EDT <span class="hljs-number">2025</span><br><br><span class="hljs-attribute">String</span> timeZoneId = <span class="hljs-string">&quot;GMT&quot;</span> + timezone;<br><span class="hljs-attribute">TimeZone</span> timeZone = TimeZone.getTimeZone(timeZoneId);<br><span class="hljs-attribute">sdf</span>.setTimeZone(timeZone);<br></code></pre></td></tr></table></figure><p>mysql的datetime字段</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
      <category>生产消息重复问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生产消息重复问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串</title>
    <link href="/2025/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2025/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><h3 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h3><h5 id="2025-5-15-字符串转换后的长度-II"><a href="#2025-5-15-字符串转换后的长度-II" class="headerlink" title="2025&#x2F;5&#x2F;15 字符串转换后的长度 II"></a>2025&#x2F;5&#x2F;15 字符串转换后的长度 II</h5>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>id生成算法</title>
    <link href="/2025/05/14/java/%E5%9F%BA%E7%A1%80/id%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/"/>
    <url>/2025/05/14/java/%E5%9F%BA%E7%A1%80/id%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>1位：固定为0，保证id为正数</p><p>41位时间戳：可以表示69年范围，毫秒级别精度</p><p>10位工作ID：支持1024台机器，保证分布式唯一性</p><p>12位序列号：每毫秒可生成4096个ID，提高并发能力</p><h3 id="时钟回拨"><a href="#时钟回拨" class="headerlink" title="时钟回拨"></a>时钟回拨</h3><ul><li>机器之间存在误差，不同服务器同步时间</li><li>人工修改时间，手动调整系统时钟造成时间错误</li></ul><p>后果：雪花算法使用了较小的时间戳，序列号重新从0开始计算，生成重复ID</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><ul><li>暂停服务直到时钟恢复正常</li><li>备用时钟源，使用其他服务器或者网络时间服务</li><li>序列号扩展，回拨期间临时添加序列号位数</li><li>时间戳记录，记录上次生成ID的时间戳，如果发现时间戳变小，就抛出异常。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>id生成算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO</title>
    <link href="/2025/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/IO/"/>
    <url>/2025/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/IO/</url>
    
    <content type="html"><![CDATA[<h2 id="DMA和零拷贝"><a href="#DMA和零拷贝" class="headerlink" title="DMA和零拷贝"></a>DMA和零拷贝</h2><h3 id="传统磁盘IO流程"><a href="#传统磁盘IO流程" class="headerlink" title="传统磁盘IO流程"></a>传统磁盘IO流程</h3><p>过程：</p><table><thead><tr><th>用户</th><th>CPU</th><th>磁盘</th></tr></thead><tbody><tr><td>read请求</td><td>用户态转换成内核态</td><td>向磁盘发起IO请求，磁盘开始准备数据</td></tr><tr><td></td><td></td><td>磁盘准备数据完毕，向CPU发起IO中断</td></tr><tr><td></td><td>cpu将磁盘中的数据拷贝到内核区</td><td></td></tr><tr><td></td><td>cpu将内核区中的数据拷贝到用户区</td><td></td></tr><tr><td></td><td>内核态转换成用户态</td><td></td></tr></tbody></table><p>流程图如下</p><p><img src="/../../images/IO_%E4%BC%A0%E7%BB%9FIO.png"></p><ul><li>用户进程调用read操作，CPU收到指令后，发出对应的指令给磁盘控制器，然后返回</li><li>磁盘控制器收到指令后，开始准备数据，把数据放入到磁盘控制器的内部缓冲区，然后产生一个中断。</li><li>CPU收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后将寄存器中的数据写入到内存，而在数据传输期间CPU是无法执行其他任务的。</li></ul><p>两次状态切换，两次CPU拷贝</p><h3 id="加一层DMA-Direct-Memory-Access"><a href="#加一层DMA-Direct-Memory-Access" class="headerlink" title="加一层DMA(Direct Memory Access)"></a>加一层DMA(Direct Memory Access)</h3><p>直接内存访问：允许外部设备直接读写内存，既不通过CPU，也不需要CPU干预。</p><p>主存和DMA控制器之间有一条数据通路，因此主存和I&#x2F;O设备之间交换信息时，不通过CPU。在数据块传送时，主存地址的确定、传送数据的计数等都由外设的硬件电路直接实现。主存中要开辟专用缓冲区，及时供给和接收外设的数据。</p><p>如下图：</p><p><img src="/../../images/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0_DMA.png"></p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><h3 id="IO分类"><a href="#IO分类" class="headerlink" title="IO分类"></a>IO分类</h3><p>1.阻塞io</p><p>2.非阻塞io</p><p>3.io多路复用</p><p>4.信号驱动io</p><p><img src="/../../images/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8io.png"></p><ul><li>当有大量IO操作的时候，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出</li><li>内核空间与用户空间的频繁交互性能也较低</li></ul><p>5.异步io</p><p><img src="/../../images/AIO.png"></p><p>IO多路复用是利用单个线程同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效等待，充分利用CPU资源</p><p>Select、Poll、Epoll，其中，select和poll只会通知用户进程有FD就绪，但不确定时各个FD，需要用户进程逐个遍历FD来确认；Epoll则会在通知用户进程FD就绪的同时，把已就绪的FD写入用户空间。</p><h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>创建fd_set rfds</p><p><img src="/../../images/IO-select.png"></p><ul><li>需要将fd_set从用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间</li><li>select无法得知具体是哪个fd就绪，需要遍历整个fd_set</li><li>fd_set监听的fd数量不能超过1024</li></ul><h3 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h3><p><img src="/../../images/IO-Pol.png"></p><ul><li>poll利用了链表解决select中监听fd上限的问题，但依然要遍历所有的FD，如果监听较多，性能会下降</li></ul><h3 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h3><ul><li><p>拷贝次数，将添加fd与等待fd的操作拆成了两步，不用每次都将监听的fd进行传输；</p></li><li><p>拷贝数量，返回就绪队列的时候，只会返回就绪的fd</p></li><li><p>基于红黑树保存fd，增删改查效率高</p></li></ul><p><img src="/../../images/IO-Epoll.png"></p><h4 id="IO多路复用-事件通知机制"><a href="#IO多路复用-事件通知机制" class="headerlink" title="IO多路复用-事件通知机制"></a>IO多路复用-事件通知机制</h4><p>当FD有数据可读时，我们调用Epoll_wait就可以得到通知，通知模式有两种：</p><ul><li><p>LevelTriggered，LT，当FD有数据可读时，会重复通知多次，直至数据处理完成，是Epoll的默认模式。</p><p>list_head中会将没读完的fd再次加入</p></li><li><p>EdgeTriggered，ET，当FD有数据可读时，只会被通知一次，不管数据是否处理完成。</p></li></ul><h3 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h3><p><img src="/../../images/Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png"></p><p>0</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2025/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
    <url>/2025/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>​其数数据结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode next;<br>    ListNode() &#123;&#125;<br>    ListNode(<span class="hljs-type">int</span> val) &#123; <span class="hljs-built_in">this</span>.val = val; &#125;<br>    ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123; <span class="hljs-built_in">this</span>.val = val; <span class="hljs-built_in">this</span>.next = next; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote><p>todo</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2025/05/10/java/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMq/"/>
    <url>/2025/05/10/java/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMq/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录下RabbitMQ 学习过程中的关键知识点</p></blockquote><h3 id="消息队列基本特性"><a href="#消息队列基本特性" class="headerlink" title="消息队列基本特性"></a>消息队列基本特性</h3><h4 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h4><blockquote><p>业务场景上无可避免的会出现业务被重复执行的情况，尽可能保证执行一次或者多次对业务状态的影响是一致的</p></blockquote><ul><li>页面卡顿</li><li>服务重试</li><li>MQ重复投递</li></ul><p>如何保证幂等性？</p><h5 id="唯一消息ID"><a href="#唯一消息ID" class="headerlink" title="唯一消息ID"></a>唯一消息ID</h5><p>每条消息都生成一个唯一的id，与消息一起投递给消费者。</p><p>消费者处理业务时，对此id进行持久化，下次再收到重复的消息，就可以通过持久化数据识别出来。</p><p>SpringAMQP自带了id功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">messageConverter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 1.定义消息转换器</span><br>    <span class="hljs-type">Jackson2JsonMessageConverter</span> <span class="hljs-variable">jjmc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>    <span class="hljs-comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span><br>    jjmc.setCreateMessageIds(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> jjmc;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="业务判断"><a href="#业务判断" class="headerlink" title="业务判断"></a>业务判断</h5><p>​比如超时审批时，此时状态已经时同意，就无需继续往下执行，但有可能会出现ABA问题。</p><h3 id="如何保证消息的可靠性"><a href="#如何保证消息的可靠性" class="headerlink" title="如何保证消息的可靠性"></a>如何保证消息的可靠性</h3><h4 id="一、生产者重试机制"><a href="#一、生产者重试机制" class="headerlink" title="一、生产者重试机制"></a>一、生产者重试机制</h4><p>生产者与MQ的网络断开，进行重试</p><blockquote><p>依赖SpringAMQP提供的消息发送时的重试机制，这个过程是阻塞的</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">connection-timeout:</span> <span class="hljs-string">1s</span> <span class="hljs-comment"># 设置MQ的连接超时时间</span><br>    <span class="hljs-attr">template:</span><br>      <span class="hljs-attr">retry:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启超时重试机制</span><br>        <span class="hljs-attr">initial-interval:</span> <span class="hljs-string">1000ms</span> <span class="hljs-comment"># 失败后的初始等待时间</span><br>        <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span><br>        <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 最大重试次数</span><br></code></pre></td></tr></table></figure><h4 id="二、生产者确认机制"><a href="#二、生产者确认机制" class="headerlink" title="二、生产者确认机制"></a>二、生产者确认机制</h4><p>确保消息正确发送到MQ，不会出现以下情况：</p><ul><li>MQ内部处理异常</li><li>找不到交换机</li><li>经过交换机后找不到对应的队列</li></ul><blockquote><p>生产者确认开启后，编写代码处理MQ回执ack、nack</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">correlated</span> <span class="hljs-comment"># 开启publisher confirm机制，并设置confirm类型</span><br>    <span class="hljs-attr">publisher-returns:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启publisher return机制</span><br></code></pre></td></tr></table></figure><p>这里<code>publisher-confirm-type</code>有三种模式可选：</p><ul><li><code>none</code>：关闭confirm机制</li><li><code>simple</code>：同步阻塞等待MQ的回执</li><li><code>correlated</code>：MQ异步回调返回回执</li></ul><ol><li><p>全局配置——定义ReturnCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MqConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        rabbitTemplate.setReturnsCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RabbitTemplate</span>.ReturnsCallback() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(ReturnedMessage returned)</span> &#123;<br>                log.error(<span class="hljs-string">&quot;触发return callback,&quot;</span>);<br>                log.debug(<span class="hljs-string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());<br>                log.debug(<span class="hljs-string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());<br>                log.debug(<span class="hljs-string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());<br>                log.debug(<span class="hljs-string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());<br>                log.debug(<span class="hljs-string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>单次发送消息配置——定义ConfirmCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPublisherConfirm</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.创建CorrelationData</span><br>    <span class="hljs-type">CorrelationData</span> <span class="hljs-variable">cd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>();<br>    <span class="hljs-comment">// 2.给Future添加ConfirmCallback</span><br>    cd.getFuture().addCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable ex)</span> &#123;<br>            <span class="hljs-comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span><br>            log.error(<span class="hljs-string">&quot;send message fail&quot;</span>, ex);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(CorrelationData.Confirm result)</span> &#123;<br>            <span class="hljs-comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span><br>            <span class="hljs-keyword">if</span>(result.isAck())&#123; <span class="hljs-comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span><br>                log.debug(<span class="hljs-string">&quot;发送消息成功，收到 ack!&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// result.getReason()，String类型，返回nack时的异常描述</span><br>                log.error(<span class="hljs-string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason());<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 3.发送消息</span><br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;hmall.direct&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, cd);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="三、MQ的可靠性"><a href="#三、MQ的可靠性" class="headerlink" title="三、MQ的可靠性"></a>三、MQ的可靠性</h4><ul><li><p>交换机、队列持久化</p></li><li><p>消息持久化</p><p><code>消息的持久化是要配置一个properties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendPersistentMessage</span><span class="hljs-params">(String messageContent)</span> &#123;<br>      <span class="hljs-comment">// 创建消息属性</span><br>    <span class="hljs-type">MessageProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageProperties</span>();<br>      <span class="hljs-comment">// 设置消息持久化</span><br>properties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);<br>      <span class="hljs-comment">// 创建消息对象</span><br>   <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(messageContent.getBytes(), properties);<br>      <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.send(<span class="hljs-string">&quot;exchange.persistent&quot;</span>, <span class="hljs-string">&quot;routing.key.persistent&quot;</span>, message);<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>在开启持久化机制以后，如果同时还开启了生产者确认，那么MQ会在消息持久化以后才发送ACK回执，进一步确保消息的可靠性。</p></blockquote><blockquote><p>不过出于性能考虑，为了减少IO次数，发送到MQ的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在100毫秒左右，这就会导致ACK有一定的延迟，因此建议生产者确认全部采用异步方式。</p></blockquote></li><li><p>消息存储方式改变</p><p>默认情况下，MQ会将收到的信息保存在内存中以降低消息收发的延迟</p><p>以下几种情况，会出现消息积压</p><ul><li>消费者宕机、网络断开</li><li>消费者处理速度跟不上</li></ul><p>触发内存预警上线，MQ会将内存消息刷到磁盘上，会阻塞进程队列，为了解决这个问题，MQ3.6版本后添加了Lazy Queues的模式，3.12版本后，默认为LazyQueue格式</p><blockquote><p>Lazy Queues 惰性队列</p><ul><li>收到消息后直接存入磁盘</li><li>消费者需要消息的时候才会从磁盘中读取并加载到内存</li><li>支持百万条消息存储</li></ul></blockquote></li></ul><h4 id="四、消费者的可靠性"><a href="#四、消费者的可靠性" class="headerlink" title="四、消费者的可靠性"></a>四、消费者的可靠性</h4><blockquote><p>消费者处理消息借宿后，向MQ发送回执，回执有以下几种类型</p><ul><li>ack 成功 mq删除消息</li><li>nack 失败 mq需要再次投递消息</li><li>reject 失败并拒绝 mq删除消息</li></ul></blockquote><h5 id="SpringAMQP提供的消息确认模式"><a href="#SpringAMQP提供的消息确认模式" class="headerlink" title="SpringAMQP提供的消息确认模式"></a>SpringAMQP提供的消息确认模式</h5><ul><li>none 不处理</li><li>auto 自动处理 AMQP使用AOP对消息处理逻辑做了增强，正常执行业务时，返回ack，出现业务异常，返回nack，出现消息处理或者校验异常，返回reject</li><li>manual 手动处理</li></ul><h5 id="失败重试机制"><a href="#失败重试机制" class="headerlink" title="失败重试机制"></a>失败重试机制</h5><p>消息不断入队投递，导致无限循环，带来不必要的压力</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">retry:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启消费者失败重试</span><br>          <span class="hljs-attr">initial-interval:</span> <span class="hljs-string">1000ms</span> <span class="hljs-comment"># 初识的失败等待时长为1秒</span><br>          <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span><br>          <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 最大重试次数</span><br>          <span class="hljs-attr">stateless:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span><br></code></pre></td></tr></table></figure><ul><li>消费者在失败后消息没有重新回到MQ无限重新投递，而是在本地重试了3次</li><li>本地重试3次以后，抛出了<code>AmqpRejectAndDontRequeueException</code>异常。查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是<code>reject</code></li></ul><p>死信队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 配置RabbitListenerContainerFactory使用RepublishMessageRecoverer</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SimpleRabbitListenerContainerFactory <span class="hljs-title function_">rabbitListenerContainerFactory</span><span class="hljs-params">(</span><br><span class="hljs-params">            ConnectionFactory connectionFactory,</span><br><span class="hljs-params">            RepublishMessageRecoverer republishMessageRecoverer)</span> &#123;<br>        <span class="hljs-type">SimpleRabbitListenerContainerFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRabbitListenerContainerFactory</span>();<br>        factory.setConnectionFactory(connectionFactory);<br>        <span class="hljs-comment">// 设置消息重试策略</span><br>        factory.setRetryTemplate(retryTemplate()); <br>        <span class="hljs-comment">// 设置消息恢复器 - 重试失败后将消息发送到死信队列</span><br>        factory.setRecoveryCallback(republishMessageRecoverer);<br>        <span class="hljs-comment">// 设置手动确认模式</span><br>        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);<br>        <span class="hljs-keyword">return</span> factory;<br>    &#125;<br><br>    <span class="hljs-comment">// 配置重试模板</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RetryTemplate <span class="hljs-title function_">retryTemplate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SimpleRetryPolicy</span> <span class="hljs-variable">retryPolicy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRetryPolicy</span>();<br>        retryPolicy.setMaxAttempts(<span class="hljs-number">3</span>); <span class="hljs-comment">// 最多重试3次</span><br>        <span class="hljs-type">ExponentialBackOffPolicy</span> <span class="hljs-variable">backOffPolicy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackOffPolicy</span>();<br>        backOffPolicy.setInitialInterval(<span class="hljs-number">500</span>); <span class="hljs-comment">// 初始重试间隔500毫秒</span><br>        backOffPolicy.setMultiplier(<span class="hljs-number">2.0</span>); <span class="hljs-comment">// 每次重试间隔加倍</span><br>        backOffPolicy.setMaxInterval(<span class="hljs-number">10000</span>); <span class="hljs-comment">// 最大重试间隔10秒</span><br>        <span class="hljs-type">RetryTemplate</span> <span class="hljs-variable">retryTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RetryTemplate</span>();<br>        retryTemplate.setRetryPolicy(retryPolicy);<br>        retryTemplate.setBackOffPolicy(backOffPolicy);<br>        <span class="hljs-keyword">return</span> retryTemplate;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="五、兜底方案"><a href="#五、兜底方案" class="headerlink" title="五、兜底方案"></a>五、兜底方案</h4><p>​消费端可以根据自己的业务逻辑，主动去查询业务信息进行操作。</p><h3 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h3><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.config;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.*;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br><br>    <span class="hljs-comment">// 定义延迟交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">delayExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;delay.exchange&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义死信交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">deadLetterExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;deadletter.exchange&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义延迟队列 - 配置死信交换机和路由键</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">delayQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(<span class="hljs-string">&quot;delay.queue&quot;</span>)<br>                .withArgument(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, <span class="hljs-string">&quot;deadletter.exchange&quot;</span>)<br>                .withArgument(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;deadletter.routing.key&quot;</span>)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-comment">// 定义死信队列</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">deadLetterQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;deadletter.queue&quot;</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定延迟队列到延迟交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">delayBinding</span><span class="hljs-params">(Queue delayQueue, DirectExchange delayExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(delayQueue).to(delayExchange).with(<span class="hljs-string">&quot;delay.routing.key&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定死信队列到死信交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">deadLetterBinding</span><span class="hljs-params">(Queue deadLetterQueue, DirectExchange deadLetterExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(deadLetterQueue).to(deadLetterExchange).with(<span class="hljs-string">&quot;deadletter.routing.key&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快捷键-配置合集</title>
    <link href="/2025/05/09/%E5%BF%AB%E6%8D%B7%E9%94%AE-%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/05/09/%E5%BF%AB%E6%8D%B7%E9%94%AE-%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="快捷键-配置合集"><a href="#快捷键-配置合集" class="headerlink" title="快捷键 &amp; 配置合集"></a>快捷键 &amp; 配置合集</h1><hr><h2 id="IDEA-快捷键"><a href="#IDEA-快捷键" class="headerlink" title="IDEA 快捷键"></a>IDEA 快捷键</h2><blockquote><p>IDEA 常用快捷键设置如下：</p></blockquote><p><img src="/../images/%E5%BF%AB%E6%8D%B7%E9%94%AE_IDEA_%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%BE%E7%BD%AE.png" alt="IDEA 快捷键设置"></p><hr><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ul><li><p><strong>格式化代码</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Ctrl</span> + Alt + L<br></code></pre></td></tr></table></figure></li><li><p><strong>插入空行</strong></p><ul><li>向上插入空行：<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Ctrl</span> <span class="hljs-operator">+</span> <span class="hljs-variable">Alt</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">Enter</span><br></code></pre></td></tr></table></figure></li><li>向下插入空行：<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">Shift</span> + Enter<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>多行编辑</strong></p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">Ctrl + <span class="hljs-built_in">Shift</span> + Alt + 鼠标左键选中<br></code></pre></td></tr></table></figure></li><li><p><strong>缩进</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Shift + <span class="hljs-literal">Tab</span><br></code></pre></td></tr></table></figure></li><li><p><strong>复制当前行到下一行</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Ctrl</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">D</span><br></code></pre></td></tr></table></figure></li><li><p><strong>查找最近打开的文件</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Ctrl</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">E</span><br></code></pre></td></tr></table></figure></li><li><p>删除无用的import</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Crtl</span> <span class="hljs-operator">+</span> <span class="hljs-variable">Alt</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">O</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="代码提示与补全"><a href="#代码提示与补全" class="headerlink" title="代码提示与补全"></a>代码提示与补全</h3><ul><li><strong>智能补全（更广泛的补全范围）</strong><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Ctrl</span> + 空格<br></code></pre></td></tr></table></figure></li><li><strong>代码片段提示</strong><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Ctrl</span> + J<br></code></pre></td></tr></table></figure></li><li><strong>快速修正语法</strong><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Alt</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">Enter</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="结构与导航"><a href="#结构与导航" class="headerlink" title="结构与导航"></a>结构与导航</h3><ul><li><strong>显示类结构图（继承层次）</strong><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Ctrl</span> + H<br></code></pre></td></tr></table></figure></li><li><strong>定位到代码块开始&#x2F;结束</strong><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Ctrl</span> +<span class="hljs-meta"> [</span><br><span class="hljs-meta">Ctrl + ]</span><br></code></pre></td></tr></table></figure></li><li><strong>跳转到方法源码</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">Ctrl + <span class="hljs-selector-tag">B</span><br></code></pre></td></tr></table></figure></li><li><strong>跳转到当前类的父类</strong><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Ctrl</span> + U<br></code></pre></td></tr></table></figure></li><li><strong>显示当前方法</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">Alt + <span class="hljs-selector-tag">Q</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="快速切换"><a href="#快速切换" class="headerlink" title="快速切换"></a>快速切换</h3><ul><li><strong>打开&#x2F;隐藏 Project 面板</strong><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Alt</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><strong>显示类结构（属性和方法）</strong><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Alt</span> + <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure></li><li><strong>切换代码视图</strong><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Alt</span> + → / Alt + ←<br></code></pre></td></tr></table></figure></li><li><strong>切换方法</strong><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Alt</span> + ↑ / Alt + ↓<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="代码包裹"><a href="#代码包裹" class="headerlink" title="代码包裹"></a>代码包裹</h3><ul><li><strong>用 if&#x2F;while&#x2F;try-catch 等包裹选中代码</strong><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">Ctrl + Alt + <span class="hljs-built_in">T</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="Typora-快捷键及配置"><a href="#Typora-快捷键及配置" class="headerlink" title="Typora 快捷键及配置"></a>Typora 快捷键及配置</h2><ul><li><strong>换行后消除格式</strong><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Ctrl</span> + [<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="修改-base-显示过长问题"><a href="#修改-base-显示过长问题" class="headerlink" title="修改 base 显示过长问题"></a>修改 base 显示过长问题</h3><p>进入：<code>偏好设置 → 外观 → 打开主题文件夹</code>，找到你使用的样式 CSS，编辑并在最后一行加入：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.md-def-content</span><span class="hljs-selector-class">.md-def-url</span><span class="hljs-selector-class">.md-auto-disp</span> &#123;<br>    <span class="hljs-comment">/* max-width: 100%; */</span><br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">overflow</span>: hidden <span class="hljs-meta">!important</span>;<br>    <span class="hljs-attribute">white-space</span>: nowrap <span class="hljs-meta">!important</span>;<br>&#125;<br><br><span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.md-image-src-span</span><span class="hljs-selector-class">.ty-focusable</span> &#123;<br>    <span class="hljs-comment">/* display: none; */</span><br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> - <span class="hljs-number">20px</span>);<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">overflow</span>: hidden <span class="hljs-meta">!important</span>;<br>    <span class="hljs-attribute">white-space</span>: nowrap <span class="hljs-meta">!important</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="Windows-快捷键"><a href="#Windows-快捷键" class="headerlink" title="Windows 快捷键"></a>Windows 快捷键</h2><ul><li><p><strong>分词</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">enter</span> 左边的键  ’<br></code></pre></td></tr></table></figure></li><li><p><strong>前进</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">Ctrl + <span class="hljs-attribute">Y</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="VSCode-快捷键"><a href="#VSCode-快捷键" class="headerlink" title="VSCode 快捷键"></a>VSCode 快捷键</h2><ul><li><p><strong>竖列多行选择</strong></p><blockquote><p>先选择起始点，然后按住 Alt + Shift 并用鼠标左键拖动。</p></blockquote><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">Alt + <span class="hljs-built_in">Shift</span> + 鼠标左键拖动<br></code></pre></td></tr></table></figure></li><li><p><strong>多行末尾插入光标</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">Shift + Alt + <span class="hljs-selector-tag">I</span><br></code></pre></td></tr></table></figure></li></ul><hr><div align="center">🤑😅🌱</div>]]></content>
    
    
    <categories>
      
      <category>快捷键-配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快捷键-配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态代理</title>
    <link href="/2025/05/05/java/%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2025/05/05/java/%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>实现动态代理一般有两种形式，一种方式是通过jdk自带的动态代理实现，通过反射实现，只能对实现接口的类进行代理；另一种方式是通过CGLIB实现，其针对类进实现代理，对指定的类生成一个子类，覆盖其中的方法，不能代理final修饰的类。</p></blockquote><h3 id="JDK自带的动态代理"><a href="#JDK自带的动态代理" class="headerlink" title="JDK自带的动态代理"></a>JDK自带的动态代理</h3><p>先看一个例子</p><ul><li><p>首先，我们有一个接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">DoSomething</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>有一个类实现了该接口</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-title">implements</span> <span class="hljs-title">DoSomething</span> </span>&#123;<br><br>        <span class="hljs-variable">@Override</span><br>        public void doSomething() &#123;<br>            System.out.println(<span class="hljs-string">&quot;drive drive&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>在代码逻辑中，我们new了一个car对象，通过Proxy.newProxyInstance进行代理</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Proxy.newProxyInstance(car.getClass().getClassLoader(), car.getClass().getInterfaces(), <span class="hljs-built_in">new</span> InvocationHandler() &#123;<br>    @Override<br>    <span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> invoke(<span class="hljs-keyword">Object</span> proxy, <span class="hljs-keyword">Method</span> <span class="hljs-keyword">method</span>, <span class="hljs-keyword">Object</span>[] args) throws Throwable &#123;<br>        // 在调用方法前可以添加额外的逻辑<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Before method call.&quot;);<br><br>        // 调用实际对象的方法<br>        <span class="hljs-keyword">Object</span> result = <span class="hljs-keyword">method</span>.invoke(car, args);<br><br>        // 在调用方法后可以添加额外的逻辑<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;After method call.&quot;);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>动态代理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm</title>
    <link href="/2025/05/04/java/%E5%9F%BA%E7%A1%80/jvm/"/>
    <url>/2025/05/04/java/%E5%9F%BA%E7%A1%80/jvm/</url>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新中</p></blockquote><h5 id="jit-即时编译"><a href="#jit-即时编译" class="headerlink" title="jit 即时编译"></a>jit 即时编译</h5><h5 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h5><blockquote><p>栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等。</p><p>而堆只负责存储对象信息。</p></blockquote><ul><li><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据</p></li><li><p>堆解决的是数据存储的问题，即数据怎么放、放在哪儿</p></li></ul><p>为什么要把堆和栈区分？</p><ul><li>从设计的角度来看，栈代表了处理逻辑，而堆代表了数据，这样分开，处理逻辑更为清晰，分而治之的思想，这种隔离、模块化的思想在软件设计的方方面面都有体现。</li><li>堆和栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象），这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式（如共享内存），另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</li><li>栈因为运行时的需要，比如保存系统运行的上下文，需要对地址段划分，由于栈只能<strong>向上增长</strong>，因此就会<strong>限制</strong>住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</li><li>面向对象就是对合栈的完美结合。面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为，就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写了处理数据的逻辑。</li></ul><p>堆中存的是对象，栈中存的是基本数据类型和堆中对象的引用，大小为4byte。</p><p>为什么不把基本类型放在堆中？</p><p>​其占用的内存一般是1~8个字节，需要空间比较少，而且因为是基本类型，所以不会出现动态增长的清空，因此栈中存储就够了，如果把他存在堆中没有什么意义。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据，一个是堆中的数据。最常见的一个问题就是，java中参数传递的问题。</p><h5 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h5><p>按回收策略分类</p><ul><li><p>引用计数</p><ul><li>原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收<br>时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</li></ul></li><li><p>标记 清除</p><ul><li>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的<br>对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</li></ul></li><li><p>复制</p><ul><li>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在<br>使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制<br>过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两<br>倍内存空间。</li></ul></li><li><p>标记-整理</p><ul><li>此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引<br>用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此<br>算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题</li></ul></li></ul><p>按照分区对待的方式分</p><ul><li>增量搜集：实时垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么<br>原因JDK5.0中的收集器没有使用这种算法的。</li><li>分代收集：基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青<br>代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。</li></ul><p>按照系统线程分</p><ul><li>串行收集:串行收集使用单线程处理所有垃圾回收工作，因为无需多线程交互，实现容易，而且效率比较高。但是，其局限性也比较明显，即无法使用多处理器的优势，所以此收集适合单处理器机器。当然，此收集器也可以用在小数据量（100M左右）情况下的多处理器机器上。</li><li>并行收集:并行收集使用多线程处理垃圾回收工作，因而速度快，效率高。而且理论上CPU数目越多，越能体现出并行收集器的优势。</li><li>并发收集:相对于串行收集和并行收集而言，前面两个在进行垃圾回收工作时，需要暂停整个运行环境，而只有垃圾回收程序在运行，因此，系统在垃圾回收时会有明显的暂停，而且暂停时间会因为堆越大而越长。</li></ul><h5 id="为什么要分代"><a href="#为什么要分代" class="headerlink" title="为什么要分代"></a>为什么要分代</h5><p>分代的垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p>试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</p><h5 id="如何分段"><a href="#如何分段" class="headerlink" title="如何分段"></a>如何分段</h5><p>年轻代、年老代和持久代，其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。</p><ul><li><p>年轻代</p><p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p></li><li><p>年老代</p><p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象</p></li><li><p>持久代</p><p>用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize&#x3D;<N>进行设置。</p></li></ul><h5 id="什么时候触发垃圾回收"><a href="#什么时候触发垃圾回收" class="headerlink" title="什么时候触发垃圾回收"></a>什么时候触发垃圾回收</h5><ul><li><p>Scavenge GC<br>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p></li><li><p>Full GC</p><p>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比ScavengeGC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p><p>· 年老代（Tenured）被写满</p><p>· 持久代（Perm）被写满</p><p>· System.gc()被显示调用</p><p>·上一次GC之后Heap的各域分配策略动态变化</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一记</title>
    <link href="/2025/05/03/java/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    <url>/2025/05/03/java/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h1><blockquote><p>代码方面见git，下面只记录一些知识点</p></blockquote><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#202554">2025&#x2F;5&#x2F;4</a></li><li><a href="#202555">2025&#x2F;5&#x2F;5</a></li><li><a href="#202556">2025&#x2F;5&#x2F;6</a></li><li><a href="#202558">2025&#x2F;5&#x2F;8</a></li><li><a href="#2025511">2025&#x2F;5&#x2F;11</a></li><li><a href="#2025513">2025&#x2F;5&#x2F;13</a></li><li><a href="#2025519">2025&#x2F;5&#x2F;19</a></li><li><a href="#threadlocal">ThreadLocal</a></li><li><a href="#%E9%9B%86%E5%90%88">集合</a></li><li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a></li><li><a href="#dubbo">Dubbo</a></li><li><a href="#oom%E6%8E%92%E6%9F%A5">OOM排查</a></li><li><a href="#jvisualvm%E7%9A%84%E4%BD%BF%E7%94%A8">JVisualVM的使用</a></li><li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">负载均衡算法</a></li><li><a href="#job-worker%E6%A8%A1%E5%9D%97%E4%B9%8B%E4%BD%BF%E7%94%A8-power-job">job-worker模块之使用 power-job</a></li><li><a href="#%E9%A1%B9%E7%9B%AE">项目</a></li></ul><hr><h2 id="2025-5-4"><a href="#2025-5-4" class="headerlink" title="2025&#x2F;5&#x2F;4"></a>2025&#x2F;5&#x2F;4</h2><h3 id="互联网项目一般建议单表查询"><a href="#互联网项目一般建议单表查询" class="headerlink" title="互联网项目一般建议单表查询"></a>互联网项目一般建议单表查询</h3><ul><li>单表查询结果更易缓存，多表连接查询的话，每个表的记录都要引起缓存的变动</li><li>后续有变动的时候，我只需要关注一小部分，而不用关注整个查询</li><li>代码复用性高</li><li>占内存，资源的瓶颈在数据库上</li></ul><hr><h3 id="left-join-和-right-join-有什么区别"><a href="#left-join-和-right-join-有什么区别" class="headerlink" title="left join 和 right join 有什么区别"></a>left join 和 right join 有什么区别</h3><hr><h3 id="联合索引分析"><a href="#联合索引分析" class="headerlink" title="联合索引分析"></a>联合索引分析</h3><blockquote><p>加了一个联合索引 name_phone，分析下这几个 SQL 会走索引吗？</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> &quot;%130&quot; <span class="hljs-keyword">and</span> name <span class="hljs-operator">=</span> &quot;w&quot;;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> &quot;w&quot; <span class="hljs-keyword">and</span> phone <span class="hljs-keyword">like</span> &quot;%130&quot;;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> &quot;w%&quot; <span class="hljs-keyword">and</span> phone <span class="hljs-keyword">like</span> &quot;130&quot;;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> &quot;%w%&quot; <span class="hljs-keyword">and</span> phone <span class="hljs-keyword">like</span> &quot;130&quot;;<br></code></pre></td></tr></table></figure><hr><h3 id="如何计算数据量占用内存"><a href="#如何计算数据量占用内存" class="headerlink" title="如何计算数据量占用内存"></a>如何计算数据量占用内存</h3><hr><h3 id="Java-线程池参数"><a href="#Java-线程池参数" class="headerlink" title="Java 线程池参数"></a>Java 线程池参数</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>核心线程数</td><td>线程池长期保持存活的线程数量</td></tr><tr><td>最大线程数</td><td>当任务队列已满，且当前线程数小于 maximumPoolSize 时，线程池会创建新的线程来处理任务，直到达到 maximumPoolSize</td></tr><tr><td>拒绝策略</td><td>handler，任务无法处理时的策略</td></tr><tr><td>workQueue</td><td>用于存储待执行任务的阻塞队列。当提交的任务数超过 corePoolSize 时，新任务会被放入这个队列中等待处理。</td></tr><tr><td>keepAliveTime</td><td>线程池中的线程数量超过 corePoolSize 时，多余的空闲线程在被销毁之前等待新任务的最长时间。</td></tr></tbody></table><hr><h3 id="为什么线程池里面要设置一个队列？"><a href="#为什么线程池里面要设置一个队列？" class="headerlink" title="为什么线程池里面要设置一个队列？"></a>为什么线程池里面要设置一个队列？</h3><hr><h3 id="无界队列一直往里面放，会先达到最大线程数还是会先内存溢出？救急线程？"><a href="#无界队列一直往里面放，会先达到最大线程数还是会先内存溢出？救急线程？" class="headerlink" title="无界队列一直往里面放，会先达到最大线程数还是会先内存溢出？救急线程？"></a>无界队列一直往里面放，会先达到最大线程数还是会先内存溢出？救急线程？</h3><ul><li>创建救急线程的前提是队列满</li><li>线程数会一直维持在核心线程数，不会达到最大线程数</li><li>随着任务持续加入队列，队列会不断占用内存。若任务生成速度远超核心线程处理速度，最终会因队列占用过多内存而导致内存溢出</li></ul><hr><h3 id="MySQL-执行很慢，如何排查"><a href="#MySQL-执行很慢，如何排查" class="headerlink" title="MySQL 执行很慢，如何排查"></a>MySQL 执行很慢，如何排查</h3><hr><h3 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h3><ul><li><p><strong>索引列使用了函数</strong></p></li><li><p><strong>使用 OR 导致索引失效</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">OR</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">-- 若 b 无索引，全表扫描</span><br><span class="hljs-comment">--MySQL 无法对 OR 条件合并索引。</span><br><span class="hljs-comment">--拆分为 UNION ALL 或为 b 添加索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>模糊查询以 % 开头</strong></p></li><li><p><strong>索引列与查询值类型不一致</strong></p></li><li><p><strong>非等值查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;active&#x27;</span>; <span class="hljs-comment">-- 可能全表扫描</span><br><span class="hljs-comment">-- 非等值操作符难以通过索引快速定位数据</span><br></code></pre></td></tr></table></figure></li><li><p><strong>查询索引列的 NULL 值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>; <span class="hljs-comment">-- 若 NULL 值极少，可能走索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT NULL</span>; <span class="hljs-comment">-- 可能全表扫描</span><br></code></pre></td></tr></table></figure></li><li><p><strong>数据量过小，优化器认为全表扫描比索引更快</strong></p></li><li><p><strong>范围查询后的索引列失效</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 联合索引 (age, name)</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">18</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;John&#x27;</span>; <span class="hljs-comment">-- name 无法使用索引</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="走了索引也很慢怎么办"><a href="#走了索引也很慢怎么办" class="headerlink" title="走了索引也很慢怎么办"></a>走了索引也很慢怎么办</h3><ul><li>先判断是不是索引创建的有问题，索引基数小的放在了左边</li><li>是不是没使用覆盖索引，走了回表</li><li>看 CPU 占用</li><li>看连接数</li></ul><hr><h3 id="count-和-count-1-有什么区别"><a href="#count-和-count-1-有什么区别" class="headerlink" title="count(*) 和 count(1) 有什么区别"></a>count(*) 和 count(1) 有什么区别</h3><blockquote><p>数据库会将 1 视为一个常量，作为一个伪列，每行都会生成一个值为 1 的伪列。性能上一般与 COUNT(<em>) 接近，但 COUNT(</em>) 在 MySQL 经过了更多优化，因此通常优先选择 COUNT(<em>)。某些旧版的数据库系统在处理COUNT(</em>)时，可能会去解析整行数据，而COUNT(1)可以直接统计行数，因此会有一些微小的性能差异。</p></blockquote><hr><h3 id="多线程插入失败如何处理"><a href="#多线程插入失败如何处理" class="headerlink" title="多线程插入失败如何处理"></a>多线程插入失败如何处理</h3><ul><li>多线程插入，其中一个线程插入失败了，怎么办？</li></ul><hr><h3 id="多线程事务控制"><a href="#多线程事务控制" class="headerlink" title="多线程事务控制"></a>多线程事务控制</h3><hr><h3 id="前端页面导出大文件，后端内存不足如何导出？"><a href="#前端页面导出大文件，后端内存不足如何导出？" class="headerlink" title="前端页面导出大文件，后端内存不足如何导出？"></a>前端页面导出大文件，后端内存不足如何导出？</h3><hr><h3 id="设计抖音"><a href="#设计抖音" class="headerlink" title="设计抖音"></a>设计抖音</h3><hr><h3 id="Java异常体系设计"><a href="#Java异常体系设计" class="headerlink" title="Java异常体系设计"></a>Java异常体系设计</h3><ul><li><strong>编译时异常</strong>：强制开发者在编译阶段预见并处理可预期的、程序外部的异常情况（如 IO 操作失败、网络连接中断、用户输入错误等）。</li><li><strong>运行时异常</strong>：表示程序逻辑错误，这类错误应在开发阶段通过代码审查、测试等手段避免，而非强制在运行时处理。</li><li><strong>Error</strong>：表示系统级的严重错误，如 JVM 内存溢出、栈溢出、类文件损坏等。</li></ul><hr><h2 id="2025-5-5"><a href="#2025-5-5" class="headerlink" title="2025&#x2F;5&#x2F;5"></a>2025&#x2F;5&#x2F;5</h2><h3 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h3><hr><h3 id="DFS、BFS"><a href="#DFS、BFS" class="headerlink" title="DFS、BFS"></a>DFS、BFS</h3><hr><h3 id="单点登录（SSO）流程"><a href="#单点登录（SSO）流程" class="headerlink" title="单点登录（SSO）流程"></a>单点登录（SSO）流程</h3><ol><li>系统的登录页放弃原有逻辑，直接在js里window.location跳转到认证中心的授权接口</li><li>用户输入用户名、密码进行验证。认证通过后，生成AuthonrizeCode，认证中心会发送请求到子系统给的redirect_uri，请求参数中包含AuthonrizeCode。</li><li>子系统接收到AuthonrizeCode，根据AuthonrizeCode调用获取Token接口，获取Token。</li><li>子系统根据返回的AccessToken调用获取认证用户接口，获取到用户信息，然后到子系统数据库中校验该用户是否存在，即是否有权限，有则放行，用户就能正常进入子系统。</li></ol><hr><h3 id="Maven依赖冲突解决"><a href="#Maven依赖冲突解决" class="headerlink" title="Maven依赖冲突解决"></a>Maven依赖冲突解决</h3><ul><li>最近定义优先，依赖树中路径最短的版本胜出</li><li>声明顺序优先，假如深度相同，最先声明的依赖版本胜出</li><li>显示声明版本</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.14.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 强制指定版本 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mvn dependency:tree -Dincludes=org.apache.logging.log4j:log4j-core<br></code></pre></td></tr></table></figure><hr><h3 id="如何打破双亲委派的规则"><a href="#如何打破双亲委派的规则" class="headerlink" title="如何打破双亲委派的规则"></a>如何打破双亲委派的规则</h3><hr><h3 id="JVM内存分区的概念"><a href="#JVM内存分区的概念" class="headerlink" title="JVM内存分区的概念"></a>JVM内存分区的概念</h3><hr><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.ANNOTATION_TYPE)</span><br></code></pre></td></tr></table></figure><hr><h3 id="为什么int-3-必须要指定大小？"><a href="#为什么int-3-必须要指定大小？" class="headerlink" title="为什么int[3]必须要指定大小？"></a>为什么int[3]必须要指定大小？</h3><hr><h2 id="2025-5-6"><a href="#2025-5-6" class="headerlink" title="2025&#x2F;5&#x2F;6"></a>2025&#x2F;5&#x2F;6</h2><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul><li>为什么https下不能使用http</li><li>协商缓存、强制缓存</li></ul><hr><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li>粘包</li></ul><hr><h3 id="Comparable-与-Comparator"><a href="#Comparable-与-Comparator" class="headerlink" title="Comparable 与 Comparator"></a>Comparable 与 Comparator</h3><ul><li>Comparable 侵入式    整数、零或正整数，对应对象小于、等于或大于指定对象。</li><li>Comparator 非侵入性</li></ul><hr><h3 id="二叉平衡树遍历"><a href="#二叉平衡树遍历" class="headerlink" title="二叉平衡树遍历"></a>二叉平衡树遍历</h3><ul><li>前序、中序、后序遍历</li></ul><hr><h2 id="2025-5-8"><a href="#2025-5-8" class="headerlink" title="2025&#x2F;5&#x2F;8"></a>2025&#x2F;5&#x2F;8</h2><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><hr><h3 id="triple协议"><a href="#triple协议" class="headerlink" title="triple协议"></a>triple协议</h3><hr><h2 id="2025-5-11"><a href="#2025-5-11" class="headerlink" title="2025&#x2F;5&#x2F;11"></a>2025&#x2F;5&#x2F;11</h2><h3 id="浮点数二进制表示"><a href="#浮点数二进制表示" class="headerlink" title="浮点数二进制表示"></a>浮点数二进制表示</h3><blockquote><p>0.2转换成二进制，依次成2，记录整数部分</p><p>0.0011 0011 0011  &#x3D;  1&#x2F; 8 + 1 &#x2F; 16 +  1&#x2F;128 + 1&#x2F;256 …</p></blockquote><hr><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;52.73&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>此代码使用一个long存储了5273，并记录了总位数以及小数点位数</p></blockquote><p><img src="/../../images/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0_bigdecimal.png" alt="BigDecimal存储原理"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;52.73&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;32.5&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalAdd</span> <span class="hljs-operator">=</span> bigDecimal1.add(bigDecimal2);<br></code></pre></td></tr></table></figure><blockquote><p>此代码在计算的时候，会先对其小数位，然后相加</p></blockquote><p><img src="/../../images/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0%E5%BD%95_bigdecimal_add.png" alt="BigDecimal加法原理"></p><hr><h3 id="equals方法会比较精度"><a href="#equals方法会比较精度" class="headerlink" title="equals方法会比较精度"></a>equals方法会比较精度</h3><hr><h3 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h3><ul><li>JDK：Java开发环境，包含了JRE、编译器javac和其他工具，比如javadoc、jconsole、javap等</li><li>JRE：Java运行时环境，主要包含JVM和Java类库</li></ul><blockquote><p>从Java9开始，不再区分JDK和JRE，取而代之的是模块系统+ jlink工具。JDK11开始，oracle不再提供单独的JRE下载。</p></blockquote><ul><li>可以用 jlink 根据自己的需求，创建一个更小的 runtime（运行时）</li><li>定制的、模块化的 Java 运行时映像有助于简化 Java 应用的部署和节省内存并增强安全性和可维护性。</li></ul><hr><h3 id="字节码、JIT"><a href="#字节码、JIT" class="headerlink" title="字节码、JIT"></a>字节码、JIT</h3><blockquote><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p></blockquote><ul><li>JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。</li><li>JIT（Just in Time Compilation）编译器，属于运行时编译。</li><li>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。</li></ul><hr><h3 id="Oracle-JDK-和-OpenJDK"><a href="#Oracle-JDK-和-OpenJDK" class="headerlink" title="Oracle JDK 和 OpenJDK"></a>Oracle JDK 和 OpenJDK</h3><ul><li>一个不开源一个开源</li><li>一个高版本后要收费</li></ul><hr><h3 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++ 的区别"></a>Java 和 C++ 的区别</h3><ul><li>Java中不提供指针来直接访问内存</li><li>Java类是单继承的、C++支持多重继承</li><li>Java有自动垃圾回收GC，C++需要手动释放内存</li><li>Java是编译 + 解释型语言，C++是编译型语言</li></ul><hr><h3 id="基本类型和泛型的区别"><a href="#基本类型和泛型的区别" class="headerlink" title="基本类型和泛型的区别"></a>基本类型和泛型的区别</h3><ul><li>内存的占用和默认值，比如代理的时候，返回null，基本数据类型会报错</li><li>基本类型不可以被泛型使用</li><li>局部变量基本类型存在JVM虚拟机栈的局部变量表中</li></ul><blockquote><p>⚠️ 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆&#x2F;方法区&#x2F;元空间中。</p></blockquote><hr><h3 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h3><ul><li><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>TRUE</code> or <code>FALSE</code>。</li></ul><hr><h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h3><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><hr><h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><blockquote><p>从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p></blockquote><hr><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><ul><li><strong>重载</strong>：一个类中多个同名方法根据不同的参数类型来确定执行对应方法。</li><li><strong>重写</strong>：子类对父类运行访问的方法实现过程进行重写。</li></ul><blockquote><p>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。<br>如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p></blockquote><hr><h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><ul><li>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数</li><li>遇到方法重载的情况会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</li></ul><hr><h3 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h3><blockquote><p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。<br>构造方法<strong>不能被重写（override）</strong>，但<strong>可以被重载（overload）</strong>。因此，一个类中可以有多个构造方法，这些构造方法可以具有不同的参数列表，以提供不同的对象初始化方式。</p></blockquote><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote><p>父类的引用指向子类的实例。</p></blockquote><hr><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><ul><li>都不能实例化</li><li>定义了一个方法，（抽象方法、接口方法），都需要子类或者抽象类中去实现，default和static除外，java9后，接口可以包含private方法</li><li>接口是行为的抽象，类是所属关系，用于代码复用。接口可以多实现</li><li>接口中的成员变量只能是public static final类型，不能修改且必须有初始值。抽象类的成员变量可以有任何修饰符，在子类中可以被重写定义或者赋值。</li></ul><hr><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><blockquote><p>Java 9 将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code><br>新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span> + <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> str1 + str2;<br><span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string&quot;</span>;<br>System.out.println(str3 == str4);<span class="hljs-comment">//false</span><br>System.out.println(str3 == str5);<span class="hljs-comment">//true</span><br>System.out.println(str4 == str5);<span class="hljs-comment">//false</span><br><span class="hljs-comment">// 对象引用和“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 </span><br><span class="hljs-comment">// 对于 String str3 = &quot;str&quot; + &quot;ing&quot;; 编译器会给你优化成 String str3 = &quot;string&quot;; 。并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量</span><br></code></pre></td></tr></table></figure><hr><h3 id="避免将异常定义为静态变量"><a href="#避免将异常定义为静态变量" class="headerlink" title="避免将异常定义为静态变量"></a>避免将异常定义为静态变量</h3><blockquote><p>当 Java 抛出一个异常时，JVM 会自动调用异常对象的 fillInStackTrace() 方法，记录当前的调用栈信息（包括类名、方法名、行号等）。每个异常实例的栈信息是抛出时的实时快照，且该信息会被存储在异常对象的 stackTrace 字段中<br>静态异常变量是共享实例，多次抛出时栈信息会被后续调用覆盖，导致调试时无法获取真实的异常发生位置。<br>解决方案：永远为每次异常抛出创建新的异常实例，确保每个异常对象携带独立的栈跟踪信息。<br>本质原则：异常是携带运行时上下文的 “事件对象”，应遵循 “按需创建，一事一议” 的设计，而非复用静态实例。</p></blockquote><hr><h3 id="Java中，写文件到磁盘中间经历了什么"><a href="#Java中，写文件到磁盘中间经历了什么" class="headerlink" title="Java中，写文件到磁盘中间经历了什么"></a>Java中，写文件到磁盘中间经历了什么</h3><hr><h3 id="Kafka-0拷贝-DMA拷贝"><a href="#Kafka-0拷贝-DMA拷贝" class="headerlink" title="Kafka 0拷贝 DMA拷贝"></a>Kafka 0拷贝 DMA拷贝</h3><hr><h3 id="http层到tcp层，中间传输数据经历了哪些过程"><a href="#http层到tcp层，中间传输数据经历了哪些过程" class="headerlink" title="http层到tcp层，中间传输数据经历了哪些过程"></a>http层到tcp层，中间传输数据经历了哪些过程</h3><hr><h3 id="get请求和post请求有什么区别"><a href="#get请求和post请求有什么区别" class="headerlink" title="get请求和post请求有什么区别"></a>get请求和post请求有什么区别</h3><hr><h3 id="怎么保证消息的顺序性"><a href="#怎么保证消息的顺序性" class="headerlink" title="怎么保证消息的顺序性"></a>怎么保证消息的顺序性</h3><hr><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><hr><h2 id="2025-5-13"><a href="#2025-5-13" class="headerlink" title="2025&#x2F;5&#x2F;13"></a>2025&#x2F;5&#x2F;13</h2><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><blockquote><p>异步、解耦、削峰</p></blockquote><hr><h3 id="Deque-和-Stack"><a href="#Deque-和-Stack" class="headerlink" title="Deque 和 Stack"></a>Deque 和 Stack</h3><hr><h3 id="https中的对称加密和非对称加密"><a href="#https中的对称加密和非对称加密" class="headerlink" title="https中的对称加密和非对称加密"></a>https中的对称加密和非对称加密</h3><hr><h3 id="stream和直接for循环的区别"><a href="#stream和直接for循环的区别" class="headerlink" title="stream和直接for循环的区别"></a>stream和直接for循环的区别</h3><hr><h2 id="2025-5-19"><a href="#2025-5-19" class="headerlink" title="2025&#x2F;5&#x2F;19"></a>2025&#x2F;5&#x2F;19</h2><h3 id="几种配置文件、配置文件的区别"><a href="#几种配置文件、配置文件的区别" class="headerlink" title="几种配置文件、配置文件的区别"></a>几种配置文件、配置文件的区别</h3><hr><h3 id="死锁为什么会导致cpu占用率升高"><a href="#死锁为什么会导致cpu占用率升高" class="headerlink" title="死锁为什么会导致cpu占用率升高"></a>死锁为什么会导致cpu占用率升高</h3><hr><h3 id="java中的线程和linux中的线程有什么区别"><a href="#java中的线程和linux中的线程有什么区别" class="headerlink" title="java中的线程和linux中的线程有什么区别"></a>java中的线程和linux中的线程有什么区别</h3><ul><li>java中的线程是通过调用系统api的方式去创建的，相当于java中的线程是抽象，linux底层是实现</li></ul><hr><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p><img src="/../../images/ThreadLocal%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt="ThreadLocal引用关系图"></p><blockquote><p>为什么ThreadLocalMap中的Entry将K设置为弱引用？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-built_in">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ul><li>private 方法是隐式的final</li><li>final方法是可以被重载的</li></ul><hr><h3 id="Dubbo-1"><a href="#Dubbo-1" class="headerlink" title="Dubbo"></a>Dubbo</h3><hr><h3 id="k8s到底是什么"><a href="#k8s到底是什么" class="headerlink" title="k8s到底是什么"></a>k8s到底是什么</h3><blockquote><p>介于应用服务和服务器之间，通过策略协调和管理多个应用服务，只需要通过一个yaml文件配置，定义应用的部署顺序等信息，就能自动部署应用到各个服务器上</p></blockquote><h4 id="control-plane-控制平面"><a href="#control-plane-控制平面" class="headerlink" title="control plane 控制平面"></a>control plane 控制平面</h4><ul><li>Api Service</li><li>Scheduler  Controller mgr</li><li>etcd</li></ul><h4 id="工作节点-node"><a href="#工作节点-node" class="headerlink" title="工作节点 node"></a>工作节点 node</h4><ul><li>kubelet 负责管理和监控node</li><li>kube proxy 负责node的网络通信</li></ul><h4 id="pod-k8s中最小的调度单位"><a href="#pod-k8s中最小的调度单位" class="headerlink" title="pod k8s中最小的调度单位"></a>pod k8s中最小的调度单位</h4><ul><li>container</li></ul><h4 id="cluster-集群"><a href="#cluster-集群" class="headerlink" title="cluster 集群"></a>cluster 集群</h4><ul><li>kubectl </li><li>怎么部署服务</li><li>怎么调用服务</li></ul><hr><h3 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h3><hr><h3 id="CDN（内容分发网络）"><a href="#CDN（内容分发网络）" class="headerlink" title="CDN（内容分发网络）"></a>CDN（内容分发网络）</h3><blockquote><p>CDN就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。</p></blockquote><hr><h3 id="Mysql-和-Mongo-db-有什么区别"><a href="#Mysql-和-Mongo-db-有什么区别" class="headerlink" title="Mysql 和 Mongo db 有什么区别"></a>Mysql 和 Mongo db 有什么区别</h3><ul><li>关系型数据库 文档型NoSQL数据库</li><li>Mongo 文档结构可随时变化</li></ul><hr><h3 id="rpc-远程过程调用"><a href="#rpc-远程过程调用" class="headerlink" title="rpc 远程过程调用"></a>rpc 远程过程调用</h3><blockquote><p>Remote procedure call </p></blockquote><hr><h3 id="tcp-粘包"><a href="#tcp-粘包" class="headerlink" title="tcp 粘包"></a>tcp 粘包</h3><hr><h3 id="应用层协议-http-rpc"><a href="#应用层协议-http-rpc" class="headerlink" title="应用层协议 http rpc"></a>应用层协议 http rpc</h3><ul><li>rpc不用考虑浏览器行为 302</li></ul><hr><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul><li>ArrayList 扩容后1.5倍</li><li>LinkedList</li><li>Vector 线程安全（Stack基于Vector，是栈，Vector是链表）</li></ul><blockquote><p>RandomAccess 标记接口，表示可以通过get(index)获取元素</p></blockquote><ul><li>快速失败 fail-fast 迭代器 </li><li>安全失败 fail-safe CopyOnWriteArrayList</li></ul><h3 id="Comparable和Comparator"><a href="#Comparable和Comparator" class="headerlink" title="Comparable和Comparator"></a>Comparable和Comparator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span> &lt;T&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T t)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparator</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(T t1 , T t2)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>HashSet</li><li>LinkedHashSet </li><li>TreeSet</li></ul><blockquote><p>HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。<br>HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。</p></blockquote><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><ul><li>ArrayDeque 与 LinkedList</li></ul><blockquote><p>ArrayDeque 是基于可变长的数组和头尾双指针来实现，因此不允许存null<br>而LinkedList </p></blockquote><ul><li>PriorityQueue</li></ul><blockquote><p>堆排序、求第 K 大的数、带权图的遍历等</p></blockquote><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li>HashMap 和 Hashtable 的区别，后者线程安全</li><li>TreeMap  排序</li></ul><blockquote><p>JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树</p></blockquote><blockquote><p>数组扩容能减少哈希冲突的发生概率（即将元素重新分散到新的、更大的数组中），这在多数情况下比直接转换为红黑树更高效。<br>红黑树需要保持自平衡，维护成本较高。并且，过早引入红黑树反而会增加复杂度。</p></blockquote><blockquote><p>泊松分布表明，链表长度达到 8 的概率极低（小于千万分之一）。在绝大多数情况下，链表长度都不会超过 8。阈值设置为 8，可以保证性能和空间效率的平衡。数组长度阈值 64 同样是经过实践验证的经验值。在小数组中扩容成本低，优先扩容可以避免过早引入红黑树。数组大小达到 64 时，冲突概率较高，此时红黑树的性能优势开始显现。</p></blockquote><hr><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul><li>synchronized 和 ReentrantLock 两者都是可重入锁</li><li>线程池中线程异常后，销毁还是复用？</li></ul><hr><h1 id="Dubbo-2"><a href="#Dubbo-2" class="headerlink" title="Dubbo"></a>Dubbo</h1><ul><li>protobuf</li><li>RPC和http的区别</li></ul><hr><h1 id="OOM排查"><a href="#OOM排查" class="headerlink" title="OOM排查"></a>OOM排查</h1><p>1.一次查询数据库内容太多<br>2.内存资源耗尽未释放</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看java进程</span><br>jps<br><span class="hljs-comment"># 查看存活对象</span><br>jmap -histo:live 进程<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><ul><li>提前设置JVM参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+HeapDumpOnOutOfMemoryErro -XX:HeapDumpPath=<br></code></pre></td></tr></table></figure><ul><li>运行中导出dump文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jmap -dump:format=b,file=xx.hprof 24068<br></code></pre></td></tr></table></figure><ul><li>分析dump文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.使用jhat xx.hprof文件，生成一个网页，但是不够具体</span><br>jhat xx.hprof<br></code></pre></td></tr></table></figure><blockquote><p>STW 的定义：在 JVM 开展垃圾回收工作时，会暂停所有应用线程的执行，此时整个应用就像被按下了暂停键，处于停滞状态，这一现象便是 STW</p></blockquote><hr><p>CPU飙升排查</p><p>1.top </p><p>​找到cpu使用最多进程的pid</p><p>2.top -H -p 进程id (不同环境命令不一样，有可能没有-p参数)</p><p>​找到cpu耗用最多的线程id</p><p>3.将线程id转换为16进制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;0x%x\n&#x27;</span> xxx<br></code></pre></td></tr></table></figure><p>4.jstack 进程pid | grep 16进制线程PID -A 20</p><h1 id="JVisualVM的使用"><a href="#JVisualVM的使用" class="headerlink" title="JVisualVM的使用"></a>JVisualVM的使用</h1><blockquote><p>下载地址 <a href="https://visualvm.github.io/index.html">VisualVM: Home</a></p></blockquote><ul><li>下载完成后，打开etc下的visualvm.conf，修改</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">visualvm_jdkhome=<span class="hljs-string">&quot;C:/Program Files/Java/jdk1.8.0_361&quot;</span><br></code></pre></td></tr></table></figure><ul><li>安装visual GC插件</li></ul><hr><h1 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h1><ul><li>随机法、两次随机法（多选出一个服务器，两台服务器根据负载情况选取）</li><li>轮询法、加权轮询法</li><li>哈希法，将ip通过哈希函数映射到服务器，同一个ip一定会跑到一个服务器</li><li>一致哈希法</li><li>最小连接</li><li>最少活跃</li><li>最快响应时间法</li></ul><hr><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><ul><li>Access Token 获取受保护资源，生命周期短</li><li>Refresh Token 获取Access Token，生命周期长</li></ul><p>Token</p><h1 id="job-worker模块之使用-power-job"><a href="#job-worker模块之使用-power-job" class="headerlink" title="job-worker模块之使用 power-job"></a>job-worker模块之使用 power-job</h1><blockquote><p>项目已经在mysql中有专门的数据库来提供给job-worker使用，同时，在job-worker中也指定了改数据库信息，并且以docker的方式部署到了服务器上。</p></blockquote><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h2><p>项目上使用的是com.github.kfcfans下的powerjob-worker-spring-boot-starter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>tech.powerjob<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>powerjob-worker-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><ul><li>feign中的configuration</li><li>事件框架</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CusEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApplicationEvent</span> <br><br><span class="hljs-comment">// 监听方法</span><br><span class="hljs-meta">@Async(&quot;指定线程池名称&quot;)</span><br><span class="hljs-meta">@EventListener</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(CusEvent cusEvent)</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// 推送消息</span><br>eventPublisher.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CusEvent</span>(xx));<br><br><span class="hljs-comment">// 指定时间框架线程池参数</span><br><span class="hljs-meta">@Bean(&quot;指定线程池名称&quot;)</span><br><span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">cusExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>    executor.setCorePoolSize(corePoolSize);<br>    executor.setMaxPoolSize(maxPoolSize);<br>    executor.setQueueCapacity(queueCapacity);<br>    executor.setThreadNamePrefix(DOMAIN_EXECUTOR);<br>    <span class="hljs-comment">// rejection-policy：当pool已经达到max size的时候，如何处理新任务</span><br>    <span class="hljs-comment">// ThreadPoolExecutor#DiscardPolicy：这个策略将会直接丢弃任务</span><br>    <span class="hljs-comment">// ThreadPoolExecutor#CallerRunsPolicy：不在新线程中执行任务，而是有调用者所在的线程来执行策略</span><br>    executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br>    executor.initialize();<br>    <span class="hljs-keyword">return</span> executor;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>自定义异常处理器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">restTemplate.setErrorHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplateResponseErrorHandler</span>());<br></code></pre></td></tr></table></figure><ul><li>内存溢出和内存泄漏</li><li>sql语句的执行过程</li><li>innodb和myism区别</li><li>回表的理解</li></ul><hr><ul><li>注解来统一处理接口耗时</li><li>流程授权的功能，在注解中进行了统一处理，替换session中的信息</li></ul><hr><ul><li>@Pointcut注解：统一定义切点表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.example.service..*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serviceLayer</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 在切入点表达式匹配的方法执行之前执行通知</span><br>    <span class="hljs-meta">@Before(&quot;serviceLayer()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logBefore</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Executing logBefore advice on serviceLayer()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="RequiredArgsConstructor"><a href="#RequiredArgsConstructor" class="headerlink" title="@RequiredArgsConstructor"></a>@RequiredArgsConstructor</h2><p>此注解常用于生成类的构造函数，当成员变量满足下面两个条件：</p><ul><li>final</li><li>未被初始化</li></ul><p>一般用在spring类上，当其生成构造函数后，spring会进行构造函数注入</p><h2 id="spring存在多个构造函数的情况"><a href="#spring存在多个构造函数的情况" class="headerlink" title="spring存在多个构造函数的情况"></a>spring存在多个构造函数的情况</h2><ul><li>某个构造函数上有@Autowired，使用此构造函数</li><li>多个构造函数，且都没有@Autowired<ul><li>存在无参构造函数，使用此构造函数</li><li>无参以及一个有参，使用有参</li><li>多个有参，无无参，抛异常</li></ul></li></ul><p>特殊情况：构造函数中某个bean存在多个候选对象，需要通过@Qualifier指定具体 Bean 名称，否则会报错。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2025/05/02/java/%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2025/05/02/java/%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新中</p></blockquote><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><blockquote><p>偶然间刷到了一个桶排序的视频，这次来实现下加深记忆</p></blockquote><p>​桶排序不是基于比较的排序算法，其效率取决于数据的分布特性，适用于数据均匀分布在某个范围内的场景（如浮点数、整数区间明确的数值数据）。其实现步骤如下：</p><ul><li>划分桶</li><li>桶内排序</li></ul><p>​值得注意的是，如何划分桶，以及数组元素定位到对应桶这两点。</p><p>方式一：</p><p>​假设桶的数量为bucketNum</p><p>​直接使用[max] - [min] &#x2F; bucketNum 确定桶的容量bucketCapacity</p><p>​数组元素进行桶定位的时候，使用当前元素item和数组内最小值的差值除以桶容量，此种情况下，会出现越界问题，必须使用Math.min进行一个辅助。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">bucketIndex</span> <span class="hljs-operator">=</span> Math.min((item - min) / bucketCapacity, bucketNum - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>​为什么会出现越界？比如 8 &#x2F; 3 ，向下取整的到的结果是 2，这里2对应的就是桶的容量，8对应的就是最大元素和最小元素的差值，3代表桶的数量，此时，使用(item - min) &#x2F; bucketCapacity，当item为最大元素时，会变成 8 &#x2F; 2，结果为4，会产生数组越界，现在我们抽象下这个问题</p><ul><li><p>[最大差值] &#x2F; [桶的数量] 向下取整  [桶的容量]</p></li><li><p>[桶的数量] * [桶的容量] &lt;&#x3D; [最大差值]</p></li></ul><p>最坏的情况下， [桶的容量] * [桶的数量] &#x3D; [最大差值] - （[桶的数量] - 1）</p><p>假设  [桶的容量]  &lt;&#x3D; （[桶的数量] - 1），此时会产生越界</p><p>方式二：</p><p>​(item - min) * bucketNum &#x2F; (max - min + 1) 非常巧妙的方式</p><ul><li>​(item - min)  &lt;  (max - min + 1)</li><li>​    (item - min)  * bucketNum &lt;   (max - min + 1) * bucketNum </li><li>(item - min) * bucketNum &#x2F; (max - min + 1) &lt; bucketNum</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> bucketSort(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-type">int</span> bucketNum = <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> min = ArrayUtils.min(arr);<br>        <span class="hljs-type">int</span> max = ArrayUtils.max(arr);<br>//        <span class="hljs-type">int</span> bucketCapacity = (max - min) / bucketNum;<br><br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; bucketList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketNum; i++) &#123;<br>            bucketList.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> item : arr) &#123;<br>//            <span class="hljs-type">int</span> bucketIndex = Math.min((item - min) / bucketCapacity, bucketNum - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> bucketIndex = (item - min) * bucketNum / (max - min + <span class="hljs-number">1</span>);<br>            bucketList.<span class="hljs-keyword">get</span>(bucketIndex).<span class="hljs-keyword">add</span>(item);<br>        &#125;<br><br>        <span class="hljs-type">int</span> indexGap = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketNum; i++) &#123;<br>            List&lt;<span class="hljs-type">Integer</span>&gt; bucket = bucketList.<span class="hljs-keyword">get</span>(i);<br>            <span class="hljs-type">int</span>[] <span class="hljs-keyword">array</span> = bucket.stream().mapToInt(<span class="hljs-type">Integer</span>::intValue).toArray();<br>            selectionSort(<span class="hljs-keyword">array</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">array</span>.length; j++) &#123;<br>                arr[j + indexGap] = <span class="hljs-keyword">array</span>[j];<br>            &#125;<br>            indexGap += <span class="hljs-keyword">array</span>.length;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阻塞队列</title>
    <link href="/2025/05/02/java/%E5%9F%BA%E7%A1%80/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <url>/2025/05/02/java/%E5%9F%BA%E7%A1%80/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新中</p></blockquote><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>​BlockingQueue是一个接口，它属于 Java 并发包java.util.concurrent，其用途是在多线程环境下实现线程安全的队列操作。</p><ul><li>线程安全：BlockingQueue自身实现了线程安全，多个线程能够同时对队列进行读写操作，无需额外的同步机制。</li><li>阻塞操作：定义了若干阻塞方法，当队列满时进行入队操作，或者队列空时进行出队操作，这些方法会让线程进入阻塞状态，直至满足操作条件。</li><li>容量限制：部分BlockingQueue的实现类具备容量限制，当队列达到最大容量时，再进行入队操作会被阻塞。</li></ul><h5 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h5><ul><li>add(E e)：若队列未满，将元素插入队列尾部，成功则返回true；若队列已满，会抛出IllegalStateException异常。</li><li>offer(E e)：若队列未满，将元素插入队列尾部，成功则返回true；若队列已满，返回false。</li><li>offer(E e, long timeout, TimeUnit unit)：在指定时间内尝试将元素插入队列尾部，若成功则返回true；若超时仍未成功，返回false。</li><li>put(E e)：若队列未满，将元素插入队列尾部；若队列已满，线程会阻塞直至队列有空间。</li></ul><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><ul><li>remove()：若队列不为空，移除并返回队列头部元素；若队列为空，抛出NoSuchElementException异常。</li><li>poll()：若队列不为空，移除并返回队列头部元素；若队列为空，返回null。</li><li>poll(long timeout, TimeUnit unit)：在指定时间内尝试移除并返回队列头部元素，若成功则返回元素；若超时仍未成功，返回null。</li><li>take()：若队列不为空，移除并返回队列头部元素；若队列为空，线程会阻塞直至队列中有元素。</li></ul><h5 id="检查元素"><a href="#检查元素" class="headerlink" title="检查元素"></a>检查元素</h5><ul><li>element()：若队列不为空，返回队列头部元素，但不移除；若队列为空，抛出NoSuchElementException异常。</li><li>peek()：若队列不为空，返回队列头部元素，但不移除；若队列为空，返回null。</li></ul><h5 id="常见实现类"><a href="#常见实现类" class="headerlink" title="常见实现类"></a>常见实现类</h5><ul><li>ArrayBlockingQueue：基于数组实现的有界阻塞队列，在创建时需指定容量，且可选择是否使用公平锁。</li><li>LinkedBlockingQueue：基于链表实现的阻塞队列，可指定容量，若不指定则默认为Integer.MAX_VALUE，被视为无界队列。</li><li>PriorityBlockingQueue：基于优先级堆实现的无界阻塞队列，队列中的元素会按照自然顺序或者指定的比较器进行排序。</li><li>SynchronousQueue：一种特殊的阻塞队列，它不存储元素，每个插入操作必须等待另一个线程的移除操作，反之亦然。</li></ul><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ArrayBlockingQueue;<br><span class="hljs-keyword">import</span> java.util.concurrent.BlockingQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueueExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 生产者线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    queue.put(i);<br>                    System.out.println(<span class="hljs-string">&quot;Produced: &quot;</span> + i);<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 消费者线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> queue.take();<br>                    System.out.println(<span class="hljs-string">&quot;Consumed: &quot;</span> + item);<br>                    Thread.sleep(<span class="hljs-number">200</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;);<br><br>        producer.start();<br>        consumer.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            producer.join();<br>            consumer.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis篇</title>
    <link href="/2025/05/01/java/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"/>
    <url>/2025/05/01/java/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/</url>
    
    <content type="html"><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>缓存</li><li>分布式锁</li><li>消息队列、延时队列</li><li>…</li></ul><p>ps：结合项目业务回答</p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>redis单线程为什么还执行那么快？</p><ul><li><p>纯内存操作，执行速度快</p></li><li><p>采用单线程，避免不必要的上下文切换可竞争条件，无需考虑线程安全问题，大key慢，scan等问题…</p></li><li><p>使用I&#x2F;O多路复用模型，非阻塞io</p><p>其瓶颈主要是网络延迟而不是执行速度</p></li></ul><h5 id="内核空间和用户空间"><a href="#内核空间和用户空间" class="headerlink" title="内核空间和用户空间"></a>内核空间和用户空间</h5><ul><li><p>用户空间：只能执行受限的命令(Ring3)，而不能直接调用系统资源，必须提供内核提供的接口来访问</p></li><li><p>内核空间：可以执行特权命令(Ring0)，调用系统资源</p><p>linux为了提高IO效率，会在二者都加入缓冲区</p><ul><li>写数据时，要把用户数据从用户缓冲区拷贝到内核缓冲区，然后写入设备</li><li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li></ul><p>想办法减少无效等待和频繁拷贝，recvfrom：从内核获取数据</p><ul><li>非阻塞io，recvfrom会立即返回结果而不是阻塞用户进程，但是会频繁访问，忙等，耗费cpu，直到数据就绪，但是数据就绪后，拷贝数据到用户空间的过程还是阻塞的。</li><li>io多路复用：单个线程同时兼容多个socket，使用select函数，监听多个socker，当内核数据就绪时，触发回调，客户端处理数据。</li><li>select、poll、epoll：前面二者只会通知用户进程有socker就绪，但不确定具体是哪个socker，需要用户进程逐个遍历，epoll会在 通知用户进程socker就绪的同时，把已就绪的socker写入用户空间</li></ul></li></ul><h5 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1.缓存穿透"></a>1.缓存穿透</h5><p>​查询<strong>不存在的数据</strong>，每次请求都会落到数据库，每次都查不到结果，redis不会缓存。</p><ul><li><p>缓存空数据，查不到结果，仍把空数据进行缓存</p><p>简单，但消耗内存，有可能会存在数据库不一致的问题。</p></li><li><p>布隆过滤器</p><ul><li>在查询redis缓存前，在<strong>前面加了一层</strong>布隆过滤器，如果布隆过滤器中，不存在，直接返回，存在在继续往下走</li><li>缓存预热时，预热布隆过滤器</li><li>基于bitmap实现<ul><li>存数据时，对key进行<strong>多次hash</strong>计算获取hash值，根据这一个个值，将数组对应位置改为1</li><li>查数据时，使用<strong>相同hash</strong>函数获取hash值，判断对应位置是否为1，都是1表示存在</li><li>有可能会存在误判，某个key hash后的值与存在的多个key的hash后的值重合，数组越小误判率越大，越大误判率越小。 </li><li>redisson和guava都实现了布隆过滤器，其可以设置误判率</li></ul></li></ul></li></ul><h5 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2.缓存击穿"></a>2.缓存击穿</h5><p>​某个时间点某个key突然有大量的并发过来，而且此时在redis中这个数据没有缓存(也许是到期了)，在第一次将数据库返回写入缓存这个过程中，其余大量请求直接到数据库可能会把数据库压垮。</p><ul><li>添加互斥锁（强一致性、性能差）<ul><li>第一次查询缓存未命中，在查询数据库之前，先要获取锁</li></ul></li><li>逻辑过期（高可用）<ul><li>不设置过期时间</li><li>查询缓存未命中，获取锁，新开了一个线程更新缓存，然后返回过期数据</li></ul></li></ul><h5 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3.缓存雪崩"></a>3.缓存雪崩</h5><p>​同一时段内，大量的缓存key同时失效或者redis服务宕机，大量请求到达数据库</p><ul><li><p>给不同的key设置不同的过期时间</p></li><li><p>利用redis集群提高服务的可用性</p></li><li><p>给缓存业务添加降级限流策略 nginx 网关限制</p></li><li><p>添加多级缓存 Guava或者Caffeine</p></li></ul><h5 id="4-mysql和redis数据同步，双写一致性"><a href="#4-mysql和redis数据同步，双写一致性" class="headerlink" title="4.mysql和redis数据同步，双写一致性"></a>4.mysql和redis数据同步，双写一致性</h5><p>​修改了数据库的数据，也要同时更新缓存的数据，缓存和数据库的数据要保持一致。</p><ul><li><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存</p></li><li><p>写操作：延迟双删</p><p>删除缓存——&gt;修改数据库——&gt;延时删除缓存</p><p>传统方案：</p><ul><li>先删除缓存，在修改数据库：在删除缓存和更新数据库之间，又来了一个线程，查询缓存查询数据库，写入旧的数据到了缓存。</li><li>先操作数据库，再删除缓存：在更新数据库之前，先前有一个线程，查询缓存查不到，查数据库、更新缓存，这个线程更新缓存的操作在当前线程删除缓存之后。</li></ul><p>为什么要延时？</p><p>mysql一般都是主从的，主节点同步到从节点也需要时间。</p></li><li><p>一般放入缓存中的数据都是读多写少，可以使用读写锁</p></li><li><p>异步通知保证数据的最终一致性，写入到数据库后，发布消息到mq去更新缓存</p></li><li><p>使用canal，写入到数据库后，canal会监听mysql的binlog，变更时通知缓存服务更新缓存</p></li></ul><h5 id="5-redis的持久化"><a href="#5-redis的持久化" class="headerlink" title="5.redis的持久化"></a>5.redis的持久化</h5><ul><li><p>RDB</p><p>把内存中的所有数据都记录到磁盘中，当redis实例故障重启后，从磁盘读取快照文件，恢复数据</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">save</span> <span class="hljs-meta">#redis主进程执行rdb，会阻塞所有命令</span><br>bgsave <span class="hljs-meta">#开启子进程执行rdb，避免主进程受到影响</span><br></code></pre></td></tr></table></figure><p>redis内部有触发RDB的机制，可以在redis.conf中找到，格式为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 900s内，如果至少有一个key被修改，则执行bgsave</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>bgsave开始时会fork主进程得到子进程，复制页表到子线程，对实际指向内存中的物理地址写入到rdb文件中放到磁盘。</p><p>假如这期间，主进程在修改数据，fork采用的是copy-on-write技术，当主进程在写的时候，会拷贝一份数据，执行写操作。</p><p>页表：记录虚拟地址和物理地址的映射关系</p></li><li><p>AOF（append only file）</p><p>redis处理的每一个写命令都会记录在aof文件中，可以看作是命令日志文件</p><ul><li><p>aof默认是关闭的，需要修改redis.conf配置文件来开启aof</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 是否开启aof 默认是no</span><br><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span><br><span class="hljs-comment"># aof文件的名称</span><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>频率，刷盘策略</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appendfsync</span> always <span class="hljs-comment"># 立即记录到aof文件，性能影响大</span><br>appendfsync everysec <span class="hljs-comment"># 写完后放入aof缓冲区，每隔1秒将缓冲区数据写到aof，默认方案，最多丢失1s数据</span><br>appendfsync <span class="hljs-literal">no</span> <span class="hljs-comment">#写入aof缓冲区，由操作系统决定何时写回磁盘</span><br></code></pre></td></tr></table></figure></li><li><p>存在问题：</p><ul><li><p>记录命令，文件大</p></li><li><p>记录多次写操作，只有最后一次写才有意义，可以使用bgrewriteaof执行重写，用最少的命令达到相同的效果</p></li><li><p>配置</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">auto</span>-aof-rewrite-percentage <span class="hljs-number">100</span> <span class="hljs-meta"># aof比上次文件增长超过多少百分比触发重写</span><br><span class="hljs-keyword">auto</span>-aof-rewrite-min-size <span class="hljs-number">64</span>mb <span class="hljs-meta"># aof文件体积最小多少大以上触发重写</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>对比</p><p>aof相对完整，取决于刷盘策略</p><p>aof数据恢复优先级高，因为其数据完整性更高</p></li></ul><p>​恢复速度rdb更快</p><p>​rdb耗费性能高，大量cpu和内存消耗</p><p>​aof追加命令，主要占用的是磁盘io资源，但aof重写的时候会占用大量的cpu和内存资源。</p><h5 id="6-数据过期策略"><a href="#6-数据过期策略" class="headerlink" title="6.数据过期策略"></a>6.数据过期策略</h5><ul><li>惰性删除：设置过期时间后，过期不会主动删除，当需要该key的时候，检查是否过期，过期就删掉，反之返回。<ul><li>对cpu友好，不用进行过期检查</li><li>内存中不会释放，占用内存</li></ul></li><li>定期删除：每隔一段时间，对key进行检查，删除过期的key（检查：从一定数量的数据库中取出一定数量的随机key进行检查）<ul><li>slow模式：定时任务，频率为10hz（每秒执行10次，即执行周期是100ms），每次不超过25ms，通过修改配置文件redis.conf的hz选项来调整</li><li>fast模式，执行频率不固定，但两次间隔不低于2ms，每次执行耗时不超过1ms</li><li>优点：有效释放了过期数据占用的内存，同时，其可以以限制执行时长和频率来减少删除操作对cpu的影响</li><li>缺点：执行时长和频率不好确定</li></ul></li></ul><p>​redis过期策略是两者结合使用</p><h5 id="7-数据淘汰策略"><a href="#7-数据淘汰策略" class="headerlink" title="7.数据淘汰策略"></a>7.数据淘汰策略</h5><p>​内存被占用满了怎么办？</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">maxmemory-<span class="hljs-keyword">policy</span> noeviction<br></code></pre></td></tr></table></figure><ul><li><p>noeviction：不会淘汰任何key，内存满了不允许写入新数据，默认</p></li><li><p>volatile-ttl：对设置了ttl的key，比较剩余ttl，ttl越小先被淘汰</p></li><li><p>allkeys-random：对全体key，随机进行淘汰</p></li><li><p>volatile-random：对设置了ttl的key，随机进行淘汰</p></li><li><p>allkeys-lru：对全体key，使用lru，最近最少使用</p></li><li><p>volatile-lru：对设置了ttl的key，使用lru，最近最少使用</p></li><li><p>allkeys-lfu：对全体key，使用lru，最近最少频率使用</p></li><li><p>volatile-lfu：对设置了ttl的key，使用lfu，最近最少使用</p></li></ul><p>优先使用lru，实际使用中，lfu不一定比lru实用，某一个key，一段时间内访问频率高，另外一段时间内访问频率不一定高</p><p>有置顶的需求，可以使用volatile-lru，同时置顶数据不设置过期时间</p><p>有短时高频访问的数据，使用lfu</p><h5 id="8-redis分布式锁"><a href="#8-redis分布式锁" class="headerlink" title="8.redis分布式锁"></a>8.redis分布式锁</h5><p>​setnx，有效时长，lua脚本</p><p>​redlock红锁：不能只在一个reids实例上创建锁，应该是在多个redis实例上创建锁(n&#x2F;2 +1)，实现复杂，性能差，运维繁琐。</p><p>​redis是ap思想，高可用</p><p>​如果要保证强一致性可以使用zookeeper，cp思想</p><h5 id="9-集群"><a href="#9-集群" class="headerlink" title="9.集群"></a>9.集群</h5><ul><li><p>主从：读写分离，主写，从读，解决高并发</p><ul><li><p>全量同步</p><table><thead><tr><th>主</th><th>从</th></tr></thead><tbody><tr><td></td><td>执行replicaof命令</td></tr><tr><td></td><td>请求数据同步，将自己的replid、offset发送</td></tr><tr><td>拿replid和自己判断，判断是否第一次同步</td><td></td></tr><tr><td>是第一次，返回master数据版本信息repliid、offset，第二次，就会直接发送repl_baklog给从</td><td></td></tr><tr><td></td><td>保存版本信息</td></tr><tr><td>执行bgsave，生成rdb，发送rdb到从</td><td></td></tr><tr><td></td><td>清空本地文件，加载rdb文件</td></tr><tr><td>记录rdb期间的所有命令到repl_baklog中,发送给从</td><td></td></tr><tr><td></td><td>执行repl_baklog</td></tr></tbody></table></li><li><p>增量同步，slave重启或后期数据变化</p><p>即上面的表格中第二次部分，从repl_baklog发送offset后的命令到从</p></li></ul></li><li><p>哨兵（sentinel）：实现主从集群的自动故障恢复，解决高可用</p><ul><li>sentinel会不断检查主从是否按照预期工作</li><li>自动故障恢复：master故障后，sentinel会将一个slave提升为master，故障实例恢复后也以新的master为主</li><li>通知：sentinel充当redis客户端的服务发现来源，集群发生故障转移时，会将最新的信息推送给redis客户端</li></ul><p>其基于心跳机制检测服务状态，每隔1s向集群的每个实例发送ping命令：</p><ul><li>主观下线：如果某个实例未在规定时间内响应，主观下线</li><li>客观下线，超过指定数量的sentinel都认为该实例主观下线，则该实例客观下线，指定数量quorum值最好超过sentinel的一半。</li></ul><p>选主规则</p><ul><li>判断主节点和从节点断开时间长短，断开时间太长了就代表数据旧</li><li>判断从节点的slave-priority值，越小优先级越高</li><li>如果slave-priority一样，则判断slave的offset值，越大优先级越高</li><li>判断slave节点的运行id大小，越小优先级越高</li></ul><p>脑裂</p><ul><li><p>主节点网络和sentinel分区了，sentinel选出了新的主，同时客户端也在往旧的主节点写数据，当主节点网络和sentinel恢复到一个分区后，会把旧的主节点当成从节点，此时数据丢失</p></li><li><p>解决</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-replicas-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 表示主节点最少的salve节点为1个，否则拒绝请求</span><br><span class="hljs-built_in">min</span>-replicas-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">5</span> <span class="hljs-comment"># 表示数据复制和同步的延迟不超过5s，否则拒绝客户端连接</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>分片集群，解决海量数据存储以及高并发写的问题</p><ul><li>集群中有多个master，每个master保存不同内存</li><li>每个master都可以有多个slave节点</li><li>master之间通过ping检测彼此健康状态，这样就不要哨兵了</li><li>客户端可以访问集群任意节点，最终都会被转发到正确节点</li></ul><p>hash槽，redis集群中有16384个hash槽，每个key通过CRC16校验后对16384取模来决定防止哪个槽，集群的每个节点负责一部分hash槽。</p><p>可以使用set[aaa] name value 指定取模来源，redis会根据aaa来进行取模，而不是name了。</p></li></ul><h5 id="redis集群如何扛住百万级别的热点key的访问"><a href="#redis集群如何扛住百万级别的热点key的访问" class="headerlink" title="redis集群如何扛住百万级别的热点key的访问"></a>redis集群如何扛住百万级别的热点key的访问</h5><p>redis单片的写入瓶颈在2万左右，读瓶颈在10w左右</p><ul><li><p>对热点key进行拆分成几个小key</p><p>如何保证各个key在不同节点上，CRC16插槽</p></li></ul><h5 id="基于list结构模拟消息队列"><a href="#基于list结构模拟消息队列" class="headerlink" title="基于list结构模拟消息队列"></a>基于list结构模拟消息队列</h5><ul><li>生产者使用LPUSH向redis队列中存入一条数据</li><li>消费者使用RPOP后进先出、LPOP先进先出、BRPOP、BLPOP</li></ul><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"># 向列表 mylist 中依次添加元素 a、b、c<br><span class="hljs-number">127.0.0.1:6379</span>&gt; RPUSH mylist a b c<br>(integer) <span class="hljs-number">3</span><br><br># 使用 RPOP 从列表右侧（尾部）移除并返回元素<br><span class="hljs-number">127.0.0.1:6379</span>&gt; RPOP mylist<br><span class="hljs-string">&quot;c&quot;</span><br><br># 此时列表中剩余元素为 a、b<br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE mylist <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;b&quot;</span><br><br># 使用 LPOP 从列表左侧（头部）移除并返回元素<br><span class="hljs-number">127.0.0.1:6379</span>&gt; LPOP mylist<br><span class="hljs-string">&quot;a&quot;</span><br><br># 此时列表中剩余元素为 b<br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE mylist <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;b&quot;</span><br></code></pre></td></tr></table></figure><h5 id="基于Pubsub的消息队列"><a href="#基于Pubsub的消息队列" class="headerlink" title="基于Pubsub的消息队列"></a>基于Pubsub的消息队列</h5><p>​消费者可以订阅一个或多个channel，生产者向对应的channel发送消息后，所有的订阅者都能收到相关消息。</p><ul><li>SUBSCRIBE xxx.q1</li><li>PUBLISH xxx.q1</li></ul><h5 id="Stream的消息队列"><a href="#Stream的消息队列" class="headerlink" title="Stream的消息队列"></a>Stream的消息队列</h5><p>​redis5.0后引入的新的数据类型，可以实现功能完善的消息队列。</p><h5 id="feed流"><a href="#feed流" class="headerlink" title="feed流"></a>feed流</h5><ul><li>拉模式：读扩散，数据存储在来源方，每次都查询</li><li>推模式：写扩散，数据推送到接收方，假如有多个接收方，就会存储多份，延迟低，但是内存占用高</li><li>推拉结合模式：读写混合，假如接收方比较少，就写扩散，或者有几个活跃的接收方，就使用这种模式，而那些僵尸粉，就使用拉模式。</li></ul><h5 id="GEO数据结构"><a href="#GEO数据结构" class="headerlink" title="GEO数据结构"></a>GEO数据结构</h5><p>3.2版本后，加入了对GEO的支持，允许存储地理坐标信息，经度、纬度、值。</p><h5 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h5><p>​redis是利用string数据类型实现的bitmap，最大上限是512M</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"># 给<span class="hljs-keyword">key</span>上dayOfMonth - <span class="hljs-number">1</span>索引的值置为<span class="hljs-literal">true</span><br>stringRedisTemplate.opsForValue().setBit(<span class="hljs-keyword">key</span>, dayOfMonth - <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br><br># 查询从第<span class="hljs-number">0</span>个索引到dayOfMonth索引的值<br>List&lt;<span class="hljs-type">Long</span>&gt; longs = stringRedisTemplate.opsForValue().bitField(<br>                <span class="hljs-keyword">key</span>,<br>              BitFieldSubCommands.create().<span class="hljs-keyword">get</span>(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="hljs-number">0</span>)<br>        );<br></code></pre></td></tr></table></figure><h5 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h5><ul><li>UV：unique visitor 独立访客量，一天内同一个用户多次访问，只记录一次</li><li>PV：page view，页面访问量或点击量，用户访问网站的一个页面，记录一次PV，用户多次打开页面，则记录多次PV。</li></ul><p>底层也是基于基于string实现的，单个HLL的内存永远小于16kb，其测量结果是概率性的，有小于0.81%的误差，对于UV来说，完全可以忽略。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">info</span> memory <span class="hljs-comment"># 查看redis内存值</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql篇</title>
    <link href="/2025/05/01/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    <url>/2025/05/01/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/</url>
    
    <content type="html"><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h5 id="查看数据库版本"><a href="#查看数据库版本" class="headerlink" title="查看数据库版本"></a>查看数据库版本</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> VERSION();<br></code></pre></td></tr></table></figure><h5 id="修改数据库最大连接数以及单个连接过期时间"><a href="#修改数据库最大连接数以及单个连接过期时间" class="headerlink" title="修改数据库最大连接数以及单个连接过期时间"></a>修改数据库最大连接数以及单个连接过期时间</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--修改数据库最大连接数以及单个连接过期时间</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> max_connections<span class="hljs-operator">=</span><span class="hljs-number">10000</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> interactive_timeout<span class="hljs-operator">=</span><span class="hljs-number">60</span><br><br><span class="hljs-comment">--查看、确认</span><br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;max_connections&#x27;</span>;<br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;interactive_timeout&#x27;</span>;<br><br><span class="hljs-comment">-- 查看当前连接数详情</span><br><span class="hljs-keyword">SHOW</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Threads%&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="优化器跟踪-OPTIMIZER-TRACE"><a href="#优化器跟踪-OPTIMIZER-TRACE" class="headerlink" title="优化器跟踪 OPTIMIZER_TRACE"></a>优化器跟踪 OPTIMIZER_TRACE</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-- 开启 OPTIMIZER_TRACE<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">optimizer_trace</span>=<span class="hljs-string">&quot;enabled=on&quot;</span>, <span class="hljs-attribute">optimizer_trace_max_mem_size</span>=1000000;<br><br>-- 执行需要分析的查询<br><br>-- 查看 OPTIMIZER_TRACE 信息<br>SELECT * <span class="hljs-keyword">FROM</span> information_schema.OPTIMIZER_TRACE;<br><br>-- 关闭 OPTIMIZER_TRACE<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">optimizer_trace</span>=<span class="hljs-string">&quot;enabled=off&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="杀掉那些当前处于“Sleep”状态的连接"><a href="#杀掉那些当前处于“Sleep”状态的连接" class="headerlink" title="杀掉那些当前处于“Sleep”状态的连接"></a>杀掉那些当前处于“Sleep”状态的连接</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;kill &#x27;</span>,id,<span class="hljs-string">&#x27;;&#x27;</span>) <span class="hljs-keyword">from</span> information_schema.`PROCESSLIST` <span class="hljs-keyword">where</span> command<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Sleep&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="命令行下的操作"><a href="#命令行下的操作" class="headerlink" title="命令行下的操作"></a>命令行下的操作</h5><ul><li>进入mysql</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>u apaas <span class="hljs-operator">-</span>p<br></code></pre></td></tr></table></figure><ul><li>查看&#x2F;使用数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES;<br>USE 数据库名;<br></code></pre></td></tr></table></figure><h5 id="修改结构"><a href="#修改结构" class="headerlink" title="修改结构"></a>修改结构</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DESCRIBE</span> 表名;<br><span class="hljs-keyword">ALTER TABLE</span> apaas_app_access<br>MODIFY <span class="hljs-keyword">COLUMN</span> object_id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><h5 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h5><ul><li>根据某张表的某些字段更新另外一张表</li></ul><p>（通过 <code>INSERT INTO ... SELECT</code> 语法，实现从源表<code>sy_property</code>查询数据，并将结果插入到目标表<code>sy_property_copy</code>中，本质是数据复制操作。）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> sy_property_copy (apply_number, document_id, form_id, tenant_id, id)<br><span class="hljs-keyword">SELECT</span> exit_ware_num, document_id, form_id,tenant_id, id<br><span class="hljs-keyword">FROM</span> sy_property<br><span class="hljs-keyword">WHERE</span> exit_ware_num <span class="hljs-keyword">is</span> <span class="hljs-keyword">not NULL</span>;<br></code></pre></td></tr></table></figure><h5 id="查询mysql对应账号的密码"><a href="#查询mysql对应账号的密码" class="headerlink" title="查询mysql对应账号的密码"></a>查询mysql对应账号的密码</h5><ul><li>此方法查出的为加密后的密码</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">user</span>, host, authentication_string <span class="hljs-keyword">FROM</span> mysql.user <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;your_username&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="字符集相关"><a href="#字符集相关" class="headerlink" title="字符集相关"></a>字符集相关</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// 展示数据库数据集<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">where</span> variable_name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%collation%&#x27;</span>;<br><br>// 设置数据库数据集<br><span class="hljs-keyword">SET</span> collation_connection = <span class="hljs-string">&#x27;utf8mb4_general_ci&#x27;</span>;<br><br>// 展示创建表语句<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> lzc1;<br><br>// 展示视图数据集<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">view</span> view_test_1;<br><br>// 展示表/视图所有列信息<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">full</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">from</span> v_crm_disty_projects;<br></code></pre></td></tr></table></figure><h3 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h3><h5 id="正则表达式-‘？-’"><a href="#正则表达式-‘？-’" class="headerlink" title="正则表达式  ‘？:’"></a>正则表达式  ‘？:’</h5><p>例如下面的代码，mysql5.0不支持</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> supplier_first_battalion_x <span class="hljs-keyword">where</span> supplier_first_battalion_x.BUKRS_X RLIKE <span class="hljs-string">&#x27;\b(?:1000|&quot;|,|\[|\])\b&#x27;</span>;<br></code></pre></td></tr></table></figure><p>可以使用以下方式替换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> supplier_first_battalion_x <span class="hljs-keyword">where</span> supplier_first_battalion_x.BUKRS_X RLIKE <span class="hljs-string">&#x27;^(&quot;|,|\[|\])*(1000)(&quot;|,|\[|\])*$&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"># 查看有没有开启binlog<br>SHOW VARIABLES LIKE <span class="hljs-string">&#x27;log_bin&#x27;</span>;<br># 查看所有binlog<br>SHOW BINARY LOGS;<br># 查看binlog对应的存储位置<br>SHOW VARIABLES LIKE <span class="hljs-string">&#x27;log_bin_basename&#x27;</span>;<br>## 查看binlog格式<br>SHOW VARIABLES LIKE <span class="hljs-string">&#x27;binlog_format&#x27;</span>;    <br><br>## 查看删除语句，使用 -vv解析row格式<br>mysqlbinlog --no-defaults -vv --base64-output=decode-rows binlog<span class="hljs-number">.000003</span> | grep -A <span class="hljs-number">20</span> -B <span class="hljs-number">1</span> <span class="hljs-string">&quot;apaas_datasource&quot;</span> | grep <span class="hljs-string">&quot;DELETE&quot;</span> -B <span class="hljs-number">1</span> -A <span class="hljs-number">20</span><br><br>--no-defaults：忽略默认配置文件，避免权限问题<br>--database：指定数据库名，过滤无关操作<br>--start-datetime / --stop-datetime：限定时间范围    <br>    <br># 找出某个时间点内的日志 <br>mysqlbinlog --no-defaults --base64-output=decode-rows binlog<span class="hljs-number">.000009</span> --start-datetime=<span class="hljs-string">&quot;2024-08-01 01:06:00&quot;</span> --stop-datetime=<span class="hljs-string">&quot;2024-08-04 23:12:20&quot;</span>  --base64-output=DECODE-ROWS --verbose | grep <span class="hljs-string">&quot;building_specialty_store&quot;</span> | grep <span class="hljs-string">&quot;DELETE&quot;</span><br><br>mysqlbinlog --no-defaults --base64-output=decode-rows binlog<span class="hljs-number">.000008</span> --start-datetime=<span class="hljs-string">&quot;2024-08-01 01:06:00&quot;</span> --stop-datetime=<span class="hljs-string">&quot;2025-08-04 23:12:20&quot;</span>  --base64-output=DECODE-ROWS --verbose | grep <span class="hljs-string">&quot;dept&quot;</span> | grep <span class="hljs-string">&quot;DELETE&quot;</span><br><br>mysqlbinlog --no-defaults --start-position=<span class="hljs-number">8019910</span> --stop-position=<span class="hljs-number">8019921</span> binlog<span class="hljs-number">.000456</span>  --base64-output=DECODE-ROWS --verbose<br>mysqlbinlog --no-defaults --base64-output=decode-rows binlog<span class="hljs-number">.000004</span> --start-datetime=<span class="hljs-string">&quot;2024-08-01 01:06:00&quot;</span> --stop-datetime=<span class="hljs-string">&quot;2024-09-04 23:12:20&quot;</span> --base64-output=DECODE-ROWS --verbose | grep <span class="hljs-string">&quot;building_specialty_store&quot;</span> | grep <span class="hljs-string">&quot;DELETE&quot;</span> | grep -v <span class="hljs-string">&quot;button&quot;</span> | grep -v <span class="hljs-string">&quot;color&quot;</span><br>    <br>    <br><br>   <br><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> <span class="hljs-string">&#x27;725058905100517377app&#x27;</span>;<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> xdap_manage_database.xdap_password_history <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;725058905100517377app&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> `<span class="hljs-keyword">User</span>` <span class="hljs-keyword">from</span> mysql.<span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> `<span class="hljs-keyword">User</span>` <span class="hljs-keyword">like</span> &quot;%app&quot; <span class="hljs-keyword">and</span> `<span class="hljs-keyword">User</span>` <span class="hljs-keyword">not</span> <span class="hljs-keyword">like</span> &quot;%acti%&quot;;<br><br><br><span class="hljs-keyword">SELECT</span> CONCAT(<span class="hljs-string">&#x27;GRANT SELECT ON xdap_manage_database.xdap_password_history TO &#x27;</span>, <span class="hljs-string">&#x27;\&#x27;&#x27;,`User`, &#x27;</span>\<span class="hljs-string">&#x27;;&#x27;</span>) <br><span class="hljs-keyword">FROM</span> mysql.<span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> `<span class="hljs-keyword">User</span>` <span class="hljs-keyword">like</span> &quot;%app&quot; <span class="hljs-keyword">and</span> `<span class="hljs-keyword">User</span>` <span class="hljs-keyword">not</span> <span class="hljs-keyword">like</span> &quot;%acti%&quot;;<br><br><br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> xdap_manage_database.xdap_password_history <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;725058905100517377app&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="使用记录"><a href="#使用记录" class="headerlink" title="使用记录"></a>使用记录</h3><h5 id="如何定位慢查询"><a href="#如何定位慢查询" class="headerlink" title="如何定位慢查询"></a>如何定位慢查询</h5><ul><li>mysql慢日志</li><li>压力测试的时候可以看接口耗时，运维工具</li></ul><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>MySQL的默认存储引擎InnoDB使用的是B+树作为索引的存储结构。</p><p>选择B+树的原因包括：</p><ul><li><p>节点可以有更多子节点，路径更短；</p></li><li><p>磁盘读写代价更低，非叶子节点只存储键值和指针，叶子节点存储数据；</p></li><li><p>B+树适合范围查询和扫描，因为叶子节点形成了一个双向链表。</p></li></ul><p>聚簇索引：聚簇索引是指数据与索引放在一起，B+树的叶子节点保存了整行数据，通常只有一个聚簇索引，一般是由主键构成。</p><p>非聚簇索引：数据与索引分开存储，B+树的叶子节点保存的是主键值</p><p>覆盖索引：SELECT查询中，返回的列全部能在索引中找到，避免了回表查询，提高了性能。使用覆盖索引可以减少对主键索引的查询次数，提高查询效率。</p><p>回表查询：通过二级索引找到对应的主键值，然后再通过主键值查询聚簇索引中对应的整行数据的过程。</p><p>索引创建原则：</p><ul><li>表中的数据量超过10万以上时考虑创建索引。</li><li>选择查询频繁的字段作为索引，如查询条件、排序字段或分组字段。</li><li>尽量使用复合索引，覆盖SQL的返回值。</li><li>如果字段区分度不高，可以将其放在组合索引的后面。</li><li>对于内容较长的字段，考虑使用前缀索引。</li><li>控制索引数量，因为索引虽然可以提高查询速度，但也会影响插入、更新的速度。</li></ul><p>前缀索引：是指对字符串类型（如CHAR、VARCHAR、TEXT）的字段，仅对其前N个字符建立索引，而非整个字段。例如，对VARCHAR(255)字段的前10个字符建立索引。</p><p>索引失效</p><ul><li>没有遵循最左匹配原则。</li><li>使用了模糊查询且%号在前面。</li><li>在索引字段上进行了运算或类型转换。</li><li>使用了复合索引但在中间使用了范围查询，导致右边的条件索引失效。</li></ul><h5 id="explain命令"><a href="#explain命令" class="headerlink" title="explain命令"></a>explain命令</h5><ul><li>possible_key 当前sql可能会用到的索引</li><li>key 当前sql实际命中的索引</li><li>key_len 索引占用的大小</li><li>extra 额外的优化建议<ul><li>using where; using index 查询使用了索引，需要的数据都在索引列中能找到，不需要回表查询数据</li><li>using index condition 查询使用了索引，但是需要回表查询数据</li></ul></li><li>type sql的连接类型，null、system、const、eq_ref、ref、range、index、all<ul><li>null 没有使用到表</li><li>system 查询系统中的表</li><li>const 根据主键查询</li><li>eq_ref 主键索引查询或者唯一索引查询</li><li>ref 索引查询</li><li>range 范围查询</li><li>index 索引树扫描</li><li>all 全表扫描</li></ul></li></ul><h5 id="优化经验"><a href="#优化经验" class="headerlink" title="优化经验"></a>优化经验</h5><ul><li>建表时选择合适的字段类型。</li><li>使用索引，遵循创建索引的原则。</li><li>编写高效的SQL语句，比如避免使用SELECT *，尽量使用UNION ALL代替UNION，以及在表关联时使用INNER JOIN。</li><li>采用主从复制和读写分离提高性能。</li><li>在数据量大时考虑分库分表。</li></ul><h5 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h5><p>脏读、不可重复读、幻读</p><ul><li>缓冲池（Buffer pool）：主内存中的区域，缓存磁盘上经常操作的真实数据，执行增删改查操作的时候，先操作缓冲池中的数据（若缓冲池中没有，则从磁盘中加载并缓存），以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</li><li>数据页：是innodb存储引擎磁盘管理的最小单元，每个页的大小默认为16KB，页中存储的是行数据</li></ul><p><strong>redo log</strong>（记录的是物理日志）：重做日志，记录的是事务提交时对物理页的物理修改，是用来实现事务的持久性，由重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）组成，前者在内存中，后者在磁盘中。</p><p>当事务提交后，Buffer pool变化，redo log buffer会记录变化，同时会把所有的修改信息都记录到该日志文件中，用于刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p><p>为什么不把Buffer pool中的数据直接存在对应表磁盘文件ibd文件中呢？因为这个过程io耗时久，由buffer pool交给redo log buffer后，对redo log file的记录是<strong>顺序的磁盘io</strong>，性能高，这种机制又叫WAL（write ahead logging）</p><p>保证了事务的持久性</p><p><strong>undo log</strong>（记录的是逻辑日志）：回滚日志，记录数据被修改前的信息，提供回滚和MVCC</p><ul><li>delete数据的时候，undo log中会记录一条对应的insert记录</li><li>update一条数据时，会记录一条对应相反的update记录</li></ul><p>保证了事务的原子性和一致性</p><h5 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h5><p>隐藏字段</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务id，记录最后操作这条记录的事务id</td></tr><tr><td>DB_ROLL_PTR</td><td>执行这条记录的上一个版本</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td></tr></tbody></table><ul><li>undo log版本链</li></ul><p><strong>readview</strong> </p><ul><li><p>readview 读视图是快照读sql执行时mvcc提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id</p></li><li><p>当前读：读取的是记录的最新版本，读取时还要保证其他事务不能修改当前记录，会对读取的记录加锁，比如select … lock in share mode(共享锁)、select … for update、insert、update、delete(排他锁)都是一种当前读</p></li><li><p>快照读：简单的select，不加锁，读取的是可见版本，有可能是历史数据，非阻塞读</p><ul><li>读已提交：每次select 都生成一个快照读</li><li>可重复读：开启事务后第一个select语句才是快照读的的地方</li></ul></li></ul><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务id集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务id</td></tr><tr><td>max_trx_id</td><td>预分配事务id，当前最大事务id+1</td></tr><tr><td>creator_trx_id</td><td>readview 创建者的事务id</td></tr></tbody></table><h5 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h5><pre><code class="hljs">核心是binlog文件，记录了所有的ddl（数据定义语言）和dml（数据操纵语言），但不包括select和show语句</code></pre><ul><li>主库事务提交，记录变更到binlog</li><li>从库读取主库binlog，写入到从库的中继日志relay log</li><li>从库重做中继日志中的事件</li></ul><h5 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h5><p>垂直分库：以表为依据，根据业务将不同表拆分到不同库中</p><p>垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中，冷热数据分离，减少io</p><ul><li><p>把不常用的字段单独放在一张表</p></li><li><p>把text、blob等大字段拆分出来放在附表中</p></li></ul><p>水平分库：将一个库的数据拆分到多个库，解决了单库大数据量，高并发的性能瓶颈问题，提高了系统的稳定性和可用性</p><p>路由规则</p><ul><li>根据id节点取模</li><li>按id也就是范围路由</li></ul><p>水平分表：将一个表的数据拆分到多个表中，优化单表数据量过大而产生的性能问题，避免io争抢而减少锁表的几率。</p><p>分库之后的问题：</p><ul><li>分布式事务一致性问题</li><li>跨节点关联查询</li><li>跨节点分页、排序函数</li><li>主键避重</li></ul><p>中间件：sharding-sphere mycat</p><h5 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h5><p>InnoDB 默认工作在自动提交模式（autocommit&#x3D;1），此时每条独立的 SQL 语句（如 INSERT&#x2F;UPDATE&#x2F;DELETE）会被自动包裹在一个隐式事务中。</p><h5 id="死锁排查"><a href="#死锁排查" class="headerlink" title="死锁排查"></a>死锁排查</h5><p>​开启两个事务，对应sql为</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br><span class="hljs-keyword">UPDATE</span> emp <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = &quot;灿2&quot; <span class="hljs-keyword">where</span> id = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">UPDATE</span> `<span class="hljs-keyword">user</span>` <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = &quot;uzii&quot; <span class="hljs-keyword">where</span> id = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br><span class="hljs-keyword">UPDATE</span> `<span class="hljs-keyword">user</span>` <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = &quot;uzii&quot; <span class="hljs-keyword">where</span> id = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">UPDATE</span> emp <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = &quot;灿2&quot; <span class="hljs-keyword">where</span> id = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><ul><li><p>查看&#x2F;开启记录</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;innodb_print_all_deadlocks&#x27;</span>;<br><span class="hljs-keyword">SET</span> GLOBAL <span class="hljs-comment">innodb_print_all_deadlocks = 1</span>;<br></code></pre></td></tr></table></figure></li><li><p>查看死锁日志</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">SHOW ENGINE INNODB STATUS<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br></code></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">*** (2) HOLDS THE LOCK(S):</span><br><span class="hljs-comment">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br></code></pre></td></tr></table></figure><p>事务1、2都执行了前两行sql，此时继续往下执行，事务1等待事务2释放user的锁，事务2持有user的锁，同时，等待事务1释放emp表的锁。</p></li></ul><p>​</p><ul><li><p>其他查看日志的方式</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;log_error&#x27;</span>;<br></code></pre></td></tr></table></figure><p>结果为：log_error    stderr</p><p>MySQL 服务器会将错误日志输出到标准错误输出（stderr）</p><p>若想修改，修改配置文件</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 修改my.cnf文件</span><br>log_error = /var/<span class="hljs-built_in">log</span>/mysql/<span class="hljs-keyword">error</span>.<span class="hljs-built_in">log</span><br><br><span class="hljs-comment"># 重启mysql服务</span><br>sudo systemctl restart mysql<br></code></pre></td></tr></table></figure><p>扩展，查找my.cnf位置</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">find</span> -name my.<span class="hljs-keyword">cnf</span><br>./etc/my.<span class="hljs-keyword">cnf</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="视图数据集问题"><a href="#视图数据集问题" class="headerlink" title="视图数据集问题"></a>视图数据集问题</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">full</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">from</span> test_view;// 查看视图列详情<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">VIEW</span> test_view <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span><br>code_value,<br>component_id ,<br>(<span class="hljs-keyword">case</span> xdap_watercode_stream.component_id <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;8f4b4271bd01dc7e7d814e40&#x27;</span> <span class="hljs-keyword">then</span> &quot;测试&quot; <span class="hljs-keyword">else</span> &quot;&quot; <span class="hljs-keyword">end</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci <span class="hljs-keyword">as</span> cus<br><span class="hljs-keyword">FROM</span><br>xdap_watercode_stream;<br><span class="hljs-keyword">SELECT</span><br>code_value,<br>component_id <br><span class="hljs-keyword">FROM</span><br>xdap_watercode_stream;<br></code></pre></td></tr></table></figure><h3 id="Mysql基础"><a href="#Mysql基础" class="headerlink" title="Mysql基础"></a>Mysql基础</h3><p>关系型数据库(RDBMS):建立在关系模型基础上，由多张相互连接的二维表组成的数据库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">使用表存储数据，格式统一，便于维护<br>使用<span class="hljs-keyword">sql</span>语言操作，标准统一，使用方便，可用于复杂查询<br></code></pre></td></tr></table></figure><p>创建数据库</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> dbname;<br></code></pre></td></tr></table></figure><p>mysql数据库的sql语句不区分大小写；</p><p>SQL分类</p><table><thead><tr><th>分类</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>用来定义数据库对象(数据库，表，字段)</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>用来对数据库表中的数据进行增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>用来查询数据库表中额数据</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>用来创建数据库用户、控制数据库的访问权限</td></tr></tbody></table><h5 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h5><p>下述语法中，database可以替换成schema。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 查询所有数据库</span><br><span class="hljs-keyword">show</span> databases;<br><br><span class="hljs-meta"># 查询当前数据库</span><br><span class="hljs-built_in">select</span> <span class="hljs-built_in">database</span>();<br><br><span class="hljs-meta"># 查询当前数据库所有表</span><br><span class="hljs-keyword">show</span> tables;<br><br><span class="hljs-meta"># 查询表结构</span><br>desc tableName;<br><br><span class="hljs-meta"># 查询建表语句</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> table tableName;<br><br><span class="hljs-meta"># 使用数据库</span><br><span class="hljs-keyword">use</span> 数据库名;<br><br><span class="hljs-meta"># 创建数据库</span><br><span class="hljs-keyword">create</span> database <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exists dbName;<br><br><span class="hljs-meta"># 删除数据库</span><br><span class="hljs-built_in">drop</span> database <span class="hljs-keyword">if</span> exists dbName;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">create <span class="hljs-selector-tag">table</span> 表名(<br>字段<span class="hljs-number">1</span> 字段类型 <span class="hljs-selector-attr">[约束]</span> <span class="hljs-selector-attr">[comment 注释]</span>,<br>......<br>字段n 字段类型 <span class="hljs-selector-attr">[约束]</span> <span class="hljs-selector-attr">[comment 注释]</span>,<br>)<span class="hljs-selector-attr">[comment 注释]</span>;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 添加字段<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> 字段名 类型(长度) [<span class="hljs-keyword">comment</span> 注释] [约束];<br><br># 修改字段类型<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify 字段名 新数据类型(长度);<br><br># 修改字段名和字段类型<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 change 旧字段名 新字段名 类型(长度) [<span class="hljs-keyword">comment</span> 注释] [约束];<br><br># 删除字段<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> 字段名;<br><br># 修改表名<br><span class="hljs-keyword">rename</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">to</span> 新表名;<br><br># 删除表（表中的全部数据也会被删除）<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> [<span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span>] 表名;<br></code></pre></td></tr></table></figure><p>约束</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">目的：为了保证数据库中数据的正确性、有效性和完整性<br>概念：作用与表中字段上的规则，用于限制存储在表中的数据.<br></code></pre></td></tr></table></figure><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段值不能为null</td><td>not null</td></tr><tr><td>唯一约束</td><td>保证字段的所有数据都是唯一、不重复的</td><td>unique</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>primary key</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段值，则采用默认值</td><td>default</td></tr><tr><td>外键约束</td><td>让两张表的数据建立连接，保证数据的一致性和完整性</td><td>foreign key</td></tr></tbody></table><p>数值类型、字符串类型、日期时间类型</p><p>tinyint unsigned 无符号</p><p>char 定长字符串  性能高(无需判断长度) 浪费空间</p><p>varchar 变长字符串 性能低() 节省空间</p><table><thead><tr><th>类型</th><th>大小(byte)</th><th>格式</th></tr></thead><tbody><tr><td>date</td><td>3</td><td>YYYY-MM-DD</td></tr><tr><td>time</td><td>3</td><td>HH:MM:SS</td></tr><tr><td>year</td><td>1</td><td>YYYY</td></tr><tr><td>datetime</td><td>8</td><td>YYYY-MM-DD HH:MM:SS</td></tr><tr><td>timestamp(有限制)</td><td>4</td><td>YYYY-MM-DD HH:MM:SS</td></tr></tbody></table><h5 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 指定字段添加数据</span><br><span class="hljs-attribute">insert</span> into table 表名(字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>) values (值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>);<br><br><span class="hljs-comment"># 全部字段添加数据</span><br><span class="hljs-attribute">insert</span> into table 表名 values (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br><br><span class="hljs-comment"># 批量添加数据</span><br><span class="hljs-attribute">insert</span> into 表名(字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>) values (值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>), (值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>);<br><span class="hljs-attribute">insert</span> into table 表名 values (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure><ul><li><p>插入数据时，顺序要一一对应</p></li><li><p>字符串和日期型数据应该包含在引号中</p></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 更新满足条件的数据</span><br><span class="hljs-attribute">update</span> 表名 set 字段<span class="hljs-number">1</span> = 值<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span> = 值<span class="hljs-number">2</span>, ...<span class="hljs-meta"> [where 条件];</span><br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-comment"># 删除满足条件的数据</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 [where 条件];<br><br><span class="hljs-comment"># 删除所有数据</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名; <br></code></pre></td></tr></table></figure><ul><li>delete语句不能删除某一个字段的值，可以使用update将该字段的值设置为null;</li></ul><p><a href="https://pcmsuat.dcpc.com/zbtest-SH-PUB/pdf/formConfig">https://pcmsuat.dcpc.com/zbtest-SH-PUB/pdf/formConfig</a></p><p>DQL</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span><br>字段列表<br><span class="hljs-keyword">from</span><br>表名列表<br><span class="hljs-keyword">where</span> <br>条件列表<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <br>分组字段列表<br><span class="hljs-keyword">having</span><br>分组后条件列表<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br>排序字段列表<br><span class="hljs-keyword">limit</span><br>分页参数<br></code></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> 字段<span class="hljs-number">1</span> [<span class="hljs-keyword">as</span> 别名<span class="hljs-number">1</span>], 字段<span class="hljs-number">2</span> [<span class="hljs-keyword">as</span> 别名<span class="hljs-number">2</span>] <span class="hljs-keyword">from</span> 表名;<br><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> 字段列表 <span class="hljs-keyword">from</span> 表名；<br></code></pre></td></tr></table></figure><h6 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h6><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于</td></tr><tr><td>between … and …</td><td>在某个范围之内（含最小、最大值）</td></tr><tr><td>in(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>like 占位符</td><td>模糊匹配(_匹配单个字符，&amp;匹配任意个字符)</td></tr><tr><td>is null</td><td>是null</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>and 或 &amp;&amp;</td><td>且</td></tr><tr><td>or 或 ||</td><td>或</td></tr><tr><td>not 或 !</td><td>非</td></tr></tbody></table><h6 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h6><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">介绍：将一列数据作为一个整体，进行纵向计算<br>语法：<span class="hljs-keyword">select</span> 聚合函数(字段列表) <span class="hljs-keyword">from</span> 表名;<br>注意：聚合函数不对<span class="hljs-literal">null</span>值进行计算<br></code></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>count(字段)  </p><p>count(常量)：count(0)、count(1)、count(a)这三种效果都是一样的</p><p>count( * )：求取表的总数据量，<em>“</em>”代表统配，mysql底层专门做了适配，推荐使用。</p><p>sum(字符串列)，我试了，mysql5返回的是0;</p><h6 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h6><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> 字段列表 <span class="hljs-keyword">from</span> 表名 [<span class="hljs-keyword">where</span> 条件] <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段名 [<span class="hljs-keyword">having</span> 分组后过滤条件]<br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># 会报错，分组后，是一组组数据，只能select 分组字段 或者 使用聚合函数</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;<br><span class="hljs-meta"># 正确使用</span><br><span class="hljs-keyword">select</span> gender, COUNT(*) <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;<br></code></pre></td></tr></table></figure><p>使用HAVING对分组后的数据进行条件过滤</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">SELECT</span><br>job,<br>COUNT<span class="hljs-comment">(*) </span><br><span class="hljs-comment">FROM</span><br><span class="hljs-comment">tb_emp </span><br><span class="hljs-comment">WHERE</span><br><span class="hljs-comment">entrydate &lt;= &#x27;2015-01-01&#x27; </span><br><span class="hljs-comment">GROUP BY</span><br><span class="hljs-comment">job</span><br><span class="hljs-comment">HAVING COUNT(*)</span>&gt; <span class="hljs-number">1</span><span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><p>where和having的区别</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">执行时机不同；<span class="hljs-keyword">where</span>是对分组之前进行过滤，不满足<span class="hljs-keyword">where</span>条件，不参与分组;而<span class="hljs-keyword">having</span>是分组后对结果进行过滤。<br>判断条件不同：<span class="hljs-keyword">where</span>不能对聚合函数进行判断，而<span class="hljs-keyword">having</span>可以<br></code></pre></td></tr></table></figure><p>注意事项</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。<br>执行顺序：<span class="hljs-keyword">where</span> &gt; 聚合函数 &gt; <span class="hljs-keyword">having</span><br></code></pre></td></tr></table></figure><h6 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h6><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> 字段列表 <span class="hljs-keyword">from</span> 表名 [<span class="hljs-keyword">where</span> 条件] <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段名 [<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 字段<span class="hljs-number">1</span> 排序方式<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span> 排序方式<span class="hljs-number">2.</span>.....]<br></code></pre></td></tr></table></figure><p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">排序方式<br><span class="hljs-symbol">ASC:</span>升序 默认<br><span class="hljs-symbol">DESC:</span>降序<br></code></pre></td></tr></table></figure><h6 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h6><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> 字段列表 <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">limit</span> 起始索引, 查询记录数;<br></code></pre></td></tr></table></figure><p>注意点：</p><ul><li>起始索引从0开始，起始索引 &#x3D; (页码 - 1) * 每页展示记录数</li><li>如果查询的是第一页数据，起始索引可以忽略，limit 10</li><li>不同数据库不同实现，mysql是limit</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 第一页</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp limit <span class="hljs-number">0</span>,<span class="hljs-number">5</span>;<br><span class="hljs-comment">// 第二页</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp limit <span class="hljs-number">5</span>,<span class="hljs-number">5</span>;<br><span class="hljs-comment">// 第三页</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp limit <span class="hljs-number">10</span>,<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h6 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># <span class="hljs-keyword">if</span> (条件表达式, <span class="hljs-keyword">true</span>取值, <span class="hljs-keyword">false</span>取值)<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">IF</span>(gender = <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;man&#x27;</span>, <span class="hljs-string">&#x27;women&#x27;</span>) [<span class="hljs-keyword">as</span>] 性别, COUNT(*) <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> gender;<br><br>结果<br>man<span class="hljs-number">24</span><br>women<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">case</span> 表达式 <span class="hljs-keyword">when</span>  值<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 结果<span class="hljs-number">1</span> <span class="hljs-keyword">when</span> 值<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 结果<span class="hljs-number">2</span> ... else... <span class="hljs-keyword">end</span><br><span class="hljs-keyword">SELECT</span><br>( <span class="hljs-keyword">CASE</span> job <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;班主任&#x27;</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;讲师&#x27;</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;学工主管&#x27;</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-number">4</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;教研主管&#x27;</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;未分配职位&#x27;</span> <span class="hljs-keyword">END</span> ) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;职位&#x27;</span> <br><span class="hljs-keyword">FROM</span><br>tb_emp;<br><br><br></code></pre></td></tr></table></figure><h5 id="多表设计"><a href="#多表设计" class="headerlink" title="多表设计"></a>多表设计</h5><h6 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h6><p>为了保证数据的一致性和完整性</p><p>外键约束</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sas">-- 创建表时指定<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(<br>字段名    数据类型,<br>...<br>[constraint]   [外键名称]  <span class="hljs-keyword">foreign</span>  <span class="hljs-keyword">key</span> (外键字段名)   <span class="hljs-keyword">references</span>   主表 (字段名)<br>);<br>-- 建完表后，添加外键<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span>  表名  <span class="hljs-keyword">add</span> constraint  外键名称  <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span> (外键字段名) <span class="hljs-keyword">references</span>  主表(字段名);<br></code></pre></td></tr></table></figure><ul><li>物理外键</li></ul><p>概念：使用 foreign key 定义外键关联另外一张表。</p><p>缺点：影响增、删、改的效率（需要检查外键关系）。</p><p>仅用于单节点数据库，不适用与分布式、集群场景。</p><p>容易引发数据库的死锁问题，消耗性能。</p><ul><li>逻辑外键</li></ul><p>概念：在业务层逻辑中，解决外键关联。</p><p>通过逻辑外键，就可以很方便的解决上述问题。</p><h6 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h6><p>案例: 用户 与 身份证信息 的关系</p><p>关系: 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以提升操作效率</p><p>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(unique)</p><h6 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h6><p>案例: 学生 与 课程的关系</p><p>关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择</p><p>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h5 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h5><p>多表查询: 指从多张表中查询数据</p><p>笛卡尔积: 笛卡尔乘积是指在数学中，两个集合(A集合 和 B集合)的所有组合情况。(在多表查询时，需要消除无效的笛卡尔积)</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># 笛卡尔积</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp, tb_dept;<br><br><span class="hljs-meta"># 添加条件，消除无效的笛卡尔积</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp, tb_dept <span class="hljs-keyword">where</span> tb_emp.dept_id = tb_dept.id;<br></code></pre></td></tr></table></figure><ul><li><p>连接查询</p><ul><li>内连接：相当于查询A、B交集部分数据</li><li>外连接<ul><li>左外连接：查询左表所有数据(包括两张表交集部分数据)</li><li>右外连接：查询右表所有数据(包括两张表交集部分数据)</li></ul></li></ul></li><li><p>子查询</p></li></ul><h6 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h6><p>隐式内连接：select  字段列表   from   表1 , 表2   where   条件 … ;</p><p>显式内连接：select  字段列表   from   表1  [ inner ]  join 表2  on  连接条件 … ;</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"># 报错，起了别名后，需要使用别名<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp <span class="hljs-built_in">e</span>, tb_dept d <span class="hljs-keyword">WHERE</span> tb_emp.dept_id = d.id;<br><span class="hljs-keyword">select</span> tb_emp.name <span class="hljs-keyword">from</span> tb_emp <span class="hljs-built_in">e</span>, tb_dept d <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br># 正确<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.name <span class="hljs-keyword">from</span> tb_emp <span class="hljs-built_in">e</span>, tb_dept d <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br></code></pre></td></tr></table></figure><h6 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h6><p>左外连接：select  字段列表   from   表1  left  [ outer ]  join 表2  on 连接条件 … ;</p><p>右外连接：select  字段列表   from   表1  right  [ outer ]  join 表2  on  连接条件 … ;</p><h6 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h6><p>介绍：SQL语句中嵌套select语句，称为嵌套查询，又称子查询。</p><p>形式：select  *  from   t1   where  column1 &#x3D;  ( select  column1  from  t2  … );</p><p>子查询外部的语句可以是insert &#x2F; update &#x2F; delete &#x2F; select 的任何一个，最常见的是 select。</p><ul><li><p>标量子查询：子查询返回的结果为单个值</p><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式常用的操作符：&#x3D;   &lt;&gt;    &gt;     &gt;&#x3D;     &lt;    &lt;&#x3D;   </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> dept_id = (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;教研部&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>列子查询：子查询返回的结果为一列</p><p>子查询返回的结果是一列（可以是多行）常用的操作符：in  、not in等</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;教研部&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;咨询部&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>行子查询：子查询返回的结果为一行</p><p>子查询返回的结果是一行（可以是多列）。常用的操作符：&#x3D;  、&lt;&gt; 、in 、not  in</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> (entrydate, job) = (<span class="hljs-keyword">select</span> entrydate, job <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;韦一笑&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>表子查询：子查询返回的结果为多行多列</p><p>子查询返回的结果是多行多列，常作为临时表常用的操作符：in</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"># 不过滤空值<br><span class="hljs-keyword">select</span> emp.name, tb_dept.name <span class="hljs-keyword">from</span> tb_dept <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> entrydate &gt; <span class="hljs-string">&#x27;2006-01-01&#x27;</span>)  emp <span class="hljs-keyword">on</span> emp.dept_id = tb_dept.id;<br># 过滤空值<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.*, d.name <span class="hljs-keyword">from</span>  (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> entrydate &gt; <span class="hljs-string">&#x27;2006-01-01&#x27;</span>) <span class="hljs-built_in">e</span>, tb_dept d <span class="hljs-keyword">where</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br></code></pre></td></tr></table></figure></li></ul><h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>事务 是一组操作的集合，它是一个不可分割的工作单位。</p><p>事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作 要么同时成功，要么同时失败。</p><p>默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。</p><p>开启事务：start transaction;  &#x2F;  begin ;</p><p>提交事务：commit;</p><p>回滚事务：rollback;</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">start transaction<span class="hljs-comment">;</span><br>sql1<span class="hljs-comment">;</span><br>sql2<span class="hljs-comment">;</span><br>commit<span class="hljs-comment">;</span><br>rollback<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>四大特性</p><p>原子性：事务是不可分割的最小单元，要么全部成功，要么全部失败</p><p>一致性：事务完成时，必须使所有的数据都保持一致状态</p><p>隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</p><p>持久性：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</p><h5 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h5><p>索引（index）是帮助数据库 高效获取数据 的 数据结构 。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_sku_sn <span class="hljs-keyword">on</span> tb_sku(sn);<br></code></pre></td></tr></table></figure><p>优点：</p><p>​提高数据查询的效率，降低数据库的IO成本。</p><p>​通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗。</p><p>缺点：</p><p>​索引会占用存储空间。</p><p>​索引大大提高了查询效率，同时却也降低了insert、update、delete的效率。</p><p>结构</p><p>​MySQL数据库支持的索引结构有很多，如：Hash索引、B+Tree索引、Full-Text索引等。我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。</p><p>问题1：为什么不用二叉搜索树或者红黑树</p><p>​大数据量情况下，层级深，检索速度慢。</p><p>B+Tree(多路平衡搜索树)</p><p>每一个节点，可以存储多个key（有n个key，就有n个指针）。</p><p>所有的数据都存储在叶子节点，非叶子节点仅用于索引数据。</p><p>叶子节点形成了一颗双向链表，便于数据的排序及区间范围查询。</p><p>create  [ unique ]  index 索引名 on  表名 (字段名,… ) ;</p><p>show  index  from  表名;</p><p>drop  index  索引名  on  表名;</p><p>主键字段，在建表时，会自动创建主键索引。</p><p>添加唯一约束时，数据库实际上会添加唯一索引。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机备份</title>
    <link href="/2025/04/27/%E8%99%9A%E6%8B%9F%E6%9C%BA/vmware/%E5%A4%87%E4%BB%BD/"/>
    <url>/2025/04/27/%E8%99%9A%E6%8B%9F%E6%9C%BA/vmware/%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="一、直接复制文件夹"><a href="#一、直接复制文件夹" class="headerlink" title="一、直接复制文件夹"></a>一、直接复制文件夹</h3><ul><li><p>右键虚拟机，打开所在目录，备份此目录内容</p></li><li><p>在新环境下的vmware文件，选择打开虚拟机，选择刚刚目录下的vmx文件即可</p></li></ul><h3 id="二、通过虚拟机导入导出"><a href="#二、通过虚拟机导入导出" class="headerlink" title="二、通过虚拟机导入导出"></a>二、通过虚拟机导入导出</h3><ul><li><p>文件-&gt;导出为OVF文件</p></li><li><p>打开-&gt;选择OVF文件</p></li></ul><p>阿里云镜像-下载linux镜像</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs md">https://developer.aliyun.com/mirror/?spm=a2c6h.25603864.0.0.74092d1c89ipr2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>虚拟机</category>
      
      <category>vmware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备份</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring使用</title>
    <link href="/2025/04/24/java/spring/Spring%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/04/24/java/spring/Spring%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="如何启动一个springboot项目"><a href="#如何启动一个springboot项目" class="headerlink" title="如何启动一个springboot项目"></a>如何启动一个springboot项目</h2><h5 id="1-pom-xml文件"><a href="#1-pom-xml文件" class="headerlink" title="1.pom.xml文件"></a>1.pom.xml文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;project xmlns=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br>         xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>         xsi:schemaLocation=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;<br>    &lt;modelVersion&gt;<span class="hljs-number">4.0</span><span class="hljs-number">.0</span>&lt;/modelVersion&gt;<br><br>    &lt;groupId&gt;org.lzc&lt;/groupId&gt;<br>    &lt;artifactId&gt;web-connect&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">1.0</span>-SNAPSHOT&lt;/version&gt;<br><br>    &lt;parent&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br>        &lt;version&gt;<span class="hljs-number">2.2</span><span class="hljs-number">.7</span>.RELEASE&lt;/version&gt;<br>        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;<br>    &lt;/parent&gt;<br><br>    &lt;properties&gt;<br>        &lt;maven.compiler.source&gt;<span class="hljs-number">8</span>&lt;/maven.compiler.source&gt;<br>        &lt;maven.compiler.target&gt;<span class="hljs-number">8</span>&lt;/maven.compiler.target&gt;<br>        &lt;project.build.sourceEncoding&gt;UTF-<span class="hljs-number">8</span>&lt;/project.build.sourceEncoding&gt;<br>    &lt;/properties&gt;<br><br><br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br>            &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br>            &lt;optional&gt;<span class="hljs-literal">true</span>&lt;/optional&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br>  <br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br>                &lt;configuration&gt;<br>                    &lt;excludes&gt;<br>                        &lt;exclude&gt;<br>                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br>                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br>                        &lt;/exclude&gt;<br>                    &lt;/excludes&gt;<br>                &lt;/configuration&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br><br>&lt;/project&gt;<br></code></pre></td></tr></table></figure><h5 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h5><ul><li><p>resources文件夹下添加application.properties配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">spring.application.name=web-connect<br>server.port=<span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure></li><li><p>创建主启动类，类上添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br></code></pre></td></tr></table></figure></li><li><p>主启动类main方法中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SpringApplication.run(主启动类.class, args);<br></code></pre></td></tr></table></figure></li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h5 id="controller与get请求"><a href="#controller与get请求" class="headerlink" title="controller与get请求"></a>controller与get请求</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span> String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Hello %s!&quot;</span>, name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注解使用"><a href="#注解使用" class="headerlink" title="注解使用"></a>注解使用</h2><h5 id="ConditionalOnProperty-根据配置文件决定是否创建类"><a href="#ConditionalOnProperty-根据配置文件决定是否创建类" class="headerlink" title="@ConditionalOnProperty 根据配置文件决定是否创建类"></a>@ConditionalOnProperty 根据配置文件决定是否创建类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(&quot;xdap.sql.connector&quot;)</span><br><span class="hljs-meta">@ConditionalOnProperty(name = &quot;xdap.sql.connector.enable&quot;, havingValue = &quot;true&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApaasSqlConnectorProperties</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">existConnector</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/&quot;</span>;<br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        SqlStringUtil.initExistConnector(existConnector);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h5><p>​用于启用自动配置功能</p><p>该注解通过以下机制实现自动配置：</p><ol><li><p><strong>@Import 注解</strong><br><code>@EnableAutoConfiguration</code> 使用 <code>@Import(AutoConfigurationImportSelector.class)</code> 导入自动配置类。</p></li><li><p><strong>AutoConfigurationImportSelector</strong><br>这是一个实现了 <code>ImportSelector</code> 接口的类，负责加载 <code>META-INF/spring.factories</code> 文件中定义的自动配置类。</p></li><li><p><strong>spring.factories 文件</strong><br>Spring Boot 及各个 Starter 模块在 <code>META-INF/spring.factories</code> 中定义了大量自动配置类，例如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span><br><span class="hljs-string">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\</span><br><span class="hljs-string">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</span><br></code></pre></td></tr></table></figure></li><li><p><strong>条件注解</strong><br>自动配置类中使用了大量条件注解（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>），确保只有在满足特定条件时才会生效。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring基础知识</title>
    <link href="/2025/04/24/java/spring/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2025/04/24/java/spring/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>ApplicationContext 、BeanFactory二者都可以获取bean，但是ApplicationContext 更全面，解析配置类，注册beanDefinition。</p><ul><li>实例化bean，早期bean</li><li>属性注入，@Autowried</li><li>初始化前 BeanPostProcessor（postProcessBeforeInitialization）、Aware</li><li>初始化  @PostConstruct 、InitializingBean（afterPropertiesSet）</li><li>初始化后  BeanPostProcessor（postProcessAfterInitialization）</li></ul><p>spring使用class.newInstance()创建对象</p><ul><li><p>默认情况下调用无参构造函数进行构造</p></li><li><p>假如有两个构造函数，也是有无参构造函数优先。</p></li><li><p>没有无参构造函数，有多个有参构造函数，会报错</p></li></ul><h5 id="springmvc的执行流程"><a href="#springmvc的执行流程" class="headerlink" title="springmvc的执行流程"></a>springmvc的执行流程</h5><ul><li><p>视图阶段（老旧jsp等）</p></li><li><p>前后端分离阶段（接口开发、异步）</p></li></ul><h5 id="springboot自动配置原理"><a href="#springboot自动配置原理" class="headerlink" title="springboot自动配置原理"></a>springboot自动配置原理</h5><pre><code class="hljs">Spring Boot的自动配置原理基于@SpringBootApplication注解，它封装了@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan。</code></pre><p>​@EnableAutoConfiguration是核心，它通过@Import导入配置选择器，读取META-INF&#x2F;spring.factories文件中的类名，根据条件注解决定是否将配置类中的Bean导入到Spring容器中。</p><h5 id="nacos和eureka的区别"><a href="#nacos和eureka的区别" class="headerlink" title="nacos和eureka的区别"></a>nacos和eureka的区别</h5><p>共同点：都支持服务注册和服务拉取，都支持服务提供者心跳方式做健康检测</p><p>不同点：</p><ul><li>nacos平时创建的都是临时实例，采用心跳检测，通过配置文件ephemeral控制，如果是非临时实例，nacos会<strong>主动询问</strong>提供者状态是否还存活。</li><li>nacos可以主动推送变更消息到服务消费者</li><li>临时实例不正常会被剔除，非临时实例则不会删除</li><li>nacos集群默认采用ap方式，当集群中存在非临时实例时，采用cp模式; eureka采用ap方式</li><li>nacos还提供了注册中心</li></ul><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>Ribbon，发起远程调用feign就会使用ribbon</p><ul><li>RoundRobinRule：简单的轮询策略。</li><li>WeightedResponseTimeRule：根据响应时间加权选择服务器。</li><li>RandomRule：随机选择服务器。</li><li>ZoneAvoidanceRule：区域感知的负载均衡，优先选择同一区域中可用的服务器。</li></ul><h5 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h5><p>服务雪崩是指一个服务的失败导致整个链路的服务相继失败。我们通常通过服务降级和服务熔断来解决这个问题：</p><ul><li>服务降级：在请求量突增时，主动降低服务的级别，确保核心服务可用。</li><li>服务熔断：当服务调用失败率达到一定阈值时，熔断机制会启动，防止系统过载。</li></ul><p>在Feign客户端启用熔断，定义降级逻辑处理异常：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">&quot;service-name&quot;</span>, fallback = FallbackService.class)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFeignClient</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/endpoint&quot;</span>)<br>    <span class="hljs-keyword">String</span> someMethod();<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">FallbackService</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">MyFeignClient</span></span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> someMethod() &#123;<br>        <span class="hljs-comment">// 返回默认值或抛出降级异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span><span class="hljs-type"></span> ServiceUnavailableException(<span class="hljs-string">&quot;服务暂不可用&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="skywalking"><a href="#skywalking" class="headerlink" title="skywalking"></a>skywalking</h5><p>application performance managment</p><ul><li>服务：微服务</li><li>端点：接口</li><li>实例：物理机</li></ul><h5 id="CAP-和-BASE"><a href="#CAP-和-BASE" class="headerlink" title="CAP 和 BASE"></a>CAP 和 BASE</h5><p>CAP理论是分布式系统设计的基础理论，包含一致性(Consistency)、可用性(Availability)和分区容错性(Partition tolerance)。在网络分区发生时，系统只能在一致性和可用性之间选择其一。</p><ul><li>C：用户访问分布式系统中的任意节点，得到的数据必须一致，即多个节点间数据要及时同步</li><li>A：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或者拒绝</li><li>P：因为网络故障或其他原因导致分布式系统中部分节点与其他节点失去连接，形成独立分区，tolerance是指集群出现分区的时候，整个系统也要持续对外提供服务</li></ul><p>分布式系统节点之间肯定时需要网络连接的，分区是必然存在的</p><p>AP 保证访问的高可用性，可以持续对外提供服务，但不是保证数据的强一致性。</p><p>CP 保证数据的强一致性，放弃高可用性。</p><p>BASE理论是分布式系统设计中对CAP理论中AP方案的延伸，强调通过基本可用、软状态和最终一致性来实现系统设计。</p><h5 id="修改spring默认线程池配置"><a href="#修改spring默认线程池配置" class="headerlink" title="修改spring默认线程池配置"></a>修改spring默认线程池配置</h5><blockquote><p>spring中经常会使用到异步任务，如何修改其线程池配置？</p></blockquote><ul><li>示例，比如事件框架前使用的@EnableAsync(放在任一配置类即可)以及@Async注解</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">xxx</span>&#123;<br>    <span class="hljs-variable">@Async</span><br>    <span class="hljs-variable">@EventListener</span><br>    public void <span class="hljs-built_in">xxx</span>() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>实现AsyncConfigurer即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultAsyncThreadPoolConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AsyncConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getAsyncExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>        <span class="hljs-comment">//核心线程池大小</span><br>        executor.setCorePoolSize(<span class="hljs-number">20</span>);<br>        <span class="hljs-comment">//最大线程数</span><br>        executor.setMaxPoolSize(<span class="hljs-number">150</span>);<br>        <span class="hljs-comment">//队列容量</span><br>        executor.setQueueCapacity(<span class="hljs-number">100</span>);<br>        <span class="hljs-comment">//活跃时间</span><br>        executor.setKeepAliveSeconds(<span class="hljs-number">300</span>);<br>        <span class="hljs-comment">//线程名字前缀</span><br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;DefaultExecutor-&quot;</span>);<br>        <span class="hljs-comment">// setRejectedExecutionHandler：当pool已经达到max size的时候，如何处理新任务</span><br>        <span class="hljs-comment">// CallerRunsPolicy：不在新线程中执行任务，而是由调用者所在的线程来执行</span><br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br>        executor.setWaitForTasksToCompleteOnShutdown(<span class="hljs-literal">true</span>);<br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;cc-async-&quot;</span>);<br>        executor.initialize();<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本人在定时任务中触发的事件框架，事件框架方法处使用的异步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EventListener</span><br><span class="hljs-meta">@Async</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleAutoApproveEvent</span><span class="hljs-params">(TestEvent testEvent)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> testEvent.getInfo();<br>    log.info(info);<br>&#125;<br></code></pre></td></tr></table></figure><p>有个注意的点，异步线程池貌似是懒加载，第一次使用到的时候才会初始化</p><p><img src="/../../../images/Spring_%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1_%E4%BA%8B%E4%BB%B6%E6%A1%86%E6%9E%B6_%E5%BC%82%E6%AD%A5_%E7%BA%BF%E7%A8%8B%E6%B1%A0.png"></p><p>todo，spring自带的线程池和jdk的有什么区别</p><h5 id="拦截器和过滤器"><a href="#拦截器和过滤器" class="headerlink" title="拦截器和过滤器"></a>拦截器和过滤器</h5><blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">HandlerInterceptor、<span class="hljs-built_in">Filter</span><br></code></pre></td></tr></table></figure></blockquote><p>1.拦截器是SpringMVC框架层面的，Filter是Servlet规范层面的</p><p>2.拦截器的执行时机是在Controller方法前后，Filter是在Servlet请求处理前后</p><p>3.拦截器能获取到HandlerMethod、ModelAndView</p><p>4.拦截器的afterCompletion 可处理异常，过滤器会报错，需要手动捕获异常</p><h5 id="配置文件优先级"><a href="#配置文件优先级" class="headerlink" title="配置文件优先级"></a>配置文件优先级</h5><h5 id="过滤器-Filter-和拦截器Interceptor"><a href="#过滤器-Filter-和拦截器Interceptor" class="headerlink" title="过滤器(Filter)和拦截器Interceptor"></a>过滤器(Filter)和拦截器Interceptor</h5><p><strong>过滤器(Filter)</strong></p><ul><li><p>概念：JavaWeb三大组件（Servlet、Filter、Listener）之一。</p></li><li><p>过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。</p></li><li><p>过滤器一般完成一些通用的操作，比如登录校验、同一编码处理、敏感字符处理。</p></li></ul><p>放行后访问对应资源，资源访问完毕后，还会回到filter中执行放行后的逻辑。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;放行前逻辑&quot;</span>);<br>    <span class="hljs-comment">// 放行</span><br>    filterChain.doFilter(servletRequest, servletResponse);<br>    System.out.println(<span class="hljs-string">&quot;放行后逻辑&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>拦截路径</th><th>urlPatterns值</th><th>含义</th></tr></thead><tbody><tr><td>拦截具体路径</td><td>&#x2F;login</td><td>只有访问&#x2F;login时才拦截</td></tr><tr><td>目录拦截</td><td>&#x2F;emps&#x2F;*</td><td>访问&#x2F;emps下的所有资源都会被拦截</td></tr><tr><td>拦截所有</td><td>&#x2F;*</td><td>访问所有资源都会被拦截</td></tr></tbody></table><p>过滤器链：一个Web应用中，可以配置多个过滤器，这多个过滤器就形成了一个过滤器链。</p><p>顺序：注解配置的filter，优先级是按照过滤器类名的自然排序</p><p><strong>拦截器Interceptor</strong></p><p>概念：是一种动态拦截方法调用的机制，类似于过滤器。是spring框架中提供的，用来动态拦截控制器方法的执行。</p><p>作用：拦截请求，在指定的方法调用后，根据业务需要执行预先设定的代码。</p><table><thead><tr><th>拦截路径</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>&#x2F;*</td><td>一级路径</td><td>不能匹配&#x2F;depts&#x2F;1</td></tr><tr><td>&#x2F;**</td><td>任意级路径</td><td></td></tr><tr><td>&#x2F;depts&#x2F;*</td><td>&#x2F;depts下的一级路径</td><td>不能匹配&#x2F;depts&#x2F;1&#x2F;2，&#x2F;depts</td></tr><tr><td>&#x2F;depts&#x2F;**</td><td>&#x2F;depts下的任意级路径</td><td></td></tr></tbody></table><p>配置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptorConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">TestInterceptor</span> testInterceptor;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addInterceptors</span>(<span class="hljs-params"><span class="hljs-title class_">InterceptorRegistry</span> registry</span>) &#123;<br>        registry.<span class="hljs-title function_">addInterceptor</span>(testInterceptor)<br>                .<span class="hljs-title function_">addPathPatterns</span>(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .<span class="hljs-title function_">excludePathPatterns</span>(<span class="hljs-string">&quot;/login&quot;</span>); <span class="hljs-comment">// 排除的资源</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Filter和Interceptor：Filter拦截所有的资源，而Interceptor只会拦截spring环境中的资源</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="定时任务Schedule跟踪以及afterSingletonsInstantiated、onApplicationEvent-ContextRefreshedEvent-event"><a href="#定时任务Schedule跟踪以及afterSingletonsInstantiated、onApplicationEvent-ContextRefreshedEvent-event" class="headerlink" title="定时任务Schedule跟踪以及afterSingletonsInstantiated、onApplicationEvent(ContextRefreshedEvent event)"></a>定时任务Schedule跟踪以及afterSingletonsInstantiated、onApplicationEvent(ContextRefreshedEvent event)</h5><blockquote><p>spring中经常看到实现一个接口然后修改配置类的情况，此次学习定时任务的时候也发现了，下面来分析下他是如何实现的</p></blockquote><ul><li>代码示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduleConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SchedulingConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureTasks</span><span class="hljs-params">(ScheduledTaskRegistrar scheduledTaskRegistrar)</span> &#123;<br>   scheduledTaskRegistrar.setScheduler(Executors.newScheduledThreadPool(corePoolSize));<br>        scheduledTaskRegistrar.setTaskScheduler(poolScheduler());<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TaskScheduler <span class="hljs-title function_">poolScheduler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolTaskScheduler</span> <span class="hljs-variable">scheduler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskScheduler</span>();<br>        scheduler.setThreadNamePrefix(<span class="hljs-string">&quot;poolScheduler&quot;</span>);<br>        scheduler.setPoolSize(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">return</span> scheduler;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过打断点的方式，网上跟踪代码，发现这段代码实现的接口，是在如下部分被调用的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.beanFactory <span class="hljs-keyword">instanceof</span> ListableBeanFactory) &#123;<br>    Map&lt;String, SchedulingConfigurer&gt; beans = ((ListableBeanFactory)<span class="hljs-built_in">this</span>.beanFactory).getBeansOfType(SchedulingConfigurer.class);<br>    List&lt;SchedulingConfigurer&gt; configurers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(beans.values());<br>    AnnotationAwareOrderComparator.sort(configurers);<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> configurers.iterator();<br><br>    <span class="hljs-keyword">while</span>(var3.hasNext()) &#123;<br>        <span class="hljs-type">SchedulingConfigurer</span> <span class="hljs-variable">configurer</span> <span class="hljs-operator">=</span> (SchedulingConfigurer)var3.next();<br>        configurer.configureTasks(<span class="hljs-built_in">this</span>.registrar);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​其获取了所有实现了SchedulingConfigurer类型的bean，然后依次执行configureTasks方法。</p><ul><li>此方法集成在finishRegistration()中，在afterSingletonsInstantiated和onApplicationEvent中均有调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterSingletonsInstantiated</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.nonAnnotatedClasses.clear();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.applicationContext == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.finishRegistration();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> &#123;<br>    <span class="hljs-keyword">if</span> (event.getApplicationContext() == <span class="hljs-built_in">this</span>.applicationContext) &#123;<br>        <span class="hljs-built_in">this</span>.finishRegistration();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>他们两个的区别</p><table><thead><tr><th>维度</th><th><code>afterSingletonsInstantiated()</code></th><th><code>onApplicationEvent(ContextRefreshedEvent)</code></th></tr></thead><tbody><tr><td><strong>接口类型</strong></td><td><code>SmartInitializingSingleton</code>（Spring 内置）</td><td><code>ApplicationListener</code>（事件监听）</td></tr><tr><td><strong>触发时机</strong></td><td>所有单例 Bean <strong>初始化完成后</strong>立即触发</td><td>整个应用上下文 <strong>刷新完成后</strong>触发</td></tr><tr><td><strong>执行次数</strong></td><td>仅执行 <strong>1 次</strong>（容器启动时）</td><td>可能执行 <strong>多次</strong>（每次上下文刷新时）</td></tr><tr><td><strong>上下文状态</strong></td><td>Bean 已完成实例化和初始化（包括 <code>@PostConstruct</code>）</td><td>整个上下文已刷新，可能包含 Bean 的销毁和重建</td></tr><tr><td><strong>延迟加载 Bean</strong></td><td>不考虑延迟加载 Bean（即使存在也会触发）</td><td>延迟加载 Bean 可能尚未初始化</td></tr></tbody></table><ul><li><p>推荐使用 SmartInitializingSingleton 的场景</p><p>需要确保所有单例 Bean 都已初始化完成（如注册全局拦截器、初始化缓存）。<br>避免多次执行（如加载基础数据到内存）</p></li><li><p>推荐使用 ContextRefreshedEvent 的场景</p><p>需要响应上下文刷新事件（如重新加载配置、重置状态）。<br>在父子上下文环境中，需要区分不同上下文的刷新。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 常用命令速查手册</title>
    <link href="/2025/04/23/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2025/04/23/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="🐧-Linux-常用命令速查手册"><a href="#🐧-Linux-常用命令速查手册" class="headerlink" title="🐧 Linux 常用命令速查手册"></a>🐧 Linux 常用命令速查手册</h1><blockquote><p>本文档收集了日常使用中最常用的 Linux 命令，方便快速查阅和使用。</p></blockquote><hr><h2 id="📁-文件查找与搜索"><a href="#📁-文件查找与搜索" class="headerlink" title="📁 文件查找与搜索"></a>📁 文件查找与搜索</h2><h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基本语法</span><br>find [文件夹路径] -name <span class="hljs-string">&quot;文件名&quot;</span><br><br><span class="hljs-comment"># 示例：在当前文件夹下面查找 main.dic 的文件</span><br>find . -name main.dic<br><br><span class="hljs-comment"># 更多实用示例</span><br>find /home -name <span class="hljs-string">&quot;*.txt&quot;</span>           <span class="hljs-comment"># 查找所有 .txt 文件</span><br>find . -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*.log&quot;</span>       <span class="hljs-comment"># 查找当前目录下的日志文件</span><br>find . -mtime -7 -name <span class="hljs-string">&quot;*.bak&quot;</span>     <span class="hljs-comment"># 查找7天内修改的备份文件</span><br></code></pre></td></tr></table></figure><h3 id="文本内容搜索、查看"><a href="#文本内容搜索、查看" class="headerlink" title="文本内容搜索、查看"></a>文本内容搜索、查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看文件中包含&quot;xx&quot;的行，上下30行的内容</span><br>grep -B 30 -A 30 <span class="hljs-string">&quot;xx&quot;</span> filename<br><br><span class="hljs-comment"># 常用选项说明</span><br>grep -i <span class="hljs-string">&quot;pattern&quot;</span> file             <span class="hljs-comment"># 忽略大小写</span><br>grep -r <span class="hljs-string">&quot;pattern&quot;</span> directory        <span class="hljs-comment"># 递归搜索目录</span><br>grep -n <span class="hljs-string">&quot;pattern&quot;</span> file             <span class="hljs-comment"># 显示行号</span><br>grep -v <span class="hljs-string">&quot;pattern&quot;</span> file             <span class="hljs-comment"># 反向匹配（排除包含pattern的行）</span><br><br><span class="hljs-comment"># 查看某个文件前、后三十行内容</span><br><span class="hljs-built_in">head</span> -n 30 文件名<br><span class="hljs-built_in">tail</span> -n 30 文件名<br></code></pre></td></tr></table></figure><hr><h2 id="🎨-字体管理"><a href="#🎨-字体管理" class="headerlink" title="🎨 字体管理"></a>🎨 字体管理</h2><h3 id="查看已安装字体"><a href="#查看已安装字体" class="headerlink" title="查看已安装字体"></a>查看已安装字体</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看中文字体</span><br>fc-list :lang=zh<br><br><span class="hljs-comment"># 查看所有字体</span><br>fc-list<br><br><span class="hljs-comment"># 查看特定字体族</span><br>fc-list | grep <span class="hljs-string">&quot;Arial&quot;</span><br></code></pre></td></tr></table></figure><h3 id="安装新字体"><a href="#安装新字体" class="headerlink" title="安装新字体"></a>安装新字体</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 步骤1：下载并解压字体压缩包</span><br>wget http://kkfileview.keking.cn/fonts.zip<br>unzip fonts.zip<br><br><span class="hljs-comment"># 安装解压工具（如果需要）</span><br><span class="hljs-built_in">sudo</span> apt-get install unzip<br><span class="hljs-built_in">sudo</span> apt-get update<br><br><span class="hljs-comment"># 步骤2：下载并安装TTF字体</span><br>wget -O /usr/share/fonts/simsun.ttf https://pfh-file-store.oss-cn-hangzhou.aliyuncs.com/simsun.ttf \<br>&amp;&amp; wget -O /usr/share/fonts/simfang.ttf https://pfh-file-store.oss-cn-hangzhou.aliyuncs.com/simfang.ttf \<br>&amp;&amp; wget -O /usr/share/fonts/STFANGSO.TTF https://pfh-file-store.oss-cn-hangzhou.aliyuncs.com/STFANGSO.TTF \<br>&amp;&amp; fc-cache -vf                    <span class="hljs-comment"># 刷新字体缓存</span><br>&amp;&amp; fc-list                         <span class="hljs-comment"># 列出已安装字体</span><br></code></pre></td></tr></table></figure><hr><h2 id="📦-压缩与解压"><a href="#📦-压缩与解压" class="headerlink" title="📦 压缩与解压"></a>📦 压缩与解压</h2><h3 id="tar-命令详解"><a href="#tar-命令详解" class="headerlink" title="tar 命令详解"></a>tar 命令详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基本语法</span><br>tar [选项] [归档文件] [源文件/目录]<br></code></pre></td></tr></table></figure><h3 id="常用选项速查表"><a href="#常用选项速查表" class="headerlink" title="常用选项速查表"></a>常用选项速查表</h3><table><thead><tr><th>选项组</th><th>参数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><strong>操作模式</strong></td><td><code>-c</code></td><td>创建新的归档文件（<strong>c</strong>reate）</td><td><code>tar -cf archive.tar files/</code></td></tr><tr><td></td><td><code>-x</code></td><td>从归档文件中提取内容（<strong>e</strong>x<strong>t</strong>ract）</td><td><code>tar -xf archive.tar</code></td></tr><tr><td></td><td><code>-t</code></td><td>列出归档文件的内容（<strong>t</strong>able of contents）</td><td><code>tar -tf archive.tar</code></td></tr><tr><td><strong>文件格式</strong></td><td><code>-z</code></td><td>通过 gzip 压缩&#x2F;解压缩（<code>.tar.gz</code> 或 <code>.tgz</code>）</td><td><code>tar -czf archive.tar.gz files/</code></td></tr><tr><td></td><td><code>-j</code></td><td>通过 bzip2 压缩&#x2F;解压缩（<code>.tar.bz2</code>）</td><td><code>tar -cjf archive.tar.bz2 files/</code></td></tr><tr><td></td><td><code>-J</code></td><td>通过 xz 压缩&#x2F;解压缩（<code>.tar.xz</code>）</td><td><code>tar -cJf archive.tar.xz files/</code></td></tr><tr><td><strong>文件操作</strong></td><td><code>-f</code></td><td>指定归档文件的名称（<strong>f</strong>ile）</td><td><code>tar -cf archive.tar files/</code></td></tr><tr><td></td><td><code>-v</code></td><td>显示详细的操作过程（<strong>v</strong>erbose）</td><td><code>tar -cvf archive.tar files/</code></td></tr><tr><td></td><td><code>-C</code></td><td>提取时指定目标目录（<strong>C</strong>hange directory）</td><td><code>tar -xf archive.tar -C /target/</code></td></tr><tr><td><strong>高级选项</strong></td><td><code>-p</code></td><td>保留文件的权限和属性（<strong>p</strong>reserve permissions）</td><td><code>tar -cpf archive.tar files/</code></td></tr><tr><td></td><td><code>--exclude</code></td><td>排除特定文件或目录</td><td><code>tar -cf archive.tar --exclude=logs files/</code></td></tr><tr><td></td><td><code>-P</code></td><td>保留绝对路径（<strong>P</strong>reserve absolute path）</td><td><code>tar -cPf archive.tar /absolute/path/</code></td></tr></tbody></table><h3 id="常用压缩解压命令"><a href="#常用压缩解压命令" class="headerlink" title="常用压缩解压命令"></a>常用压缩解压命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩命令</span><br>tar -czf archive.tar.gz directory/     <span class="hljs-comment"># 创建 .tar.gz 压缩包</span><br>tar -cjf archive.tar.bz2 directory/    <span class="hljs-comment"># 创建 .tar.bz2 压缩包</span><br>tar -cJf archive.tar.xz directory/     <span class="hljs-comment"># 创建 .tar.xz 压缩包</span><br><br><span class="hljs-comment"># 解压命令</span><br>tar -xzf archive.tar.gz                <span class="hljs-comment"># 解压 .tar.gz 文件</span><br>tar -xjf archive.tar.bz2               <span class="hljs-comment"># 解压 .tar.bz2 文件</span><br>tar -xJf archive.tar.xz                <span class="hljs-comment"># 解压 .tar.xz 文件</span><br><br><span class="hljs-comment"># 查看压缩包内容</span><br>tar -tzf archive.tar.gz                <span class="hljs-comment"># 查看 .tar.gz 内容</span><br>tar -tjf archive.tar.bz2               <span class="hljs-comment"># 查看 .tar.bz2 内容</span><br>tar -tJf archive.tar.xz                <span class="hljs-comment"># 查看 .tar.xz 内容</span><br><br><span class="hljs-comment"># 解压到指定目录</span><br>tar -xzf archive.tar.gz -C /target/directory/<br><br><span class="hljs-comment"># 只有gz</span><br>gzip -d 文件名.gz<br><br>gunzip -k file.txt.gz  <span class="hljs-comment"># 解压后保留原文件file.txt.gz</span><br><span class="hljs-comment"># 或</span><br>gzip -dk file.txt.gz<br></code></pre></td></tr></table></figure><hr><h2 id="💡-使用技巧"><a href="#💡-使用技巧" class="headerlink" title="💡 使用技巧"></a>💡 使用技巧</h2><h3 id="记忆口诀"><a href="#记忆口诀" class="headerlink" title="记忆口诀"></a>记忆口诀</h3><ul><li><strong>创建压缩</strong>：<code>-c</code> (create) + <code>-f</code> (file) + 压缩格式</li><li><strong>解压文件</strong>：<code>-x</code> (extract) + <code>-f</code> (file) + 压缩格式</li><li><strong>查看内容</strong>：<code>-t</code> (table) + <code>-f</code> (file) + 压缩格式</li></ul><h3 id="常用组合"><a href="#常用组合" class="headerlink" title="常用组合"></a>常用组合</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 最常用的压缩组合</span><br>tar -czf archive.tar.gz files/         <span class="hljs-comment"># 压缩为 .tar.gz</span><br>tar -xzf archive.tar.gz                <span class="hljs-comment"># 解压 .tar.gz</span><br><br><span class="hljs-comment"># 带详细输出的组合</span><br>tar -czvf archive.tar.gz files/        <span class="hljs-comment"># 压缩时显示详细信息</span><br>tar -xzvf archive.tar.gz               <span class="hljs-comment"># 解压时显示详细信息</span><br></code></pre></td></tr></table></figure><hr><blockquote><p><strong>提示</strong>：使用 <code>tar --help</code> 或 <code>man tar</code> 可以查看完整的命令选项说明。</p></blockquote><h2 id="💡-网络"><a href="#💡-网络" class="headerlink" title="💡 网络"></a>💡 网络</h2><h3 id="查看ip"><a href="#查看ip" class="headerlink" title="查看ip"></a>查看ip</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ip addr</span><br></code></pre></td></tr></table></figure><h2 id="💡-权限"><a href="#💡-权限" class="headerlink" title="💡 权限"></a>💡 权限</h2><p>先用 sudo 获取 root 权限，再以 root 权限执行 su - 命令，最终切换到 root 的 “登录 shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> su -<br></code></pre></td></tr></table></figure><ul><li>sudo（Superuser Do，超级用户执行）是 Linux&#x2F;Unix 系统中权限代理工具，核心作用是：<br>允许普通用户在不需要切换到 root（超级用户）的情况下，临时以 root 或其他指定用户的权限执行命令。</li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>命令</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务项目-报错记录</title>
    <link href="/2025/04/21/java/%E9%A1%B9%E7%9B%AE/%E9%BB%91%E9%A9%AC%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/04/21/java/%E9%A1%B9%E7%9B%AE/%E9%BB%91%E9%A9%AC%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><h5 id="Gateway启动报错"><a href="#Gateway启动报错" class="headerlink" title="Gateway启动报错"></a>Gateway启动报错</h5><p>启动的时候，构造器中找不到对应的类，</p><ul><li>使用命令查看使用到错误类的jar包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plain">mvn dependency:tree -Dincludes=io.projectreactor.netty:reactor-netty<br></code></pre></td></tr></table></figure><ul><li>百度，查找spring微服务之间的版本关系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plain">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E<br></code></pre></td></tr></table></figure><p>最终替换版本解决问题</p><h5 id="Maven中Nacos自动配置依赖引不进来"><a href="#Maven中Nacos自动配置依赖引不进来" class="headerlink" title="Maven中Nacos自动配置依赖引不进来"></a>Maven中Nacos自动配置依赖引不进来</h5><p>一开始没加版本号，上网查了，特定版本的springcloud，需要指定版本号才行，其父pom中没有此依赖版本配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="IDEA启动报错类找不到，但是代码未提示错误"><a href="#IDEA启动报错类找不到，但是代码未提示错误" class="headerlink" title="IDEA启动报错类找不到，但是代码未提示错误"></a>IDEA启动报错类找不到，但是代码未提示错误</h5><p>刷新缓存，mvn idea:idea，重启项目…</p><h5 id="IDEA默认配置"><a href="#IDEA默认配置" class="headerlink" title="IDEA默认配置"></a>IDEA默认配置</h5><ul><li>自动编译</li><li>自动引包</li></ul><p><a href="https://zhuanlan.zhihu.com/p/690391225">【IDEA】idea设置默认maven配置, 避免每次设置maven - 知乎</a></p><h5 id="mvn-idea-idea报错"><a href="#mvn-idea-idea报错" class="headerlink" title="mvn idea:idea报错"></a>mvn idea:idea报错</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">For artifact &#123;io.projectreactor.netty:reactor-netty:nul<span class="hljs-variable">l:jar</span>&#125;: The <span class="hljs-keyword">version</span> cannot <span class="hljs-keyword">be</span> <span class="hljs-built_in">empty</span>. <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>项目</category>
      
      <category>黑马微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务项目-黑马商城</title>
    <link href="/2025/04/21/java/%E9%A1%B9%E7%9B%AE/%E9%BB%91%E9%A9%AC%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/"/>
    <url>/2025/04/21/java/%E9%A1%B9%E7%9B%AE/%E9%BB%91%E9%A9%AC%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="网关-gateway部分"><a href="#网关-gateway部分" class="headerlink" title="网关-gateway部分"></a>网关-gateway部分</h3><p>​todo</p><h3 id="nacos部分"><a href="#nacos部分" class="headerlink" title="nacos部分"></a>nacos部分</h3><h5 id="自动配置报错记录"><a href="#自动配置报错记录" class="headerlink" title="自动配置报错记录"></a>自动配置报错记录</h5><p>配置了bootstrap.yaml文件，指定了nacos中的共享配置，但是，本地启动的时候，<br>报错：spring 加载HikariDataSource的时候，如下代码找不到数据库配置导致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HikariDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> (HikariDataSource)DataSourceConfiguration.createDataSource(properties, HikariDataSource.class);<br></code></pre></td></tr></table></figure><p><strong>为什么？</strong></p><p>​一开始以为是这部分的执行顺序在nacos的自动配置之前。</p><p>​先把数据库配置写了一个必要的url在原始配置文件中，结果能正常启动，查看启动日志，发现后续也启动了bootstrap.yaml，但是跑接口的时候发现，启动并没有把我在nacos中的共享配置加载进来。</p><p>​最后怀疑是我名字没对上，结果还真是，nacos中的配置文件，是我几个月前建立好的共享配置，但是，今天的代码中bootstrap中的共享配置是我直接粘贴的文档内容，还真没对上，需要反省下，看了半个小时。</p><p>后续问题，在第二个模块中，引入如下依赖的时候，没有指定版本号，但是没报错，项目启动不会启动nacos的自动配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>项目</category>
      
      <category>黑马微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署github</title>
    <link href="/2025/04/21/hexo/%E9%83%A8%E7%BD%B2github/"/>
    <url>/2025/04/21/hexo/%E9%83%A8%E7%BD%B2github/</url>
    
    <content type="html"><![CDATA[<h5 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">https</span>://hexo.io/zh-cn/docs/<span class="hljs-literal">one</span>-<span class="hljs-keyword">command</span><span class="hljs-title">-deployment</span>.<span class="hljs-title">html</span><br></code></pre></td></tr></table></figure><ol><li><p>安装工具</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure></li><li><p>编辑**_config.yml**配置文件，前置条件，GitHub中创建对应仓库</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> <span class="hljs-params">&lt;repository url&gt;</span> <span class="hljs-meta"># https:<span class="hljs-comment">//bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span></span><br><span class="hljs-symbol">  branch:</span> [branch]<br><span class="hljs-symbol">  message:</span> [message]<br></code></pre></td></tr></table></figure></li><li><p>执行部署命令</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">hexo <span class="hljs-selector-tag">g</span>（生成）<br>hexo d（上传）<br></code></pre></td></tr></table></figure></li><li><p>访问<a href="https://lzc3.github.io/%E5%8D%B3%E5%8F%AF">https://lzc3.github.io/即可</a></p></li></ol><p>Github创建仓库</p><p>1.仓库名固定格式   [用户名]github.io   例如，lzc3.github.io </p><p>2.仓库需要公开</p><p>3.添加readme</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主题替换</title>
    <link href="/2025/04/20/hexo/%E4%B8%BB%E9%A2%98%E6%9B%BF%E6%8D%A2/"/>
    <url>/2025/04/20/hexo/%E4%B8%BB%E9%A2%98%E6%9B%BF%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h5 id="GitHub地址"><a href="#GitHub地址" class="headerlink" title="GitHub地址"></a>GitHub地址</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">https</span>://github.com/fluid-dev/hexo-theme-fluid?<span class="hljs-literal">tab</span>=readme-ov-<span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><h5 id="用户手册"><a href="#用户手册" class="headerlink" title="用户手册"></a>用户手册</h5><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">https:</span>//hexo.fluid-dev.com/docs/guide/#<span class="hljs-variable">%E5</span><span class="hljs-variable">%85</span><span class="hljs-variable">%B3</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%87</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%97</span><br></code></pre></td></tr></table></figure><h5 id="自定义配置修改"><a href="#自定义配置修改" class="headerlink" title="自定义配置修改"></a>自定义配置修改</h5><p>​修改_config.fluid.yml文件内容</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">slogan：<br><span class="hljs-built_in">text</span>：界面主题介绍文字<br></code></pre></td></tr></table></figure><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">navbar:</span><br>blog_title：导航栏左侧文字<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>主题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo</title>
    <link href="/2025/04/20/hexo/use/"/>
    <url>/2025/04/20/hexo/use/</url>
    
    <content type="html"><![CDATA[<h5 id="hexo使用文档"><a href="#hexo使用文档" class="headerlink" title="hexo使用文档"></a>hexo使用文档</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://hexo.io/zh-cn/docs/commands<br></code></pre></td></tr></table></figure><h5 id="新建md文件"><a href="#新建md文件" class="headerlink" title="新建md文件"></a>新建md文件</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">npx hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> <span class="hljs-comment">--path hexo/use &quot;使用hexo&quot;</span><br>npx hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> <span class="hljs-comment">--path hexo/主题替换 &quot;主题替换&quot;</span><br>npx hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> <span class="hljs-comment">--path java/spring/基础知识 &quot;spring基础知识&quot;</span><br>npx hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> <span class="hljs-comment">--path 随笔/数据库三大范式 &quot;数据库三大范式&quot;</span><br>npx hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> <span class="hljs-comment">--path windows/磁盘清理 &quot;磁盘清理&quot;</span><br></code></pre></td></tr></table></figure><h5 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">npx hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">npx hexo s</span><br></code></pre></td></tr></table></figure><h5 id="常用的格式"><a href="#常用的格式" class="headerlink" title="常用的格式"></a>常用的格式</h5><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">categories:<br>  - [Java, spring]<br>  - [Java, 项目]<br><span class="hljs-keyword">tags:</span><br>  - 注解<br>  - 报错<br></code></pre></td></tr></table></figure><h5 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h5><ul><li>在hexo项目根目录下安装上传本地图片插件</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save<br></code></pre></td></tr></table></figure><ul><li>绝对路径引用</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[]</span>(../images/xx.png)<br></code></pre></td></tr></table></figure><ul><li>相对路径本地引用，修改hexo目录下的配置文件_config.yml中</li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/qq_43401552/article/details/104805466">https://blog.csdn.net/qq_43401552/article/details/104805466</a></p><h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><ul><li>区分source下的post、自定义、draft模式</li><li>自定义主题<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid: :ocean: 一款 Material Design 风格的 Hexo 主题 &#x2F; An elegant Material-Design theme for Hexo</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/04/20/hello-world/"/>
    <url>/2025/04/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-number">1</span>.集合<br><span class="hljs-number">2</span>.多线程、<span class="hljs-type">IO</span>、netty<br><span class="hljs-number">3</span>.dubbo框架、<span class="hljs-type">Mybatis</span>框架<br><span class="hljs-number">4</span>.设计模式<br><span class="hljs-number">5</span>.令牌桶<br><span class="hljs-number">6</span>.<span class="hljs-keyword">jvm</span>工具<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
