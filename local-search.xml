<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>异常</title>
    <link href="/2025/05/21/java/%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8/"/>
    <url>/2025/05/21/java/%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="一、关系图"><a href="#一、关系图" class="headerlink" title="一、关系图"></a>一、关系图</h3><div><!--块级封装-->    <center><!--将图片和文字居中-->    <img src="../../../images/java_异常_类关系图.jpg"         alt="图片无法显示"         style="zoom:100%;"/>    <br><!--换行-->    图：Java异常体系结构<!--标题-->    </center></div><h3 id="二、各自含义"><a href="#二、各自含义" class="headerlink" title="二、各自含义"></a>二、各自含义</h3><blockquote><p><strong>Throwable</strong></p></blockquote><p>​Throwable类是 Java 语言中所有错误或异常的超类，只有当对象是此类（或其子类之一）的实例时，才能通过 Java 虚拟机或者 Java throw 语句抛出。</p><blockquote><p><strong>Error</strong></p></blockquote><p>​系统错误（System Error) 是由 Java 虚拟机抛出的，用 Error 类表示。Error 类描述的是内部系统错误。这样的错误很少发生。如果发生，除了通知用户以及尽量稳妥地终止程序外，几乎什么也不能做。</p><ul><li>OutOfMemoryError ：内存耗尽</li><li>NoClassDefFoundError ：无法加载某个Class </li><li>StackOverflowError ：栈溢出</li></ul><blockquote><p><strong>Exception</strong></p></blockquote><p>​Exception及其子类(除了RuntimeException)，在编译时期抛出的异常，在编译期间检查程序是否可能会出现问题，如果可能会有，则预先防范：捕获 声明。</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golo">/**<br> * <span class="hljs-keyword">try</span>中<span class="hljs-keyword">return</span>的返回值会被放入局部变量表，假如是基本数据类型，在<span class="hljs-keyword">finally</span>块中修改不会生效 &lt;br/&gt;<br> * <span class="hljs-keyword">finally</span>执行逻辑就是在<span class="hljs-keyword">try</span>快<span class="hljs-keyword">return</span>之前，执行逻辑，假如<span class="hljs-keyword">finally</span>中有<span class="hljs-keyword">return</span>语句，将会直接返回<br> * <br> * <span class="hljs-meta">@return</span> <span class="hljs-keyword">map</span><br> */<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2025/05/20/Git/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2025/05/20/Git/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><h5 id="与远程仓库建立连接"><a href="#与远程仓库建立连接" class="headerlink" title="与远程仓库建立连接"></a>与远程仓库建立连接</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin git@github.com:lzc3/lzc3.git<br></code></pre></td></tr></table></figure><h5 id="拉取项目代码"><a href="#拉取项目代码" class="headerlink" title="拉取项目代码"></a>拉取项目代码</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@xxx<br></code></pre></td></tr></table></figure><h5 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git submodule foreach git branch -D [branch_name]<br></code></pre></td></tr></table></figure><h5 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git submodule foreach git push origin --delete [branch_name]<br></code></pre></td></tr></table></figure><h5 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 使用git add 后<br>git reset HEAD src/main/java/com/xdap/manage/init/InitDatasource.java<br>git reset HEAD .<br><br>// 已经使用git commit提交的了代码，回退上一次commit的状态<br>git reset --hard HEAD^ <br><br>// 还原错误push到远程分支的代码 <br>// git revert 会创建一个新的提交，该提交会撤销指定提交的更改，而不会更改历史记录。适用于需要撤销某次提交，但又不希望修改提交历史的场景。<br>git revert &lt;commit_hash&gt;<br>git push origin &lt;branch_name&gt;<br><br>//git reset + 强制推送<br>git reset --hard &lt;commit_hash&gt;  <span class="hljs-comment"># 重置到某个提交</span><br>git push origin &lt;branch_name&gt; --force<br><br>// git reset --soft 如果你不想丢失文件的修改，而只想重置提交历史，这会将历史回退到某个提交，但保留修改，并将其放入暂存区。<br><br>参考https://www.cnblogs.com/Will-Chang/p/18576714<br></code></pre></td></tr></table></figure><h5 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> submodule foreach git push --set-upstream origin release/papaas-<span class="hljs-number">4</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>-rc-dev6-bak<br></code></pre></td></tr></table></figure><h5 id="工作用"><a href="#工作用" class="headerlink" title="工作用"></a>工作用</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">duoji bugfix start issue-2025042462755 -b release/papaas-4.0.8<br>duoji bugfix start issue-2025031361259 -b papaas-3.2.20-lts<br>duoji bugfix start issue-2025042962925 -b release/papaas-4.1.1<br><br>duoji feature start us-006050 -b release/papaas-4.1.1<br>duoji feature start us-003761-411 -b release/papaas-4.0.8<br><br>duoji ka start chervon -t v4.0.8-rc-20240927.1<br>duoji bugfix start issue-2025012459729 -b ka/papaas-3.2.19.7-jlqc<br><br>git defineflow utils delete branch ka/papaas-4.1.1-4.1.1-wej<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
      <category>常用命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arthas篇</title>
    <link href="/2025/05/20/java/arthas/"/>
    <url>/2025/05/20/java/arthas/</url>
    
    <content type="html"><![CDATA[<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><ul><li>wget下载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://arthas.aliyun.com/arthas-boot.jar<br></code></pre></td></tr></table></figure><ul><li>端口冲突解决</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">pid=1 ;\<br><span class="hljs-built_in">touch</span> /proc/<span class="hljs-variable">$&#123;pid&#125;</span>/cwd/.attach_pid<span class="hljs-variable">$&#123;pid&#125;</span> &amp;&amp; \<br>  <span class="hljs-built_in">kill</span> -SIGQUIT <span class="hljs-variable">$&#123;pid&#125;</span> &amp;&amp; \<br>  <span class="hljs-built_in">sleep</span> 2 &amp;&amp;<br>  <span class="hljs-built_in">ls</span> /proc/<span class="hljs-variable">$&#123;pid&#125;</span>/root/tmp/.java_pid<span class="hljs-variable">$&#123;pid&#125;</span><br><br>watch org.artofsolving.jodconverter.AbstractConversionTask getStoreProperties <span class="hljs-string">&#x27;&#123;returnObj&#125;&#x27;</span>  -n 5  -x 5<br></code></pre></td></tr></table></figure><h5 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h5><ul><li>params过滤</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">watch com<span class="hljs-selector-class">.xdap</span><span class="hljs-selector-class">.processapi</span><span class="hljs-selector-class">.ProcessQueryOperate</span> queryProcInstanceByDocId <span class="hljs-string">&#x27;&#123;params,returnObj&#125;&#x27;</span> <span class="hljs-string">&#x27;params[0].contains(&quot;xxx&quot;)&#x27;</span> -n <span class="hljs-number">5</span>  -<span class="hljs-attribute">x</span> <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><ul><li>returnObj过滤</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">watch com<span class="hljs-selector-class">.definesys</span><span class="hljs-selector-class">.mpaas</span><span class="hljs-selector-class">.query</span><span class="hljs-selector-class">.MpaasQuery</span> buildQuerySql <span class="hljs-string">&#x27;&#123;returnObj&#125;&#x27;</span> <span class="hljs-string">&#x27;returnObj.contains(&quot;distinct xu.phone&quot;)&#x27;</span> -n <span class="hljs-number">10</span>  -<span class="hljs-attribute">x</span> <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><h5 id="删除多余的arthas进程"><a href="#删除多余的arthas进程" class="headerlink" title="删除多余的arthas进程"></a>删除多余的arthas进程</h5><ul><li>查找所有Arthas进程的PID</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> arthas<br></code></pre></td></tr></table></figure><ul><li>假设你找到了一个不需要的进程的PID，例如12345，使用kill命令关闭它</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kill</span> <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>arthas</category>
      
    </categories>
    
    
    <tags>
      
      <tag>arthas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker篇</title>
    <link href="/2025/05/20/docker/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2025/05/20/docker/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="打镜像"><a href="#打镜像" class="headerlink" title="打镜像"></a>打镜像</h5><ul><li><p>-t 标签 </p></li><li><p>. 当前目录</p></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> build -t keking/kkfileview:v4.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> -f miss-Dockerfile .<br><br><span class="hljs-attribute">REPOSITORY</span>          TAG       IMAGE ID       CREATED         SIZE<br><span class="hljs-attribute">keking</span>/kkfileview   v4.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>    <span class="hljs-number">49067017</span>aaf1   <span class="hljs-number">8</span> minutes ago   <span class="hljs-number">1</span>.<span class="hljs-number">59</span>GB<br></code></pre></td></tr></table></figure><h5 id="打tag"><a href="#打tag" class="headerlink" title="打tag"></a>打tag</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> tag keking/kkfileview:v4.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> keking/kkfileview:<span class="hljs-number">20250325</span><br></code></pre></td></tr></table></figure><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> ps<br><span class="hljs-attribute">docker</span> stop <span class="hljs-number">0699</span>d8e34ce9<br><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">8012</span>:<span class="hljs-number">8012</span> -v /data:/data -d hub.dfy.definesys.cn/common/kkfileview:<span class="hljs-number">20240723</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">8012</span>:<span class="hljs-number">8012</span> -v /data:/data -d keking/kkfileview:v4.<span class="hljs-number">0</span>.<span class="hljs-number">14</span><br><span class="hljs-attribute">docker</span> exec -it <span class="hljs-number">4</span>ca043c2068b sh<br></code></pre></td></tr></table></figure><h5 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h5><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">// 认证私有docker<br>docker pull hub.dfy.definesys.cn/common/kkfileview:20240723.1<br><span class="hljs-keyword">Error </span>response from daemon: unauthorized: access to the requested resource is not authorized<br><br>// 登录、拉镜像<br>docker login hub.dfy.definesys.cn<br>docker pull hub.dfy.definesys.cn/common/kkfileview:20240723.1<br></code></pre></td></tr></table></figure><h5 id="导出本地镜像"><a href="#导出本地镜像" class="headerlink" title="导出本地镜像"></a>导出本地镜像</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">docker save -o <span class="hljs-selector-attr">[导出镜像文件名]</span><span class="hljs-selector-class">.tar</span> <span class="hljs-selector-attr">[本地镜像]</span><br></code></pre></td></tr></table></figure><h5 id="获取命名空间下pod"><a href="#获取命名空间下pod" class="headerlink" title="获取命名空间下pod"></a>获取命名空间下pod</h5><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">kubectl <span class="hljs-built_in">get</span> pods -n apaas<br>kubectl exec -it -n apaas xdap-app-dingxuewei01-nkjx-<span class="hljs-number">749b987974</span>-4xnm4 bash<br></code></pre></td></tr></table></figure><h5 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">docker logs -f <span class="hljs-attr">--tail</span>=<span class="hljs-number">100</span> <span class="hljs-selector-attr">[id]</span>/<span class="hljs-selector-attr">[name]</span><br></code></pre></td></tr></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 删除镜像</span><br>docker rmi <span class="hljs-symbol">$</span>(docker images | grep <span class="hljs-string">&quot;apaas&quot;</span>) --force <br><br><span class="hljs-comment">// 依稀记得id和name都可以，待测试</span><br>docker rm [id]/[name]<br><br><span class="hljs-comment">// 删除未使用的 Docker 资源，包括：</span><br><span class="hljs-comment">// 停止的容器（已停止但未删除的容器）</span><br><span class="hljs-comment">// 悬空镜像（dangling images，即无标签的镜像层）</span><br><span class="hljs-comment">// 未使用的网络（未被任何容器引用的网络）</span><br><span class="hljs-comment">// 构建缓存（build cache，通过 docker build 生成的临时层）</span><br>docker <span class="hljs-keyword">system</span> prune<br></code></pre></td></tr></table></figure><h5 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">kubectl cp 命名空间<span class="hljs-regexp">/POD名:/</span>路径<span class="hljs-regexp">/文件名 /</span>本地路径/文件名<br><br><span class="hljs-regexp">//</span> -r 递归复制目录<br>kubectl cp -r <span class="hljs-regexp">/本地路径/</span>文件名 命名空间<span class="hljs-regexp">/POD名:/</span>路径/文件名<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
      <category>常用命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqlserver篇</title>
    <link href="/2025/05/20/java/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlserver/"/>
    <url>/2025/05/20/java/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlserver/</url>
    
    <content type="html"><![CDATA[<h3 id="类型不匹配问题"><a href="#类型不匹配问题" class="headerlink" title="类型不匹配问题"></a>类型不匹配问题</h3><blockquote><p>记录一些类型不匹配导致的sql报错</p></blockquote><h5 id="其余类型-字符串-field1-in-“xxx”"><a href="#其余类型-字符串-field1-in-“xxx”" class="headerlink" title="其余类型-&gt;字符串 field1 in (“xxx”)"></a>其余类型-&gt;字符串 field1 in (“xxx”)</h5><p>​形如 field1 in (“xxx”)，其中，xxx为字符串不是数字的话，就会报错</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> QUERY <span class="hljs-keyword">AS</span> (<br><span class="hljs-keyword">SELECT</span><br>inner_query.<span class="hljs-operator">*</span>,<br><span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> ( <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> ) <span class="hljs-operator">-</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> query_num <br><span class="hljs-keyword">FROM</span><br>(<br><span class="hljs-keyword">SELECT</span><br>dbo.sql_server_srp.form_id <span class="hljs-keyword">AS</span> &quot;formId&quot;,<br>dbo.sql_server_srp.OWNER <span class="hljs-keyword">AS</span> &quot;owner&quot;,<br>dbo.sql_server_srp.last_updated_by <span class="hljs-keyword">AS</span> &quot;lastUpdatedBy&quot;,<br>dbo.sql_server_srp.last_update_date <span class="hljs-keyword">AS</span> &quot;lastUpdateDate&quot;,<br>dbo.sql_server_srp.creation_date <span class="hljs-keyword">AS</span> &quot;creationDate&quot;,<br>dbo.sql_server_srp.tab_doc_id <span class="hljs-keyword">AS</span> &quot;tabDocId&quot;,<br>dbo.sql_server_srp.field1 <span class="hljs-keyword">AS</span> &quot;a8e04fd2bee82fb927a5a8a7&quot;,<br>dbo.sql_server_srp.created_by <span class="hljs-keyword">AS</span> &quot;createdBy&quot;,<br>dbo.sql_server_srp.process_id <span class="hljs-keyword">AS</span> &quot;processId&quot;,<br>dbo.sql_server_srp.document_id <span class="hljs-keyword">AS</span> &quot;documentId&quot;,<br>dbo.sql_server_srp.id <span class="hljs-keyword">AS</span> &quot;id&quot;,<br>dbo.sql_server_srp.approver_id <span class="hljs-keyword">AS</span> &quot;approverList&quot;,<br>dbo.sql_server_srp.STATUS <span class="hljs-keyword">AS</span> &quot;status&quot; <br><span class="hljs-keyword">FROM</span><br>dbo.sql_server_srp <br><span class="hljs-keyword">WHERE</span><br>(<br>sql_server_srp.field2 <span class="hljs-keyword">IN</span> ( <span class="hljs-string">&#x27;asdas&#x27;</span> ))) inner_query <br>) <span class="hljs-keyword">SELECT</span><br><span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span><br>QUERY <br><span class="hljs-keyword">WHERE</span><br>query_num <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span> <br><span class="hljs-keyword">AND</span> query_num <span class="hljs-operator">&lt;</span> <span class="hljs-number">1</span><br>[<span class="hljs-number">42000</span>] [Microsoft][ODBC Driver <span class="hljs-number">17</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">SQL</span> Server][<span class="hljs-keyword">SQL</span> Server]Error converting data type <span class="hljs-type">varchar</span> <span class="hljs-keyword">to</span> bigint. (<span class="hljs-number">8114</span>)<br></code></pre></td></tr></table></figure><h3 id="查询删除插入"><a href="#查询删除插入" class="headerlink" title="查询删除插入"></a>查询删除插入</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs txt">SELECT table_name FROM information_schema.tables<br>WHERE table_type = &#x27;BASE TABLE&#x27;<br>AND table_catalog = &#x27;master&#x27;;  -- 替换为你的数据库名称<br><br><br>SELECT * FROM master.dbo.prod_info_server_relatedtable;<br><br><br>SELECT * FROM master.dbo.prod_info_server;<br><br>DELETE FROM master.dbo.prod_info_server;<br><br>INSERT INTO master.dbo.prod_info_server ([prod_id], [prod_name], [prod_price], [prod_name1]) VALUES (1, N&#x27;水杯&#x27;, 50, NULL);<br>INSERT INTO master.dbo.prod_info_server ([prod_id], [prod_name], [prod_price], [prod_name1]) VALUES (2, N&#x27;笔&#x27;, 2, NULL);<br>INSERT INTO master.dbo.prod_info_server ([prod_id], [prod_name], [prod_price], [prod_name1]) VALUES (3, N&#x27;键盘&#x27;, 500, NULL);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>sqlserver</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sqlserver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongo篇</title>
    <link href="/2025/05/20/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/"/>
    <url>/2025/05/20/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/</url>
    
    <content type="html"><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h5 id="命令行下的操作"><a href="#命令行下的操作" class="headerlink" title="命令行下的操作"></a><strong>命令行下的操作</strong></h5><ul><li>进入mongo</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mongo">mongo --host 172.27.4.216 --port 37017 --username admin --password apaas2021 <br></code></pre></td></tr></table></figure><ul><li>查看&#x2F;使用数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mongo">// 进入对应库<br>use xdap_app_505331235694837761;<br>// 查看当前库<br>db;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>mongo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mongo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oracle篇</title>
    <link href="/2025/05/20/java/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle/"/>
    <url>/2025/05/20/java/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle/</url>
    
    <content type="html"><![CDATA[<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>Oracle数据库在12.1版本及以前，对象名（包括表名和列名）的长度限制为30个字符。‌</p><p>​这一限制在Oracle 12.2版本之后得到了调整，对象名的长度限制从30个字节增加到了128个字节，从而允许用户创建更长的对象名，以满足更复杂的数据库设计需求。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> version <span class="hljs-keyword">FROM</span> v$instance;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oracle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生产消息重复问题</title>
    <link href="/2025/05/18/%E9%9A%8F%E7%AC%94/%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98/"/>
    <url>/2025/05/18/%E9%9A%8F%E7%AC%94/%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="客户消息发送重复问题"><a href="#客户消息发送重复问题" class="headerlink" title="客户消息发送重复问题"></a>客户消息发送重复问题</h1><h1 id="特殊Bug记录"><a href="#特殊Bug记录" class="headerlink" title="特殊Bug记录"></a>特殊Bug记录</h1><h2 id="1、客户生产收到了重复消息"><a href="#1、客户生产收到了重复消息" class="headerlink" title="1、客户生产收到了重复消息"></a>1、客户生产收到了重复消息</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​客户提交了一个bug，问题是升级版本后，执行的某个事件，推送消息变成了两条。</p><p>​先说结论，是一次非空判断的遗漏导致了全表数据查询，然后查出了全表数据，对全表数据进行了循环发送mq消息。</p><h4 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h4><ul><li><p>分析执行流程</p><p>执行过程如下，重点关注两种类型，一是发送Mq的过程，二是可能会重复的地方，比如for循环</p><blockquote><p>提交数据触发事件埋点<br>发送Mq执行业务事件<br>业务事件执行完毕后，事件框架推送发送消息<br>消息事件执行，触发Mq实际发送数据<br>消费者执行具体消息 </p></blockquote></li><li><p>分析重复消息记录</p><p>在数据库分析对比两条数据的创建时间，发现消息重复几百次，而且不止一条消息重复。</p></li><li><p>分析Mq执行的过程及状态</p><p>拉取了日志，消息在消费者这边是正常消费，同时，Mq中对应队列状态也正常。</p></li><li><p>分析代码逻辑</p><p>重点关注几个for循环地方，在发版期间无代码改动。</p></li><li><p>分析数据库消息表，</p><p>根据最新消息唯一标识继续查询，消息还在持续不断重复中。</p></li><li><p>继续结合日志分析Mq</p><p>查看Mq对应队列以及消费者pod日志，在不断接收来自Mq的消息。</p><p>查看生产者pod日志，发现无消息推送记录</p><p>排除消息确认机制影响，消费端无报错、生产者无重复推送记录</p></li></ul><p>结论：消息消费者一直在不断消费Mq发送消息，这些消息和客户说明的操作无关系，有可能是其他应用的操作引起的。</p><h4 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h4><ul><li><strong>定位pod</strong></li></ul><p>​   首先，一个一个去应用的pod中查看日志，看哪些应用在对应时刻有发送对应mq的记录，只有一个应用在不断发送mq消息。</p><ul><li><strong>找到不断发送消息的地方</strong></li></ul><p>  消息发送上层有很多调用，使用arthas抓取发送消息的上层调用链路，分析后都是同一个调用链路。</p><p>​   重点关注哪个地方开始重复的，继续使用arthas监听，最终是在一个for循环处，对查出来的documentId列表进行遍历，不断发送消息。结合日志，找到这个for循环对应的事件id，去数据库中找到名字。</p><ul><li><strong>分析此事件</strong></li></ul><p>​查看事件执行记录，入参为空，代码中间某段逻辑处查出了表的全部数据。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>难点：</p><ul><li>客户业务复杂，提供的信息不准确</li><li>表单操作、执行事件、发送系统消息执行链路长</li><li>日志体积大、刷新频率高，客户正在使用，具体排查困难</li></ul><p>学到了什么：</p><ul><li><p>Arthas监听调用栈</p></li><li><p>Mq如果不指定确认策略默认自动开启消费者确认</p></li><li><p>消息发送的时候，最好加个参数，指明消息来源</p></li></ul><h2 id="2、日期保存后-1"><a href="#2、日期保存后-1" class="headerlink" title="2、日期保存后+1"></a>2、日期保存后+1</h2><p>输入时间为：2025-04-04 08:03:02</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-comment">// 前置条件，设置默认时区</span><br>TimeZone.setDefault(TimeZone.getTimeZone(<span class="hljs-string">&quot;America/New_York&quot;</span>));<br><br><span class="hljs-built_in">String</span> s = <span class="hljs-string">&quot;2025-04-04 08:03:02&quot;</span>;<br><span class="hljs-comment">// 按照指定格式格式化日期</span><br>SimpleDateFormat dateTimeFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br><span class="hljs-comment">// 此时date为 Fri Apr 04 08:03:02 EDT 2025</span><br><span class="hljs-built_in">Date</span> <span class="hljs-built_in">date</span> = dateTimeFormat.parse(s)<br><br><span class="hljs-comment">// 转东八区</span><br><span class="hljs-built_in">date</span>.setTime(<span class="hljs-built_in">date</span>.getTime() + xx);<br><br><span class="hljs-comment">// 2025-04-04 21:03:02</span><br><span class="hljs-built_in">Object</span> o = dateTimeFormat.format(<span class="hljs-built_in">date</span>)<br><br><span class="hljs-comment">// afterParseDate值变成了Fri Apr 04 09:03:02 EDT 2025</span><br>dateTimeFormat.setTimeZone(TimeZone.getTimeZone(<span class="hljs-string">&quot;GMT+8&quot;</span>));<br>afterParseDate = dateTimeFormat.parse(<span class="hljs-built_in">String</span>.valueOf(o));<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Fri</span> Apr <span class="hljs-number">04</span> <span class="hljs-number">09</span>:<span class="hljs-number">03</span>:<span class="hljs-number">02</span> EDT <span class="hljs-number">2025</span><br><br><span class="hljs-attribute">String</span> timeZoneId = <span class="hljs-string">&quot;GMT&quot;</span> + timezone;<br><span class="hljs-attribute">TimeZone</span> timeZone = TimeZone.getTimeZone(timeZoneId);<br><span class="hljs-attribute">sdf</span>.setTimeZone(timeZone);<br></code></pre></td></tr></table></figure><p>mysql的datetime字段</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
      <category>生产消息重复问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生产消息重复问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串</title>
    <link href="/2025/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2025/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><h3 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h3><h5 id="2025-5-15-字符串转换后的长度-II"><a href="#2025-5-15-字符串转换后的长度-II" class="headerlink" title="2025&#x2F;5&#x2F;15 字符串转换后的长度 II"></a>2025&#x2F;5&#x2F;15 字符串转换后的长度 II</h5>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>id生成算法</title>
    <link href="/2025/05/14/java/%E5%9F%BA%E7%A1%80/id%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/"/>
    <url>/2025/05/14/java/%E5%9F%BA%E7%A1%80/id%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>1位：固定为0，保证id为正数</p><p>41位时间戳：可以表示69年范围，毫秒级别精度</p><p>10位工作ID：支持1024台机器，保证分布式唯一性</p><p>12位序列号：每毫秒可生成4096个ID，提高并发能力</p><h3 id="时钟回拨"><a href="#时钟回拨" class="headerlink" title="时钟回拨"></a>时钟回拨</h3><ul><li>机器之间存在误差，不同服务器同步时间</li><li>人工修改时间，手动调整系统时钟造成时间错误</li></ul><p>后果：雪花算法使用了较小的时间戳，序列号重新从0开始计算，生成重复ID</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><ul><li>暂停服务直到时钟恢复正常</li><li>备用时钟源，使用其他服务器或者网络时间服务</li><li>序列号扩展，回拨期间临时添加序列号位数</li><li>时间戳记录，记录上次生成ID的时间戳，如果发现时间戳变小，就抛出异常。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>id生成算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO</title>
    <link href="/2025/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/IO/"/>
    <url>/2025/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/IO/</url>
    
    <content type="html"><![CDATA[<h2 id="DMA和零拷贝"><a href="#DMA和零拷贝" class="headerlink" title="DMA和零拷贝"></a>DMA和零拷贝</h2><h3 id="传统磁盘IO流程"><a href="#传统磁盘IO流程" class="headerlink" title="传统磁盘IO流程"></a>传统磁盘IO流程</h3><p>过程：</p><table><thead><tr><th>用户</th><th>CPU</th><th>磁盘</th></tr></thead><tbody><tr><td>read请求</td><td>用户态转换成内核态</td><td>向磁盘发起IO请求，磁盘开始准备数据</td></tr><tr><td></td><td></td><td>磁盘准备数据完毕，向CPU发起IO中断</td></tr><tr><td></td><td>cpu将磁盘中的数据拷贝到内核区</td><td></td></tr><tr><td></td><td>cpu将内核区中的数据拷贝到用户区</td><td></td></tr><tr><td></td><td>内核态转换成用户态</td><td></td></tr></tbody></table><p>流程图如下</p><p><img src="/../../images/IO_%E4%BC%A0%E7%BB%9FIO.png"></p><ul><li>用户进程调用read操作，CPU收到指令后，发出对应的指令给磁盘控制器，然后返回</li><li>磁盘控制器收到指令后，开始准备数据，把数据放入到磁盘控制器的内部缓冲区，然后产生一个中断。</li><li>CPU收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后将寄存器中的数据写入到内存，而在数据传输期间CPU是无法执行其他任务的。</li></ul><p>两次状态切换，两次CPU拷贝</p><h3 id="加一层DMA-Direct-Memory-Access"><a href="#加一层DMA-Direct-Memory-Access" class="headerlink" title="加一层DMA(Direct Memory Access)"></a>加一层DMA(Direct Memory Access)</h3><p>直接内存访问：允许外部设备直接读写内存，既不通过CPU，也不需要CPU干预。</p><p>主存和DMA控制器之间有一条数据通路，因此主存和I&#x2F;O设备之间交换信息时，不通过CPU。在数据块传送时，主存地址的确定、传送数据的计数等都由外设的硬件电路直接实现。主存中要开辟专用缓冲区，及时供给和接收外设的数据。</p><p>如下图：</p><p><img src="/../../images/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0_DMA.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2025/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
    <url>/2025/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>​其数数据结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode next;<br>    ListNode() &#123;&#125;<br>    ListNode(<span class="hljs-type">int</span> val) &#123; <span class="hljs-built_in">this</span>.val = val; &#125;<br>    ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123; <span class="hljs-built_in">this</span>.val = val; <span class="hljs-built_in">this</span>.next = next; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote><p>todo</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper</title>
    <link href="/2025/05/10/java/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/"/>
    <url>/2025/05/10/java/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/</url>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2025/05/10/java/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMq/"/>
    <url>/2025/05/10/java/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMq/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录下RabbitMQ 学习过程中的关键知识点</p></blockquote><h3 id="消息队列基本特性"><a href="#消息队列基本特性" class="headerlink" title="消息队列基本特性"></a>消息队列基本特性</h3><h4 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h4><blockquote><p>业务场景上无可避免的会出现业务被重复执行的情况，尽可能保证执行一次或者多次对业务状态的影响是一致的</p></blockquote><ul><li>页面卡顿</li><li>服务重试</li><li>MQ重复投递</li></ul><p>如何保证幂等性？</p><h5 id="唯一消息ID"><a href="#唯一消息ID" class="headerlink" title="唯一消息ID"></a>唯一消息ID</h5><p>每条消息都生成一个唯一的id，与消息一起投递给消费者。</p><p>消费者处理业务时，对此id进行持久化，下次再收到重复的消息，就可以通过持久化数据识别出来。</p><p>SpringAMQP自带了id功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">messageConverter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 1.定义消息转换器</span><br>    <span class="hljs-type">Jackson2JsonMessageConverter</span> <span class="hljs-variable">jjmc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>    <span class="hljs-comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span><br>    jjmc.setCreateMessageIds(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> jjmc;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="业务判断"><a href="#业务判断" class="headerlink" title="业务判断"></a>业务判断</h5><p>​比如超时审批时，此时状态已经时同意，就无需继续往下执行，但有可能会出现ABA问题。</p><h3 id="如何保证消息的可靠性"><a href="#如何保证消息的可靠性" class="headerlink" title="如何保证消息的可靠性"></a>如何保证消息的可靠性</h3><h4 id="一、生产者重试机制"><a href="#一、生产者重试机制" class="headerlink" title="一、生产者重试机制"></a>一、生产者重试机制</h4><p>生产者与MQ的网络断开，进行重试</p><blockquote><p>依赖SpringAMQP提供的消息发送时的重试机制，这个过程是阻塞的</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">connection-timeout:</span> <span class="hljs-string">1s</span> <span class="hljs-comment"># 设置MQ的连接超时时间</span><br>    <span class="hljs-attr">template:</span><br>      <span class="hljs-attr">retry:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启超时重试机制</span><br>        <span class="hljs-attr">initial-interval:</span> <span class="hljs-string">1000ms</span> <span class="hljs-comment"># 失败后的初始等待时间</span><br>        <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span><br>        <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 最大重试次数</span><br></code></pre></td></tr></table></figure><h4 id="二、生产者确认机制"><a href="#二、生产者确认机制" class="headerlink" title="二、生产者确认机制"></a>二、生产者确认机制</h4><p>确保消息正确发送到MQ，不会出现以下情况：</p><ul><li>MQ内部处理异常</li><li>找不到交换机</li><li>经过交换机后找不到对应的队列</li></ul><blockquote><p>生产者确认开启后，编写代码处理MQ回执ack、nack</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">correlated</span> <span class="hljs-comment"># 开启publisher confirm机制，并设置confirm类型</span><br>    <span class="hljs-attr">publisher-returns:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启publisher return机制</span><br></code></pre></td></tr></table></figure><p>这里<code>publisher-confirm-type</code>有三种模式可选：</p><ul><li><code>none</code>：关闭confirm机制</li><li><code>simple</code>：同步阻塞等待MQ的回执</li><li><code>correlated</code>：MQ异步回调返回回执</li></ul><ol><li><p>全局配置——定义ReturnCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MqConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        rabbitTemplate.setReturnsCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RabbitTemplate</span>.ReturnsCallback() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(ReturnedMessage returned)</span> &#123;<br>                log.error(<span class="hljs-string">&quot;触发return callback,&quot;</span>);<br>                log.debug(<span class="hljs-string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());<br>                log.debug(<span class="hljs-string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());<br>                log.debug(<span class="hljs-string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());<br>                log.debug(<span class="hljs-string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());<br>                log.debug(<span class="hljs-string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>单次发送消息配置——定义ConfirmCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPublisherConfirm</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.创建CorrelationData</span><br>    <span class="hljs-type">CorrelationData</span> <span class="hljs-variable">cd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>();<br>    <span class="hljs-comment">// 2.给Future添加ConfirmCallback</span><br>    cd.getFuture().addCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable ex)</span> &#123;<br>            <span class="hljs-comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span><br>            log.error(<span class="hljs-string">&quot;send message fail&quot;</span>, ex);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(CorrelationData.Confirm result)</span> &#123;<br>            <span class="hljs-comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span><br>            <span class="hljs-keyword">if</span>(result.isAck())&#123; <span class="hljs-comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span><br>                log.debug(<span class="hljs-string">&quot;发送消息成功，收到 ack!&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// result.getReason()，String类型，返回nack时的异常描述</span><br>                log.error(<span class="hljs-string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason());<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 3.发送消息</span><br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;hmall.direct&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, cd);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="三、MQ的可靠性"><a href="#三、MQ的可靠性" class="headerlink" title="三、MQ的可靠性"></a>三、MQ的可靠性</h4><ul><li><p>交换机、队列持久化</p></li><li><p>消息持久化</p><p><code>消息的持久化是要配置一个properties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendPersistentMessage</span><span class="hljs-params">(String messageContent)</span> &#123;<br>      <span class="hljs-comment">// 创建消息属性</span><br>    <span class="hljs-type">MessageProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageProperties</span>();<br>      <span class="hljs-comment">// 设置消息持久化</span><br>properties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);<br>      <span class="hljs-comment">// 创建消息对象</span><br>   <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(messageContent.getBytes(), properties);<br>      <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.send(<span class="hljs-string">&quot;exchange.persistent&quot;</span>, <span class="hljs-string">&quot;routing.key.persistent&quot;</span>, message);<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>在开启持久化机制以后，如果同时还开启了生产者确认，那么MQ会在消息持久化以后才发送ACK回执，进一步确保消息的可靠性。</p></blockquote><blockquote><p>不过出于性能考虑，为了减少IO次数，发送到MQ的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在100毫秒左右，这就会导致ACK有一定的延迟，因此建议生产者确认全部采用异步方式。</p></blockquote></li><li><p>消息存储方式改变</p><p>默认情况下，MQ会将收到的信息保存在内存中以降低消息收发的延迟</p><p>以下几种情况，会出现消息积压</p><ul><li>消费者宕机、网络断开</li><li>消费者处理速度跟不上</li></ul><p>触发内存预警上线，MQ会将内存消息刷到磁盘上，会阻塞进程队列，为了解决这个问题，MQ3.6版本后添加了Lazy Queues的模式，3.12版本后，默认为LazyQueue格式</p><blockquote><p>Lazy Queues 惰性队列</p><ul><li>收到消息后直接存入磁盘</li><li>消费者需要消息的时候才会从磁盘中读取并加载到内存</li><li>支持百万条消息存储</li></ul></blockquote></li></ul><h4 id="四、消费者的可靠性"><a href="#四、消费者的可靠性" class="headerlink" title="四、消费者的可靠性"></a>四、消费者的可靠性</h4><blockquote><p>消费者处理消息借宿后，向MQ发送回执，回执有以下几种类型</p><ul><li>ack 成功 mq删除消息</li><li>nack 失败 mq需要再次投递消息</li><li>reject 失败并拒绝 mq删除消息</li></ul></blockquote><h5 id="SpringAMQP提供的消息确认模式"><a href="#SpringAMQP提供的消息确认模式" class="headerlink" title="SpringAMQP提供的消息确认模式"></a>SpringAMQP提供的消息确认模式</h5><ul><li>none 不处理</li><li>auto 自动处理 AMQP使用AOP对消息处理逻辑做了增强，正常执行业务时，返回ack，出现业务异常，返回nack，出现消息处理或者校验异常，返回reject</li><li>manual 手动处理</li></ul><h5 id="失败重试机制"><a href="#失败重试机制" class="headerlink" title="失败重试机制"></a>失败重试机制</h5><p>消息不断入队投递，导致无限循环，带来不必要的压力</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">retry:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启消费者失败重试</span><br>          <span class="hljs-attr">initial-interval:</span> <span class="hljs-string">1000ms</span> <span class="hljs-comment"># 初识的失败等待时长为1秒</span><br>          <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span><br>          <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 最大重试次数</span><br>          <span class="hljs-attr">stateless:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span><br></code></pre></td></tr></table></figure><ul><li>消费者在失败后消息没有重新回到MQ无限重新投递，而是在本地重试了3次</li><li>本地重试3次以后，抛出了<code>AmqpRejectAndDontRequeueException</code>异常。查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是<code>reject</code></li></ul><p>死信队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 配置RabbitListenerContainerFactory使用RepublishMessageRecoverer</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SimpleRabbitListenerContainerFactory <span class="hljs-title function_">rabbitListenerContainerFactory</span><span class="hljs-params">(</span><br><span class="hljs-params">            ConnectionFactory connectionFactory,</span><br><span class="hljs-params">            RepublishMessageRecoverer republishMessageRecoverer)</span> &#123;<br>        <span class="hljs-type">SimpleRabbitListenerContainerFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRabbitListenerContainerFactory</span>();<br>        factory.setConnectionFactory(connectionFactory);<br>        <span class="hljs-comment">// 设置消息重试策略</span><br>        factory.setRetryTemplate(retryTemplate()); <br>        <span class="hljs-comment">// 设置消息恢复器 - 重试失败后将消息发送到死信队列</span><br>        factory.setRecoveryCallback(republishMessageRecoverer);<br>        <span class="hljs-comment">// 设置手动确认模式</span><br>        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);<br>        <span class="hljs-keyword">return</span> factory;<br>    &#125;<br><br>    <span class="hljs-comment">// 配置重试模板</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RetryTemplate <span class="hljs-title function_">retryTemplate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SimpleRetryPolicy</span> <span class="hljs-variable">retryPolicy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRetryPolicy</span>();<br>        retryPolicy.setMaxAttempts(<span class="hljs-number">3</span>); <span class="hljs-comment">// 最多重试3次</span><br>        <span class="hljs-type">ExponentialBackOffPolicy</span> <span class="hljs-variable">backOffPolicy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackOffPolicy</span>();<br>        backOffPolicy.setInitialInterval(<span class="hljs-number">500</span>); <span class="hljs-comment">// 初始重试间隔500毫秒</span><br>        backOffPolicy.setMultiplier(<span class="hljs-number">2.0</span>); <span class="hljs-comment">// 每次重试间隔加倍</span><br>        backOffPolicy.setMaxInterval(<span class="hljs-number">10000</span>); <span class="hljs-comment">// 最大重试间隔10秒</span><br>        <span class="hljs-type">RetryTemplate</span> <span class="hljs-variable">retryTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RetryTemplate</span>();<br>        retryTemplate.setRetryPolicy(retryPolicy);<br>        retryTemplate.setBackOffPolicy(backOffPolicy);<br>        <span class="hljs-keyword">return</span> retryTemplate;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="五、兜底方案"><a href="#五、兜底方案" class="headerlink" title="五、兜底方案"></a>五、兜底方案</h4><p>​消费端可以根据自己的业务逻辑，主动去查询业务信息进行操作。</p><h3 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h3><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.config;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.*;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br><br>    <span class="hljs-comment">// 定义延迟交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">delayExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;delay.exchange&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义死信交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">deadLetterExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;deadletter.exchange&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义延迟队列 - 配置死信交换机和路由键</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">delayQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(<span class="hljs-string">&quot;delay.queue&quot;</span>)<br>                .withArgument(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, <span class="hljs-string">&quot;deadletter.exchange&quot;</span>)<br>                .withArgument(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;deadletter.routing.key&quot;</span>)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-comment">// 定义死信队列</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">deadLetterQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;deadletter.queue&quot;</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定延迟队列到延迟交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">delayBinding</span><span class="hljs-params">(Queue delayQueue, DirectExchange delayExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(delayQueue).to(delayExchange).with(<span class="hljs-string">&quot;delay.routing.key&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定死信队列到死信交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">deadLetterBinding</span><span class="hljs-params">(Queue deadLetterQueue, DirectExchange deadLetterExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(deadLetterQueue).to(deadLetterExchange).with(<span class="hljs-string">&quot;deadletter.routing.key&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快捷键-配置合集</title>
    <link href="/2025/05/09/%E5%BF%AB%E6%8D%B7%E9%94%AE-%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/05/09/%E5%BF%AB%E6%8D%B7%E9%94%AE-%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h3><blockquote><p>idea快捷键设置如下</p></blockquote><p><img src="/../images/%E5%BF%AB%E6%8D%B7%E9%94%AE_IDEA_%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%BE%E7%BD%AE.png"></p><h5 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ctrl</span> + alt + l<br></code></pre></td></tr></table></figure><h5 id="插入空行"><a href="#插入空行" class="headerlink" title="插入空行"></a>插入空行</h5><ul><li>向上插入空行</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ctrl</span> + alt + enter<br></code></pre></td></tr></table></figure><ul><li>向下插入空行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">shift</span> + enter<br></code></pre></td></tr></table></figure><h5 id="处理多行"><a href="#处理多行" class="headerlink" title="处理多行"></a>处理多行</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ctrl + <span class="hljs-built_in">shift</span> + alt + 鼠标左键选中<br></code></pre></td></tr></table></figure><h5 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">shift <span class="hljs-literal">tab</span><br></code></pre></td></tr></table></figure><h5 id="复制当前行到下一行"><a href="#复制当前行到下一行" class="headerlink" title="复制当前行到下一行"></a>复制当前行到下一行</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ctrl</span> + d<br></code></pre></td></tr></table></figure><h5 id="查找最近打开的文件"><a href="#查找最近打开的文件" class="headerlink" title="查找最近打开的文件"></a>查找最近打开的文件</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ctrl</span> + e<br></code></pre></td></tr></table></figure><h5 id="提示代码"><a href="#提示代码" class="headerlink" title="提示代码"></a>提示代码</h5><ul><li>按下这个组合键后，补全范围会更广泛，不仅包含自动补全的内容，还会有一些不太常用的类、方法或者变量。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ctrl</span> + 空格<br></code></pre></td></tr></table></figure><ul><li>提示代码，在输入代码时可以提示快捷键</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ctrl</span> + j<br></code></pre></td></tr></table></figure><ul><li>快速提示完成，在代码存在语法问题时，IDEA 会提示使用该快捷键自动修正语法</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">alt</span> + enter<br></code></pre></td></tr></table></figure><h5 id="显示类结构图（类的继承层次）"><a href="#显示类结构图（类的继承层次）" class="headerlink" title="显示类结构图（类的继承层次）"></a>显示类结构图（类的继承层次）</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ctrl</span> + h（Hierarhcy层级）<br></code></pre></td></tr></table></figure><h5 id="定位到代码块开始或者结束位置"><a href="#定位到代码块开始或者结束位置" class="headerlink" title="定位到代码块开始或者结束位置"></a>定位到代码块<code>开始</code>或者<code>结束</code>位置</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ctrl</span> +<span class="hljs-meta"> [   </span><br><span class="hljs-meta">ctrl + ]</span><br></code></pre></td></tr></table></figure><h5 id="快速定位源码，将光标放在方法上输入Ctrl-B-可以去到该方法的源码"><a href="#快速定位源码，将光标放在方法上输入Ctrl-B-可以去到该方法的源码" class="headerlink" title="快速定位源码，将光标放在方法上输入Ctrl + B , 可以去到该方法的源码"></a>快速定位源码，将光标放在方法上输入<code>Ctrl + B </code>, 可以去到该方法的源码</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ctrl + <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><h5 id="快速转到当前类的父类"><a href="#快速转到当前类的父类" class="headerlink" title="快速转到当前类的父类"></a>快速转到当前类的父类</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ctrl</span> + u<br></code></pre></td></tr></table></figure><h5 id="显示当前方法"><a href="#显示当前方法" class="headerlink" title="显示当前方法"></a>显示当前方法</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">alt + <span class="hljs-selector-tag">q</span><br></code></pre></td></tr></table></figure><h5 id="快速切换"><a href="#快速切换" class="headerlink" title="快速切换"></a>快速切换</h5><ul><li>快速打开或隐藏 Project 面板</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Alt</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>快速显示类结构，可以显示类中包含的所有属性和方法</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Alt</span> + <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><ul><li>快速切换代码视图</li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">alt + -&gt;<br>alt + &lt;-<br></code></pre></td></tr></table></figure><ul><li>快速切换方法</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">alt</span> + ↑ / ↓<br></code></pre></td></tr></table></figure><h5 id="将选中的代码使用-if、while、try-catch-等代码块包装起来（功能强大）"><a href="#将选中的代码使用-if、while、try-catch-等代码块包装起来（功能强大）" class="headerlink" title="将选中的代码使用 if、while、try/catch 等代码块包装起来（功能强大）"></a>将选中的代码使用 <code>if、while、try/catch</code> 等代码块包装起来（功能强大）</h5><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ctrl + alt + <span class="hljs-built_in">t</span><br></code></pre></td></tr></table></figure><h3 id="Typora快捷键及配置"><a href="#Typora快捷键及配置" class="headerlink" title="Typora快捷键及配置"></a>Typora快捷键及配置</h3><h5 id="换行后消除格式"><a href="#换行后消除格式" class="headerlink" title="换行后消除格式"></a>换行后消除格式</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">crtl</span> + [ <br></code></pre></td></tr></table></figure><h5 id="修改base显示太长的问题"><a href="#修改base显示太长的问题" class="headerlink" title="修改base显示太长的问题"></a>修改base显示太长的问题</h5><p>去到偏好设置-外观-打开主题文件夹，中找到你使用的样式css,编辑它，在最后一行加入</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.md-def-content</span><span class="hljs-selector-class">.md-def-url</span><span class="hljs-selector-class">.md-auto-disp</span> &#123;<br>    <span class="hljs-comment">/* max-width: 100%; */</span><br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">overflow</span>: hidden <span class="hljs-meta">!important</span>;<br>    <span class="hljs-attribute">white-space</span>: nowrap <span class="hljs-meta">!important</span>;<br>&#125;<br><br><span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.md-image-src-span</span><span class="hljs-selector-class">.ty-focusable</span> &#123;<br>    <span class="hljs-comment">/* display: none; */</span><br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> - <span class="hljs-number">20px</span>);<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">overflow</span>: hidden <span class="hljs-meta">!important</span>;<br>    <span class="hljs-attribute">white-space</span>: nowrap <span class="hljs-meta">!important</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Window快捷键"><a href="#Window快捷键" class="headerlink" title="Window快捷键"></a>Window快捷键</h3><h5 id="前进"><a href="#前进" class="headerlink" title="前进"></a>前进</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">crtl + <span class="hljs-attribute">y</span><br></code></pre></td></tr></table></figure><h4 id="Vscode"><a href="#Vscode" class="headerlink" title="Vscode"></a>Vscode</h4><h5 id="多行选择"><a href="#多行选择" class="headerlink" title="多行选择"></a>多行选择</h5><ul><li>竖列多行选择。先选择起始点，然后按住 Alt + Shift 加上左键按住拖动。</li></ul><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">Alt + <span class="hljs-built_in">Shift</span> + 鼠标左键按住拖动<br></code></pre></td></tr></table></figure><ul><li>为选中的多行代码末尾插入光标</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">Shift + Alt + <span class="hljs-selector-tag">i</span><br></code></pre></td></tr></table></figure><p>🤑😅🌱</p>]]></content>
    
    
    <categories>
      
      <category>快捷键-配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快捷键-配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态代理</title>
    <link href="/2025/05/05/java/%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2025/05/05/java/%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>实现动态代理一般有两种形式，一种方式是通过jdk自带的动态代理实现，通过反射实现，只能对实现接口的类进行代理；另一种方式是通过CGLIB实现，其针对类进实现代理，对指定的类生成一个子类，覆盖其中的方法，不能代理final修饰的类。</p></blockquote><h3 id="jdk自带的动态代理"><a href="#jdk自带的动态代理" class="headerlink" title="jdk自带的动态代理"></a>jdk自带的动态代理</h3><p>先看一个例子</p><ul><li><p>首先，我们有一个接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">DoSomething</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>有一个类实现了该接口</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-title">implements</span> <span class="hljs-title">DoSomething</span> </span>&#123;<br><br>        <span class="hljs-variable">@Override</span><br>        public void doSomething() &#123;<br>            System.out.println(<span class="hljs-string">&quot;drive drive&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>在代码逻辑中，我们new了一个car对象，通过Proxy.newProxyInstance进行代理</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Proxy.newProxyInstance(car.getClass().getClassLoader(), car.getClass().getInterfaces(), <span class="hljs-built_in">new</span> InvocationHandler() &#123;<br>    @Override<br>    <span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> invoke(<span class="hljs-keyword">Object</span> proxy, <span class="hljs-keyword">Method</span> <span class="hljs-keyword">method</span>, <span class="hljs-keyword">Object</span>[] args) throws Throwable &#123;<br>        // 在调用方法前可以添加额外的逻辑<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Before method call.&quot;);<br><br>        // 调用实际对象的方法<br>        <span class="hljs-keyword">Object</span> result = <span class="hljs-keyword">method</span>.invoke(car, args);<br><br>        // 在调用方法后可以添加额外的逻辑<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;After method call.&quot;);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>动态代理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm</title>
    <link href="/2025/05/04/java/%E5%9F%BA%E7%A1%80/jvm/"/>
    <url>/2025/05/04/java/%E5%9F%BA%E7%A1%80/jvm/</url>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新中</p></blockquote><h5 id="jit-即时编译"><a href="#jit-即时编译" class="headerlink" title="jit 即时编译"></a>jit 即时编译</h5><h5 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h5><blockquote><p>栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等。</p><p>而堆只负责存储对象信息。</p></blockquote><ul><li><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据</p></li><li><p>堆解决的是数据存储的问题，即数据怎么放、放在哪儿</p></li></ul><p>为什么要把堆和栈区分？</p><ul><li>从设计的角度来看，栈代表了处理逻辑，而堆代表了数据，这样分开，处理逻辑更为清晰，分而治之的思想，这种隔离、模块化的思想在软件设计的方方面面都有体现。</li><li>堆和栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象），这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式（如共享内存），另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</li><li>栈因为运行时的需要，比如保存系统运行的上下文，需要对地址段划分，由于栈只能<strong>向上增长</strong>，因此就会<strong>限制</strong>住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</li><li>面向对象就是对合栈的完美结合。面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为，就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写了处理数据的逻辑。</li></ul><p>堆中存的是对象，栈中存的是基本数据类型和堆中对象的引用，大小为4byte。</p><p>为什么不把基本类型放在堆中？</p><p>​其占用的内存一般是1~8个字节，需要空间比较少，而且因为是基本类型，所以不会出现动态增长的清空，因此栈中存储就够了，如果把他存在堆中没有什么意义。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据，一个是堆中的数据。最常见的一个问题就是，java中参数传递的问题。</p><h5 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h5><p>按回收策略分类</p><ul><li><p>引用计数</p><ul><li>原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收<br>时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</li></ul></li><li><p>标记 清除</p><ul><li>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的<br>对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</li></ul></li><li><p>复制</p><ul><li>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在<br>使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制<br>过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两<br>倍内存空间。</li></ul></li><li><p>标记-整理</p><ul><li>此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引<br>用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此<br>算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题</li></ul></li></ul><p>按照分区对待的方式分</p><ul><li>增量搜集：实时垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么<br>原因JDK5.0中的收集器没有使用这种算法的。</li><li>分代收集：基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青<br>代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。</li></ul><p>按照系统线程分</p><ul><li>串行收集:串行收集使用单线程处理所有垃圾回收工作，因为无需多线程交互，实现容易，而且效率比较高。但是，其局限性也比较明显，即无法使用多处理器的优势，所以此收集适合单处理器机器。当然，此收集器也可以用在小数据量（100M左右）情况下的多处理器机器上。</li><li>并行收集:并行收集使用多线程处理垃圾回收工作，因而速度快，效率高。而且理论上CPU数目越多，越能体现出并行收集器的优势。</li><li>并发收集:相对于串行收集和并行收集而言，前面两个在进行垃圾回收工作时，需要暂停整个运行环境，而只有垃圾回收程序在运行，因此，系统在垃圾回收时会有明显的暂停，而且暂停时间会因为堆越大而越长。</li></ul><h5 id="为什么要分代"><a href="#为什么要分代" class="headerlink" title="为什么要分代"></a>为什么要分代</h5><p>分代的垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p>试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</p><h5 id="如何分段"><a href="#如何分段" class="headerlink" title="如何分段"></a>如何分段</h5><p>年轻代、年老代和持久代，其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。</p><ul><li><p>年轻代</p><p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p></li><li><p>年老代</p><p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象</p></li><li><p>持久代</p><p>用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize&#x3D;<N>进行设置。</p></li></ul><h5 id="什么时候触发垃圾回收"><a href="#什么时候触发垃圾回收" class="headerlink" title="什么时候触发垃圾回收"></a>什么时候触发垃圾回收</h5><ul><li><p>Scavenge GC<br>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p></li><li><p>Full GC</p><p>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比ScavengeGC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p><p>· 年老代（Tenured）被写满</p><p>· 持久代（Perm）被写满</p><p>· System.gc()被显示调用</p><p>·上一次GC之后Heap的各域分配策略动态变化</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一记</title>
    <link href="/2025/05/03/java/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    <url>/2025/05/03/java/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>代码方面见git，下面只记录一些知识点</p></blockquote><h5 id="2025-5-4"><a href="#2025-5-4" class="headerlink" title="2025&#x2F;5&#x2F;4"></a>2025&#x2F;5&#x2F;4</h5><ul><li><p>互联网项目一般建议单表查询</p><ul><li>单表查询结果更易缓存，多表连接查询的话，每个表的记录都要引起缓存的变动</li><li>后续有变动的时候，我只需要关注一小部分，而不用关注整个查询</li><li>代码复用性高</li><li>占内存，资源的瓶颈在数据库上</li></ul></li><li><p>left join 和 right join有什么区别</p></li><li><p>加了一个联合索引name_phone，分析下这几个sql会走索引吗？</p><ul><li>select * from user where phone &#x3D; “%130” and name &#x3D; “w”</li><li>select * from user where name &#x3D; “w” and phone like “%130”</li><li>select * from user where name like “w%” and phone like “130”</li><li>select * from user where name like “%w%” and phone like “130”</li></ul></li><li><p>怎么计算数据量会占用多大内存，从mysql查出来数据有看过占用多大内存吗</p></li><li><p>java中，线程池中有哪些参数？</p><ul><li>核心线程数：线程池长期保持存活的线程数量</li><li>最大线程数：当任务队列已满，且当前线程数小于 maximumPoolSize 时，线程池会创建新的线程来处理任务，直到达到 maximumPoolSize</li><li>拒绝策略<code>handler</code>：</li><li>workQueue：用于存储待执行任务的阻塞队列。当提交的任务数超过 corePoolSize 时，新任务会被放入这个队列中等待处理。</li><li>等待时间<code>keepAliveTime</code>：线程池中的线程数量超过 corePoolSize 时，多余的空闲线程在被销毁之前等待新任务的最长时间。</li><li>线程池</li></ul></li><li><p>为什么线程池里面要设置一个队列呢？</p></li><li><p>无界队列一直往里面放，是会先达到最大线程数还是会先内存溢出呢？救急线程？</p><ul><li><p>创建救急线程的前提是队列满</p></li><li><p>线程数会一直维持在核心线程数，不会达到最大线程数</p></li><li><p>随着任务持续加入队列，队列会不断占用内存。若任务生成速度远超核心线程处理速度，最终会因队列占用过多内存而导致内存溢出</p></li></ul></li><li><p>mysql执行的很慢，如何排查</p></li><li><p>索引失效的场景</p><ul><li><p>索引列使用了函数</p></li><li><p>使用 OR 导致索引失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">ELECT <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">OR</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">-- 若 b 无索引，全表扫描</span><br><span class="hljs-comment">--MySQL 无法对 OR 条件合并索引。</span><br><span class="hljs-comment">--拆分为 UNION ALL 或为 b 添加索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></li><li><p>模糊查询以 % 开头</p></li><li><p>索引列与查询值类型不一致</p></li><li><p>非等值查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;active&#x27;</span>; <span class="hljs-comment">-- 可能全表扫描</span><br><span class="hljs-comment">-- 非等值操作符难以通过索引快速定位数据</span><br></code></pre></td></tr></table></figure></li><li><p>查询索引列的 <code>NULL</code> 值</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>; <span class="hljs-comment">-- 若 NULL 值极少，可能走索引</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>; <span class="hljs-comment">-- 可能全表扫描</span><br></code></pre></td></tr></table></figure></li><li><p>数据量过小，优化器认为全表扫描比索引更快</p></li><li><p>范围查询后的索引列失效</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 联合索引 (age, name)</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">18</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;John&#x27;</span>; <span class="hljs-comment">-- name 无法使用索引</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>走了索引也很慢，会怎么办</p><p>先判断是不是索引创建的有问题，索引基数小的放在了左边</p><p>是不是没使用覆盖索引，走了回表</p><p>看cpu占用</p><p>看连接数</p></li><li><p>count (*) 和 count（1）有什么区别</p></li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">数据库会将 <span class="hljs-number">1</span> 视为一个常量，作为一个伪列，每行都会生成一个值为 <span class="hljs-number">1</span> 的伪列<br>性能上一般与 COUNT(\*) 接近，但 COUNT<span class="hljs-comment">(*) 在 MySQL 经过了更多优化，因此通常优先选择 COUNT(*)</span>。<br>某些旧版的数据库系统在处理COUNT<span class="hljs-comment">(*)时，可能会去解析整行数据，而COUNT(1)可以直接统计行数，因此会有一些微小的性能差异。</span><br></code></pre></td></tr></table></figure><ul><li><p>有10w条数据，写在一张表里面，怎么写最快，</p><p>多线程插入，其中一个线程插入失败了，怎么办呢？</p></li><li><p>多个线程怎么去用事务控制</p></li><li><p>前端页面要导出一个文件16G，后端应用内存就只有4G，如何导出？</p></li><li><p>设计抖音</p></li><li><p>为什么要设计出编译时异常、运行时异常，还有error</p><ul><li>强制开发者在编译阶段预见并处理可预期的、程序外部的异常情况（如 IO 操作失败、网络连接中断、用户输入错误等）。这类异常通常与程序外部环境相关（如文件不存在、数据库连接失败），而非程序本身的逻辑错误。</li><li>运行时异常表示程序逻辑错误，这类错误应在开发阶段通过代码审查、测试等手段避免，而非强制在运行时处理。例如空指针引用、数组越界、类型转换错误等，本质上是开发者的错误，而非外部环境不可控的问题。</li><li>表示系统级的严重错误，如 JVM 内存溢出、栈溢出、类文件损坏等。这类问题通常超出程序控制范围，即使捕获也无法恢复，强行处理可能导致更严重的后果（如数据不一致）。</li></ul></li></ul><h5 id="2025-5-5"><a href="#2025-5-5" class="headerlink" title="2025&#x2F;5&#x2F;5"></a>2025&#x2F;5&#x2F;5</h5><ul><li><p>n皇后问题</p></li><li><p>dfs bfs</p></li><li><p>单点登录</p><ul><li>系统的登录页放弃原有逻辑（若子系统想保留原有登录页，则需要新建一个前端页面作为登录页），直接在js里window.location跳转到认证中心的授权接口</li><li>用户输入用户名、密码进行验证。认证通过后，生成AuthonrizeCode，认证中心会发送请求到子系统给的redirect_uri，请求参数中包含AuthonrizeCode。</li><li>子系统接收到AuthonrizeCode，根据AuthonrizeCode调用获取Token接口，获取Token。</li><li>子系统根据返回的AccessToken调用获取认证用户接口，获取到用户信息，然后到子系统数据库中校验该用户是否存在，即是否有权限，有则放行，用户就能正常进入子系统。</li></ul></li><li><p>maven是如何加载的，如何load的，假如两个依赖都依赖了log4j，版本不一样，那么加载哪个呢？</p><ul><li><p>最近定义优先，依赖树中路径最短的版本胜出</p></li><li><p>声明顺序优先，假如深度相同，最先声明的依赖版本胜出</p></li><li><p>显示声明版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.14.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 强制指定版本 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mvn dependency:tree -Dincludes=org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.log4j</span>:log4j-core<br></code></pre></td></tr></table></figure></li><li><p>如何打破双亲委派的规则</p></li><li><p>jvm内存分区的概念</p></li><li><p>元注解</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Target</span>(ElementType.ANNOTATION_TYPE)<br></code></pre></td></tr></table></figure></li><li><p>为什么int[3]必须要指定大小？</p></li></ul><h5 id="2025-5-6"><a href="#2025-5-6" class="headerlink" title="2025&#x2F;5&#x2F;6"></a>2025&#x2F;5&#x2F;6</h5><ul><li><p>https</p><ul><li>为什么https下不能使用http</li><li>协商缓存、强制缓存</li></ul></li><li><p>tcp</p><ul><li>粘包</li></ul></li><li><p>Comparable 侵入式    整数、零或正整数，对应对象小于、等于或大于指定对象。</p></li><li><p>Comparator 非侵入性</p></li><li><p>二叉平衡树，前序、中序、后序遍历</p></li></ul><h5 id="2025-5-8"><a href="#2025-5-8" class="headerlink" title="2025&#x2F;5&#x2F;8"></a>2025&#x2F;5&#x2F;8</h5><p>dubbo</p><p>triple协议</p><h5 id="2025-5-11"><a href="#2025-5-11" class="headerlink" title="2025&#x2F;5&#x2F;11"></a>2025&#x2F;5&#x2F;11</h5><ul><li><p>浮点数</p><p>0.2转换成二进制，依次成2，记录整数部分</p></li></ul><p>​   0.0011 0011 0011  &#x3D;  1&#x2F; 8 + 1 &#x2F; 16 +  1&#x2F;128 + 1&#x2F;256 …</p><ul><li><p>BigDecimal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;52.73&quot;</span>);<br></code></pre></td></tr></table></figure><p>此代码使用一个long存储了5273，并记录了总位数以及小数点位数</p><p><img src="/../../images/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0_bigdecimal.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;52.73&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;32.5&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalAdd</span> <span class="hljs-operator">=</span> bigDecimal1.add(bigDecimal2);<br></code></pre></td></tr></table></figure><p>此代码在计算的时候，会先对其小数位，然后相加</p><p><img src="/../../images/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0%E5%BD%95_bigdecimal_add.png"></p></li><li><p>equals方法会比较精度</p></li><li><p>jdk和jre</p><ul><li>jdk java开发环境，包含了jre、编译器javac和其他工具，比如javadoc、jconsole、javap等</li><li>jre java运行时环境，主要包含jvm和java类库</li></ul><p>从java9开始，就不再区分二者关系，取而代之的是模块系统（JDK被重新组织成94个模块）+ jlink工具（随java9一起发布的新命令行工具，用于生成自定义java运行时映像，改映像仅包含给定应用程序所需的模块）。并且，从JDK11开始，oracle不再提供单独的jre下载。</p><p>也就是说，可以用 jlink 根据自己的需求，创建一个更小的 runtime（运行时），而不是不管什么应用，都是同样的 JRE。</p><p>定制的、模块化的 Java 运行时映像有助于简化 Java 应用的部署和节省内存并增强安全性和可维护性。这对于满足现代应用程序架构的需求，如虚拟化、容器化、微服务和云原生开发，是非常重要的</p></li><li><p>字节码、JIT</p><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p>JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 <strong>JIT（Just in Time Compilation）</strong> 编译器，而 JIT 属于运行时编译。</p><p>当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p><p><strong>HotSpot</strong> 采用了<strong>惰性评估(Lazy Evaluation)<strong>的做法，根据</strong>二八定律</strong>，消耗大部分系统资源的只有那一<strong>小部分的代码</strong>（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p></li><li><p>oracle jdk 和 openjdk</p><ul><li>一个不开源一个开源</li><li>一个高版本后要收费</li></ul></li><li><p>java和c++的区别</p><ul><li>java中不提供指针来直接访问内存</li><li>java类是单继承的、c++支持多重继承</li><li>java有自动垃圾回收GC，c++需要手动释放内存</li><li>java是编译 + 解释型语言，c++是编译型语言</li></ul></li><li><p>基本类型和泛型的区别</p><ul><li>内存的占用和默认值，比如代理的时候，返回null，基本数据类型会报错</li><li>基本类型不可以被泛型使用</li><li>局部变量基本类型存在jvm虚拟机栈的局部变量表中</li></ul><p>⚠️ 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆&#x2F;方法区&#x2F;元空间中。</p></li><li><p>包装类型的缓存机制</p><p>​        <code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>TRUE</code> or <code>FALSE</code>。</p></li></ul><p>​</p><ul><li><p>自动装箱和拆箱</p><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul></li><li><p>成员变量和局部变量</p><p>从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p></li><li><p>重载和重写</p><ul><li><p>重载就是一个类中多个同名方法根据不同的参数类型来确定执行对应方法。</p></li><li><p>重写是指子类对父类运行访问的方法实现过程进行重写。</p><p>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p><p>如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p></li></ul></li><li><p>可变长参数</p><ul><li>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数</li><li>遇到方法重载的情况会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</li></ul></li><li><p>默认构造方法</p><p>​    如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。</p><p>​    构造方法<strong>不能被重写（override）</strong>，但<strong>可以被重载（overload）</strong>。因此，一个类中可以有多个构造方法，这些构造方法可以具有不同的参数列表，以提供不同的对象初始化方式</p></li><li><p>多态</p><p>​    父类的引用指向子类的实例。</p></li><li><p>接口和抽象类</p><ul><li>都不能实例化</li><li>定义了一个方法，（抽象方法、接口方法），都需要子类或者抽象类中去实现，default和static除外，java9后，接口可以包含private方法</li><li>接口是行为的抽象，类是所属关系，用于代码复用。接口可以多实现</li><li>接口中的成员变量只能是public static final类型，不能修改且必须有初始值。抽象类的成员变量可以有任何修饰符，在子类中可以被重写定义或者赋值。</li></ul></li><li><p>String</p><p>Java 9 将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> </p><p>新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span> + <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> str1 + str2;<br><span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string&quot;</span>;<br>System.out.println(str3 == str4);<span class="hljs-comment">//false</span><br>System.out.println(str3 == str5);<span class="hljs-comment">//true</span><br>System.out.println(str4 == str5);<span class="hljs-comment">//false</span><br><span class="hljs-comment">// 对象引用和“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 </span><br><span class="hljs-comment">// 对于 String str3 = &quot;str&quot; + &quot;ing&quot;; 编译器会给你优化成 String str3 = &quot;string&quot;; 。并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量</span><br></code></pre></td></tr></table></figure></li><li><p>避免将异常定义为静态变量</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">当 <span class="hljs-keyword">Java </span>抛出一个异常时，<span class="hljs-keyword">JVM </span>会自动调用异常对象的 fillInStackTrace() 方法，记录当前的调用栈信息（包括类名、方法名、行号等）。每个异常实例的栈信息是抛出时的实时快照，且该信息会被存储在异常对象的 stackTrace 字段中<br>静态异常变量是共享实例，多次抛出时栈信息会被后续调用覆盖，导致调试时无法获取真实的异常发生位置。<br>解决方案：永远为每次异常抛出创建新的异常实例，确保每个异常对象携带独立的栈跟踪信息。<br>本质原则：异常是携带运行时上下文的 “事件对象”，应遵循 “按需创建，一事一议” 的设计，而非复用静态实例。<br></code></pre></td></tr></table></figure></li></ul><p>​</p><ul><li><p>java中，写文件到磁盘中间经历了什么</p></li><li><p>kafka 0拷贝 DMA拷贝</p></li><li><p>http层到tcp层，中间传输数据经历了哪些过程</p></li><li><p>get请求和post请求有什么区别</p></li><li><p>怎么保证消息的顺序性</p></li><li><p>RBAC</p></li></ul><h5 id="2025-5-13"><a href="#2025-5-13" class="headerlink" title="2025&#x2F;5&#x2F;13"></a>2025&#x2F;5&#x2F;13</h5><ul><li>fifo</li></ul><p>异步、解耦、削峰</p><p>Deque 和 Stack</p><p>https中的对称加密和非对称加密</p><p>stream和直接for循环的区别</p><h5 id="2025-5-19"><a href="#2025-5-19" class="headerlink" title="2025&#x2F;5&#x2F;19"></a>2025&#x2F;5&#x2F;19</h5><p>几种配置文件、配置文件的区别</p><p>死锁为什么会导致cpu占用率升高</p><p>java中的线程和linux中的线程有什么区别</p><ul><li>java中的线程是通过调用系统api的方式去创建的，相当于java中的线程是抽象，linux底层是实现</li></ul><h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><img src="../../images/ThreadLocal引用关系图.jpg" /><p>为什么ThreadLocalMap中的Entry将K设置为弱引用？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-built_in">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>private 方法是隐式的final</p></li><li><p>final方法是可以被重载的</p></li><li><p>dubbo</p></li></ul><p>k8s到底是什么</p><p>​介于应用服务和服务器之间，通过策略协调和管理多个应用服务，只需要通过一个yaml文件配置，定义应用的部署顺序等信息，就能自动部署应用到各个服务器上</p><p>control plane 控制平面</p><ul><li><p>Api Service</p></li><li><p>Scheduler  Controller mgr</p></li><li><p>etcd</p></li></ul><p>工作节点 node</p><p>kubelet 负责管理和监控node</p><p>kube proxy 负责node的网络通信</p><ul><li>pod k8s中最小的调度单位</li></ul><p>container</p><p>cluster 集群</p><p>kubectl </p><p>怎么部署服务</p><p>怎么调用服务</p><p>令牌桶</p><p><strong>Content Delivery Network，内容分发网络</strong>。</p><p>具体来说，CDN就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。</p><p>Mysql 和 Mongo db 有什么区别</p><ul><li><p>关系型数据库 文档型NoSQL数据库</p></li><li><p>Mongo 文档结构可随时变化</p></li></ul><p>rpc 远程过程调用</p><p>Remote procedure call </p><p>tcp 粘包</p><p>应用层协议 http rpc</p><p>rpc不用考虑浏览器行为 302</p><h5 id="job-worker模块之使用-power-job"><a href="#job-worker模块之使用-power-job" class="headerlink" title="job-worker模块之使用 power-job"></a>job-worker模块之使用 power-job</h5><blockquote><p>项目已经在mysql中有专门的数据库来提供给job-worker使用，同时，在job-worker中也指定了改数据库信息，并且以docker的方式部署到了服务器上。</p></blockquote><ol><li><p>引入依赖</p><p>项目上使用的是com.github.kfcfans下的powerjob-worker-spring-boot-starter</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>tech.powerjob<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>powerjob-worker-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h5><ul><li><p>feign中的configuration</p></li><li><p>事件框架</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 继承</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CusEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span> </span><br><br><span class="hljs-comment">// 监听方法</span><br><span class="hljs-meta">@Async</span>(<span class="hljs-string">&quot;指定线程池名称&quot;</span>)<br><span class="hljs-meta">@EventListener</span><br>public void method(<span class="hljs-type">CusEvent</span> cusEvent) &#123;<br>&#125;<br><br><span class="hljs-comment">// 推送消息</span><br>eventPublisher.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-type">CusEvent</span>(xx));<br><br><span class="hljs-comment">// 指定时间框架线程池参数</span><br><span class="hljs-meta">@Bean</span>(<span class="hljs-string">&quot;指定线程池名称&quot;</span>)<br>public <span class="hljs-type">Executor</span> cusExecutor() &#123;<br>    <span class="hljs-type">ThreadPoolTaskExecutor</span> executor = <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolTaskExecutor</span>();<br>    executor.setCorePoolSize(corePoolSize);<br>    executor.setMaxPoolSize(maxPoolSize);<br>    executor.setQueueCapacity(queueCapacity);<br>    executor.setThreadNamePrefix(<span class="hljs-type">DOMAIN_EXECUTOR</span>);<br>    <span class="hljs-comment">// rejection-policy：当pool已经达到max size的时候，如何处理新任务</span><br>    <span class="hljs-comment">// ThreadPoolExecutor#DiscardPolicy：这个策略将会直接丢弃任务</span><br>    <span class="hljs-comment">// ThreadPoolExecutor#CallerRunsPolicy：不在新线程中执行任务，而是有调用者所在的线程来执行策略</span><br>    executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>.<span class="hljs-type">CallerRunsPolicy</span>());<br>    executor.initialize();<br>    <span class="hljs-keyword">return</span> executor;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自定义异常处理器</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">restTemplate.setErrorHandler(new RestTemplateResponseErrorHandler())<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>内存溢出和内存泄漏</p></li><li><p>sql语句的执行过程</p></li><li><p>innodb和myism区别</p></li><li><p>回表的理解</p></li><li><p>注解来统一处理接口耗时</p></li><li><p>流程授权的功能，在注解中进行了统一处理，替换session中的信息</p></li><li><p>@Pointcut注解：统一定义切点表达式</p></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Aspect</span><br>public class LoggingAspect &#123;<br><br>    <span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;execution(* com.example.service..*(..))&quot;</span>)<br>    public void <span class="hljs-built_in">serviceLayer</span>() &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 在切入点表达式匹配的方法执行之前执行通知</span><br>    <span class="hljs-variable">@Before</span>(<span class="hljs-string">&quot;serviceLayer()&quot;</span>)<br>    public void <span class="hljs-built_in">logBefore</span>() &#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;Executing logBefore advice on serviceLayer()&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2025/05/02/java/%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2025/05/02/java/%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新中</p></blockquote><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><blockquote><p>偶然间刷到了一个桶排序的视频，这次来实现下加深记忆</p></blockquote><p>​桶排序不是基于比较的排序算法，其效率取决于数据的分布特性，适用于数据均匀分布在某个范围内的场景（如浮点数、整数区间明确的数值数据）。其实现步骤如下：</p><ul><li>划分桶</li><li>桶内排序</li></ul><p>​值得注意的是，如何划分桶，以及数组元素定位到对应桶这两点。</p><p>方式一：</p><p>​假设桶的数量为bucketNum</p><p>​直接使用[max] - [min] &#x2F; bucketNum 确定桶的容量bucketCapacity</p><p>​数组元素进行桶定位的时候，使用当前元素item和数组内最小值的差值除以桶容量，此种情况下，会出现越界问题，必须使用Math.min进行一个辅助。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">bucketIndex</span> <span class="hljs-operator">=</span> Math.min((item - min) / bucketCapacity, bucketNum - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>​为什么会出现越界？比如 8 &#x2F; 3 ，向下取整的到的结果是 2，这里2对应的就是桶的容量，8对应的就是最大元素和最小元素的差值，3代表桶的数量，此时，使用(item - min) &#x2F; bucketCapacity，当item为最大元素时，会变成 8 &#x2F; 2，结果为4，会产生数组越界，现在我们抽象下这个问题</p><ul><li><p>[最大差值] &#x2F; [桶的数量] 向下取整  [桶的容量]</p></li><li><p>[桶的数量] * [桶的容量] &lt;&#x3D; [最大差值]</p></li></ul><p>最坏的情况下， [桶的容量] * [桶的数量] &#x3D; [最大差值] - （[桶的数量] - 1）</p><p>假设  [桶的容量]  &lt;&#x3D; （[桶的数量] - 1），此时会产生越界</p><p>方式二：</p><p>​(item - min) * bucketNum &#x2F; (max - min + 1) 非常巧妙的方式</p><ul><li>​(item - min)  &lt;  (max - min + 1)</li><li>​    (item - min)  * bucketNum &lt;   (max - min + 1) * bucketNum </li><li>(item - min) * bucketNum &#x2F; (max - min + 1) &lt; bucketNum</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> bucketSort(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-type">int</span> bucketNum = <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> min = ArrayUtils.min(arr);<br>        <span class="hljs-type">int</span> max = ArrayUtils.max(arr);<br>//        <span class="hljs-type">int</span> bucketCapacity = (max - min) / bucketNum;<br><br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; bucketList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketNum; i++) &#123;<br>            bucketList.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> item : arr) &#123;<br>//            <span class="hljs-type">int</span> bucketIndex = Math.min((item - min) / bucketCapacity, bucketNum - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> bucketIndex = (item - min) * bucketNum / (max - min + <span class="hljs-number">1</span>);<br>            bucketList.<span class="hljs-keyword">get</span>(bucketIndex).<span class="hljs-keyword">add</span>(item);<br>        &#125;<br><br>        <span class="hljs-type">int</span> indexGap = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketNum; i++) &#123;<br>            List&lt;<span class="hljs-type">Integer</span>&gt; bucket = bucketList.<span class="hljs-keyword">get</span>(i);<br>            <span class="hljs-type">int</span>[] <span class="hljs-keyword">array</span> = bucket.stream().mapToInt(<span class="hljs-type">Integer</span>::intValue).toArray();<br>            selectionSort(<span class="hljs-keyword">array</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">array</span>.length; j++) &#123;<br>                arr[j + indexGap] = <span class="hljs-keyword">array</span>[j];<br>            &#125;<br>            indexGap += <span class="hljs-keyword">array</span>.length;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阻塞队列</title>
    <link href="/2025/05/02/java/%E5%9F%BA%E7%A1%80/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <url>/2025/05/02/java/%E5%9F%BA%E7%A1%80/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新中</p></blockquote><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>​BlockingQueue是一个接口，它属于 Java 并发包java.util.concurrent，其用途是在多线程环境下实现线程安全的队列操作。</p><ul><li>线程安全：BlockingQueue自身实现了线程安全，多个线程能够同时对队列进行读写操作，无需额外的同步机制。</li><li>阻塞操作：定义了若干阻塞方法，当队列满时进行入队操作，或者队列空时进行出队操作，这些方法会让线程进入阻塞状态，直至满足操作条件。</li><li>容量限制：部分BlockingQueue的实现类具备容量限制，当队列达到最大容量时，再进行入队操作会被阻塞。</li></ul><h5 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h5><ul><li>add(E e)：若队列未满，将元素插入队列尾部，成功则返回true；若队列已满，会抛出IllegalStateException异常。</li><li>offer(E e)：若队列未满，将元素插入队列尾部，成功则返回true；若队列已满，返回false。</li><li>offer(E e, long timeout, TimeUnit unit)：在指定时间内尝试将元素插入队列尾部，若成功则返回true；若超时仍未成功，返回false。</li><li>put(E e)：若队列未满，将元素插入队列尾部；若队列已满，线程会阻塞直至队列有空间。</li></ul><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><ul><li>remove()：若队列不为空，移除并返回队列头部元素；若队列为空，抛出NoSuchElementException异常。</li><li>poll()：若队列不为空，移除并返回队列头部元素；若队列为空，返回null。</li><li>poll(long timeout, TimeUnit unit)：在指定时间内尝试移除并返回队列头部元素，若成功则返回元素；若超时仍未成功，返回null。</li><li>take()：若队列不为空，移除并返回队列头部元素；若队列为空，线程会阻塞直至队列中有元素。</li></ul><h5 id="检查元素"><a href="#检查元素" class="headerlink" title="检查元素"></a>检查元素</h5><ul><li>element()：若队列不为空，返回队列头部元素，但不移除；若队列为空，抛出NoSuchElementException异常。</li><li>peek()：若队列不为空，返回队列头部元素，但不移除；若队列为空，返回null。</li></ul><h5 id="常见实现类"><a href="#常见实现类" class="headerlink" title="常见实现类"></a>常见实现类</h5><ul><li>ArrayBlockingQueue：基于数组实现的有界阻塞队列，在创建时需指定容量，且可选择是否使用公平锁。</li><li>LinkedBlockingQueue：基于链表实现的阻塞队列，可指定容量，若不指定则默认为Integer.MAX_VALUE，被视为无界队列。</li><li>PriorityBlockingQueue：基于优先级堆实现的无界阻塞队列，队列中的元素会按照自然顺序或者指定的比较器进行排序。</li><li>SynchronousQueue：一种特殊的阻塞队列，它不存储元素，每个插入操作必须等待另一个线程的移除操作，反之亦然。</li></ul><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ArrayBlockingQueue;<br><span class="hljs-keyword">import</span> java.util.concurrent.BlockingQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueueExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 生产者线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    queue.put(i);<br>                    System.out.println(<span class="hljs-string">&quot;Produced: &quot;</span> + i);<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 消费者线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> queue.take();<br>                    System.out.println(<span class="hljs-string">&quot;Consumed: &quot;</span> + item);<br>                    Thread.sleep(<span class="hljs-number">200</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;);<br><br>        producer.start();<br>        consumer.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            producer.join();<br>            consumer.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis篇</title>
    <link href="/2025/05/01/java/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"/>
    <url>/2025/05/01/java/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/</url>
    
    <content type="html"><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>缓存</li><li>分布式锁</li><li>消息队列、延时队列</li><li>…</li></ul><p>ps：结合项目业务回答</p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>redis单线程为什么还执行那么快？</p><ul><li><p>纯内存操作，执行速度快</p></li><li><p>采用单线程，避免不必要的上下文切换可竞争条件，无需考虑线程安全问题，大key慢，scan等问题…</p></li><li><p>使用I&#x2F;O多路复用模型，非阻塞io</p><p>其瓶颈主要是网络延迟而不是执行速度</p></li></ul><h5 id="内核空间和用户空间"><a href="#内核空间和用户空间" class="headerlink" title="内核空间和用户空间"></a>内核空间和用户空间</h5><ul><li><p>用户空间：只能执行受限的命令(Ring3)，而不能直接调用系统资源，必须提供内核提供的接口来访问</p></li><li><p>内核空间：可以执行特权命令(Ring0)，调用系统资源</p><p>linux为了提高IO效率，会在二者都加入缓冲区</p><ul><li>写数据时，要把用户数据从用户缓冲区拷贝到内核缓冲区，然后写入设备</li><li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li></ul><p>想办法减少无效等待和频繁拷贝，recvfrom：从内核获取数据</p><ul><li>非阻塞io，recvfrom会立即返回结果而不是阻塞用户进程，但是会频繁访问，忙等，耗费cpu，直到数据就绪，但是数据就绪后，拷贝数据到用户空间的过程还是阻塞的。</li><li>io多路复用：单个线程同时兼容多个socket，使用select函数，监听多个socker，当内核数据就绪时，触发回调，客户端处理数据。</li><li>select、poll、epoll：前面二者只会通知用户进程有socker就绪，但不确定具体是哪个socker，需要用户进程逐个遍历，epoll会在 通知用户进程socker就绪的同时，把已就绪的socker写入用户空间</li></ul></li></ul><h5 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1.缓存穿透"></a>1.缓存穿透</h5><p>​查询<strong>不存在的数据</strong>，每次请求都会落到数据库，每次都查不到结果，redis不会缓存。</p><ul><li><p>缓存空数据，查不到结果，仍把空数据进行缓存</p><p>简单，但消耗内存，有可能会存在数据库不一致的问题。</p></li><li><p>布隆过滤器</p><ul><li>在查询redis缓存前，在<strong>前面加了一层</strong>布隆过滤器，如果布隆过滤器中，不存在，直接返回，存在在继续往下走</li><li>缓存预热时，预热布隆过滤器</li><li>基于bitmap实现<ul><li>存数据时，对key进行<strong>多次hash</strong>计算获取hash值，根据这一个个值，将数组对应位置改为1</li><li>查数据时，使用<strong>相同hash</strong>函数获取hash值，判断对应位置是否为1，都是1表示存在</li><li>有可能会存在误判，某个key hash后的值与存在的多个key的hash后的值重合，数组越小误判率越大，越大误判率越小。 </li><li>redisson和guava都实现了布隆过滤器，其可以设置误判率</li></ul></li></ul></li></ul><h5 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2.缓存击穿"></a>2.缓存击穿</h5><p>​某个时间点某个key突然有大量的并发过来，而且此时在redis中这个数据没有缓存(也许是到期了)，在第一次将数据库返回写入缓存这个过程中，其余大量请求直接到数据库可能会把数据库压垮。</p><ul><li>添加互斥锁（强一致性、性能差）<ul><li>第一次查询缓存未命中，在查询数据库之前，先要获取锁</li></ul></li><li>逻辑过期（高可用）<ul><li>不设置过期时间</li><li>查询缓存未命中，获取锁，新开了一个线程更新缓存，然后返回过期数据</li></ul></li></ul><h5 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3.缓存雪崩"></a>3.缓存雪崩</h5><p>​同一时段内，大量的缓存key同时失效或者redis服务宕机，大量请求到达数据库</p><ul><li><p>给不同的key设置不同的过期时间</p></li><li><p>利用redis集群提高服务的可用性</p></li><li><p>给缓存业务添加降级限流策略 nginx 网关限制</p></li><li><p>添加多级缓存 Guava或者Caffeine</p></li></ul><h5 id="4-mysql和redis数据同步，双写一致性"><a href="#4-mysql和redis数据同步，双写一致性" class="headerlink" title="4.mysql和redis数据同步，双写一致性"></a>4.mysql和redis数据同步，双写一致性</h5><p>​修改了数据库的数据，也要同时更新缓存的数据，缓存和数据库的数据要保持一致。</p><ul><li><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存</p></li><li><p>写操作：延迟双删</p><p>删除缓存——&gt;修改数据库——&gt;延时删除缓存</p><p>传统方案：</p><ul><li>先删除缓存，在修改数据库：在删除缓存和更新数据库之间，又来了一个线程，查询缓存查询数据库，写入旧的数据到了缓存。</li><li>先操作数据库，再删除缓存：在更新数据库之前，先前有一个线程，查询缓存查不到，查数据库、更新缓存，这个线程更新缓存的操作在当前线程删除缓存之后。</li></ul><p>为什么要延时？</p><p>mysql一般都是主从的，主节点同步到从节点也需要时间。</p></li><li><p>一般放入缓存中的数据都是读多写少，可以使用读写锁</p></li><li><p>异步通知保证数据的最终一致性，写入到数据库后，发布消息到mq去更新缓存</p></li><li><p>使用canal，写入到数据库后，canal会监听mysql的binlog，变更时通知缓存服务更新缓存</p></li></ul><h5 id="5-redis的持久化"><a href="#5-redis的持久化" class="headerlink" title="5.redis的持久化"></a>5.redis的持久化</h5><ul><li><p>RDB</p><p>把内存中的所有数据都记录到磁盘中，当redis实例故障重启后，从磁盘读取快照文件，恢复数据</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">save</span> <span class="hljs-meta">#redis主进程执行rdb，会阻塞所有命令</span><br>bgsave <span class="hljs-meta">#开启子进程执行rdb，避免主进程受到影响</span><br></code></pre></td></tr></table></figure><p>redis内部有触发RDB的机制，可以在redis.conf中找到，格式为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 900s内，如果至少有一个key被修改，则执行bgsave</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>bgsave开始时会fork主进程得到子进程，复制页表到子线程，对实际指向内存中的物理地址写入到rdb文件中放到磁盘。</p><p>假如这期间，主进程在修改数据，fork采用的是copy-on-write技术，当主进程在写的时候，会拷贝一份数据，执行写操作。</p><p>页表：记录虚拟地址和物理地址的映射关系</p></li><li><p>AOF（append only file）</p><p>redis处理的每一个写命令都会记录在aof文件中，可以看作是命令日志文件</p><ul><li><p>aof默认是关闭的，需要修改redis.conf配置文件来开启aof</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 是否开启aof 默认是no</span><br><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span><br><span class="hljs-comment"># aof文件的名称</span><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>频率，刷盘策略</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appendfsync</span> always <span class="hljs-comment"># 立即记录到aof文件，性能影响大</span><br>appendfsync everysec <span class="hljs-comment"># 写完后放入aof缓冲区，每隔1秒将缓冲区数据写到aof，默认方案，最多丢失1s数据</span><br>appendfsync <span class="hljs-literal">no</span> <span class="hljs-comment">#写入aof缓冲区，由操作系统决定何时写回磁盘</span><br></code></pre></td></tr></table></figure></li><li><p>存在问题：</p><ul><li><p>记录命令，文件大</p></li><li><p>记录多次写操作，只有最后一次写才有意义，可以使用bgrewriteaof执行重写，用最少的命令达到相同的效果</p></li><li><p>配置</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">auto</span>-aof-rewrite-percentage <span class="hljs-number">100</span> <span class="hljs-meta"># aof比上次文件增长超过多少百分比触发重写</span><br><span class="hljs-keyword">auto</span>-aof-rewrite-min-size <span class="hljs-number">64</span>mb <span class="hljs-meta"># aof文件体积最小多少大以上触发重写</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>对比</p><p>aof相对完整，取决于刷盘策略</p><p>aof数据恢复优先级高，因为其数据完整性更高</p></li></ul><p>​恢复速度rdb更快</p><p>​rdb耗费性能高，大量cpu和内存消耗</p><p>​aof追加命令，主要占用的是磁盘io资源，但aof重写的时候会占用大量的cpu和内存资源。</p><h5 id="6-数据过期策略"><a href="#6-数据过期策略" class="headerlink" title="6.数据过期策略"></a>6.数据过期策略</h5><ul><li>惰性删除：设置过期时间后，过期不会主动删除，当需要该key的时候，检查是否过期，过期就删掉，反之返回。<ul><li>对cpu友好，不用进行过期检查</li><li>内存中不会释放，占用内存</li></ul></li><li>定期删除：每隔一段时间，对key进行检查，删除过期的key（检查：从一定数量的数据库中取出一定数量的随机key进行检查）<ul><li>slow模式：定时任务，频率为10hz（每秒执行10次，即执行周期是100ms），每次不超过25ms，通过修改配置文件redis.conf的hz选项来调整</li><li>fast模式，执行频率不固定，但两次间隔不低于2ms，每次执行耗时不超过1ms</li><li>优点：有效释放了过期数据占用的内存，同时，其可以以限制执行时长和频率来减少删除操作对cpu的影响</li><li>缺点：执行时长和频率不好确定</li></ul></li></ul><p>​redis过期策略是两者结合使用</p><h5 id="7-数据淘汰策略"><a href="#7-数据淘汰策略" class="headerlink" title="7.数据淘汰策略"></a>7.数据淘汰策略</h5><p>​内存被占用满了怎么办？</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">maxmemory-<span class="hljs-keyword">policy</span> noeviction<br></code></pre></td></tr></table></figure><ul><li><p>noeviction：不会淘汰任何key，内存满了不允许写入新数据，默认</p></li><li><p>volatile-ttl：对设置了ttl的key，比较剩余ttl，ttl越小先被淘汰</p></li><li><p>allkeys-random：对全体key，随机进行淘汰</p></li><li><p>volatile-random：对设置了ttl的key，随机进行淘汰</p></li><li><p>allkeys-lru：对全体key，使用lru，最近最少使用</p></li><li><p>volatile-lru：对设置了ttl的key，使用lru，最近最少使用</p></li><li><p>allkeys-lfu：对全体key，使用lru，最近最少频率使用</p></li><li><p>volatile-lfu：对设置了ttl的key，使用lfu，最近最少使用</p></li></ul><p>优先使用lru，实际使用中，lfu不一定比lru实用，某一个key，一段时间内访问频率高，另外一段时间内访问频率不一定高</p><p>有置顶的需求，可以使用volatile-lru，同时置顶数据不设置过期时间</p><p>有短时高频访问的数据，使用lfu</p><h5 id="8-redis分布式锁"><a href="#8-redis分布式锁" class="headerlink" title="8.redis分布式锁"></a>8.redis分布式锁</h5><p>​setnx，有效时长，lua脚本</p><p>​redlock红锁：不能只在一个reids实例上创建锁，应该是在多个redis实例上创建锁(n&#x2F;2 +1)，实现复杂，性能差，运维繁琐。</p><p>​redis是ap思想，高可用</p><p>​如果要保证强一致性可以使用zookeeper，cp思想</p><h5 id="9-集群"><a href="#9-集群" class="headerlink" title="9.集群"></a>9.集群</h5><ul><li><p>主从：读写分离，主写，从读，解决高并发</p><ul><li><p>全量同步</p><table><thead><tr><th>主</th><th>从</th></tr></thead><tbody><tr><td></td><td>执行replicaof命令</td></tr><tr><td></td><td>请求数据同步，将自己的replid、offset发送</td></tr><tr><td>拿replid和自己判断，判断是否第一次同步</td><td></td></tr><tr><td>是第一次，返回master数据版本信息repliid、offset，第二次，就会直接发送repl_baklog给从</td><td></td></tr><tr><td></td><td>保存版本信息</td></tr><tr><td>执行bgsave，生成rdb，发送rdb到从</td><td></td></tr><tr><td></td><td>清空本地文件，加载rdb文件</td></tr><tr><td>记录rdb期间的所有命令到repl_baklog中,发送给从</td><td></td></tr><tr><td></td><td>执行repl_baklog</td></tr></tbody></table></li><li><p>增量同步，slave重启或后期数据变化</p><p>即上面的表格中第二次部分，从repl_baklog发送offset后的命令到从</p></li></ul></li><li><p>哨兵（sentinel）：实现主从集群的自动故障恢复，解决高可用</p><ul><li>sentinel会不断检查主从是否按照预期工作</li><li>自动故障恢复：master故障后，sentinel会将一个slave提升为master，故障实例恢复后也以新的master为主</li><li>通知：sentinel充当redis客户端的服务发现来源，集群发生故障转移时，会将最新的信息推送给redis客户端</li></ul><p>其基于心跳机制检测服务状态，每隔1s向集群的每个实例发送ping命令：</p><ul><li>主观下线：如果某个实例未在规定时间内响应，主观下线</li><li>客观下线，超过指定数量的sentinel都认为该实例主观下线，则该实例客观下线，指定数量quorum值最好超过sentinel的一半。</li></ul><p>选主规则</p><ul><li>判断主节点和从节点断开时间长短，断开时间太长了就代表数据旧</li><li>判断从节点的slave-priority值，越小优先级越高</li><li>如果slave-priority一样，则判断slave的offset值，越大优先级越高</li><li>判断slave节点的运行id大小，越小优先级越高</li></ul><p>脑裂</p><ul><li><p>主节点网络和sentinel分区了，sentinel选出了新的主，同时客户端也在往旧的主节点写数据，当主节点网络和sentinel恢复到一个分区后，会把旧的主节点当成从节点，此时数据丢失</p></li><li><p>解决</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-replicas-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 表示主节点最少的salve节点为1个，否则拒绝请求</span><br><span class="hljs-built_in">min</span>-replicas-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">5</span> <span class="hljs-comment"># 表示数据复制和同步的延迟不超过5s，否则拒绝客户端连接</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>分片集群，解决海量数据存储以及高并发写的问题</p><ul><li>集群中有多个master，每个master保存不同内存</li><li>每个master都可以有多个slave节点</li><li>master之间通过ping检测彼此健康状态，这样就不要哨兵了</li><li>客户端可以访问集群任意节点，最终都会被转发到正确节点</li></ul><p>hash槽，redis集群中有16384个hash槽，每个key通过CRC16校验后对16384取模来决定防止哪个槽，集群的每个节点负责一部分hash槽。</p><p>可以使用set[aaa] name value 指定取模来源，redis会根据aaa来进行取模，而不是name了。</p></li></ul><h5 id="redis集群如何扛住百万级别的热点key的访问"><a href="#redis集群如何扛住百万级别的热点key的访问" class="headerlink" title="redis集群如何扛住百万级别的热点key的访问"></a>redis集群如何扛住百万级别的热点key的访问</h5><p>redis单片的写入瓶颈在2万左右，读瓶颈在10w左右</p><ul><li><p>对热点key进行拆分成几个小key</p><p>如何保证各个key在不同节点上，CRC16插槽</p></li></ul><h5 id="基于list结构模拟消息队列"><a href="#基于list结构模拟消息队列" class="headerlink" title="基于list结构模拟消息队列"></a>基于list结构模拟消息队列</h5><ul><li>生产者使用LPUSH向redis队列中存入一条数据</li><li>消费者使用RPOP后进先出、LPOP先进先出、BRPOP、BLPOP</li></ul><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"># 向列表 mylist 中依次添加元素 a、b、c<br><span class="hljs-number">127.0.0.1:6379</span>&gt; RPUSH mylist a b c<br>(integer) <span class="hljs-number">3</span><br><br># 使用 RPOP 从列表右侧（尾部）移除并返回元素<br><span class="hljs-number">127.0.0.1:6379</span>&gt; RPOP mylist<br><span class="hljs-string">&quot;c&quot;</span><br><br># 此时列表中剩余元素为 a、b<br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE mylist <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;b&quot;</span><br><br># 使用 LPOP 从列表左侧（头部）移除并返回元素<br><span class="hljs-number">127.0.0.1:6379</span>&gt; LPOP mylist<br><span class="hljs-string">&quot;a&quot;</span><br><br># 此时列表中剩余元素为 b<br><span class="hljs-number">127.0.0.1:6379</span>&gt; LRANGE mylist <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;b&quot;</span><br></code></pre></td></tr></table></figure><h5 id="基于Pubsub的消息队列"><a href="#基于Pubsub的消息队列" class="headerlink" title="基于Pubsub的消息队列"></a>基于Pubsub的消息队列</h5><p>​消费者可以订阅一个或多个channel，生产者向对应的channel发送消息后，所有的订阅者都能收到相关消息。</p><ul><li>SUBSCRIBE xxx.q1</li><li>PUBLISH xxx.q1</li></ul><h5 id="Stream的消息队列"><a href="#Stream的消息队列" class="headerlink" title="Stream的消息队列"></a>Stream的消息队列</h5><p>​redis5.0后引入的新的数据类型，可以实现功能完善的消息队列。</p><h5 id="feed流"><a href="#feed流" class="headerlink" title="feed流"></a>feed流</h5><ul><li>拉模式：读扩散，数据存储在来源方，每次都查询</li><li>推模式：写扩散，数据推送到接收方，假如有多个接收方，就会存储多份，延迟低，但是内存占用高</li><li>推拉结合模式：读写混合，假如接收方比较少，就写扩散，或者有几个活跃的接收方，就使用这种模式，而那些僵尸粉，就使用拉模式。</li></ul><h5 id="GEO数据结构"><a href="#GEO数据结构" class="headerlink" title="GEO数据结构"></a>GEO数据结构</h5><p>3.2版本后，加入了对GEO的支持，允许存储地理坐标信息，经度、纬度、值。</p><h5 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h5><p>​redis是利用string数据类型实现的bitmap，最大上限是512M</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"># 给<span class="hljs-keyword">key</span>上dayOfMonth - <span class="hljs-number">1</span>索引的值置为<span class="hljs-literal">true</span><br>stringRedisTemplate.opsForValue().setBit(<span class="hljs-keyword">key</span>, dayOfMonth - <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br><br># 查询从第<span class="hljs-number">0</span>个索引到dayOfMonth索引的值<br>List&lt;<span class="hljs-type">Long</span>&gt; longs = stringRedisTemplate.opsForValue().bitField(<br>                <span class="hljs-keyword">key</span>,<br>              BitFieldSubCommands.create().<span class="hljs-keyword">get</span>(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="hljs-number">0</span>)<br>        );<br></code></pre></td></tr></table></figure><h5 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h5><ul><li>UV：unique visitor 独立访客量，一天内同一个用户多次访问，只记录一次</li><li>PV：page view，页面访问量或点击量，用户访问网站的一个页面，记录一次PV，用户多次打开页面，则记录多次PV。</li></ul><p>底层也是基于基于string实现的，单个HLL的内存永远小于16kb，其测量结果是概率性的，有小于0.81%的误差，对于UV来说，完全可以忽略。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">info</span> memory <span class="hljs-comment"># 查看redis内存值</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql篇</title>
    <link href="/2025/05/01/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    <url>/2025/05/01/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/</url>
    
    <content type="html"><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h5 id="查看数据库版本"><a href="#查看数据库版本" class="headerlink" title="查看数据库版本"></a>查看数据库版本</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> VERSION();<br></code></pre></td></tr></table></figure><h5 id="修改数据库最大连接数以及单个连接过期时间"><a href="#修改数据库最大连接数以及单个连接过期时间" class="headerlink" title="修改数据库最大连接数以及单个连接过期时间"></a>修改数据库最大连接数以及单个连接过期时间</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--修改数据库最大连接数以及单个连接过期时间</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> max_connections<span class="hljs-operator">=</span><span class="hljs-number">10000</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> interactive_timeout<span class="hljs-operator">=</span><span class="hljs-number">60</span><br><br><span class="hljs-comment">--查看、确认</span><br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;max_connections&#x27;</span>;<br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;interactive_timeout&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="优化器跟踪-OPTIMIZER-TRACE"><a href="#优化器跟踪-OPTIMIZER-TRACE" class="headerlink" title="优化器跟踪 OPTIMIZER_TRACE"></a>优化器跟踪 OPTIMIZER_TRACE</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-- 开启 OPTIMIZER_TRACE<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">optimizer_trace</span>=<span class="hljs-string">&quot;enabled=on&quot;</span>, <span class="hljs-attribute">optimizer_trace_max_mem_size</span>=1000000;<br><br>-- 执行需要分析的查询<br><br>-- 查看 OPTIMIZER_TRACE 信息<br>SELECT * <span class="hljs-keyword">FROM</span> information_schema.OPTIMIZER_TRACE;<br><br>-- 关闭 OPTIMIZER_TRACE<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">optimizer_trace</span>=<span class="hljs-string">&quot;enabled=off&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="杀掉那些当前处于“Sleep”状态的连接"><a href="#杀掉那些当前处于“Sleep”状态的连接" class="headerlink" title="杀掉那些当前处于“Sleep”状态的连接"></a>杀掉那些当前处于“Sleep”状态的连接</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;kill &#x27;</span>,id,<span class="hljs-string">&#x27;;&#x27;</span>) <span class="hljs-keyword">from</span> information_schema.`PROCESSLIST` <span class="hljs-keyword">where</span> command<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Sleep&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="命令行下的操作"><a href="#命令行下的操作" class="headerlink" title="命令行下的操作"></a>命令行下的操作</h5><ul><li>进入mysql</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>u apaas <span class="hljs-operator">-</span>p<br></code></pre></td></tr></table></figure><ul><li>查看&#x2F;使用数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES;<br>USE 数据库名;<br></code></pre></td></tr></table></figure><h5 id="修改结构"><a href="#修改结构" class="headerlink" title="修改结构"></a>修改结构</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DESCRIBE</span> 表名;<br><span class="hljs-keyword">ALTER TABLE</span> apaas_app_access<br>MODIFY <span class="hljs-keyword">COLUMN</span> object_id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><h5 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h5><ul><li>根据某张表的某些字段更新另外一张表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> sy_property_copy (apply_number, document_id, form_id, tenant_id, id)<br><span class="hljs-keyword">SELECT</span> exit_ware_num, document_id, form_id,tenant_id, id<br><span class="hljs-keyword">FROM</span> sy_property<br><span class="hljs-keyword">WHERE</span> exit_ware_num <span class="hljs-keyword">is</span> <span class="hljs-keyword">not NULL</span>;;<br></code></pre></td></tr></table></figure><h5 id="查询mysql对应账号的密码"><a href="#查询mysql对应账号的密码" class="headerlink" title="查询mysql对应账号的密码"></a>查询mysql对应账号的密码</h5><ul><li>此方法查出的为加密后的密码</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">user</span>, host, authentication_string <span class="hljs-keyword">FROM</span> mysql.user <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;your_username&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="字符集相关"><a href="#字符集相关" class="headerlink" title="字符集相关"></a>字符集相关</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// 展示数据库数据集<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">where</span> variable_name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%collation%&#x27;</span>;<br><br>// 设置数据库数据集<br><span class="hljs-keyword">SET</span> collation_connection = <span class="hljs-string">&#x27;utf8mb4_general_ci&#x27;</span>;<br><br>// 展示创建表语句<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> lzc1;<br><br>// 展示视图数据集<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">view</span> view_test_1;<br><br>// 展示表/视图所有列信息<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">full</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">from</span> v_crm_disty_projects;<br></code></pre></td></tr></table></figure><h3 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h3><h5 id="正则表达式-‘？-’"><a href="#正则表达式-‘？-’" class="headerlink" title="正则表达式  ‘？:’"></a>正则表达式  ‘？:’</h5><p>例如下面的代码，mysql5.0不支持</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> supplier_first_battalion_x <span class="hljs-keyword">where</span> supplier_first_battalion_x.BUKRS_X RLIKE <span class="hljs-string">&#x27;\b(?:1000|&quot;|,|\[|\])\b&#x27;</span>;<br></code></pre></td></tr></table></figure><p>可以使用以下方式替换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> supplier_first_battalion_x <span class="hljs-keyword">where</span> supplier_first_battalion_x.BUKRS_X RLIKE <span class="hljs-string">&#x27;^(&quot;|,|\[|\])*(1000)(&quot;|,|\[|\])*$&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"># 查看有没有开启binlog<br>SHOW VARIABLES LIKE <span class="hljs-string">&#x27;log_bin&#x27;</span>;<br># 查看所有binlog<br>SHOW BINARY LOGS;<br># 查看binlog对应的存储位置<br>SHOW VARIABLES LIKE <span class="hljs-string">&#x27;log_bin_basename&#x27;</span>;<br><br><br># 找出某个时间点内的日志 <br>mysqlbinlog --no-defaults --base64-output=decode-rows binlog<span class="hljs-number">.000009</span> --start-datetime=<span class="hljs-string">&quot;2024-08-01 01:06:00&quot;</span> --stop-datetime=<span class="hljs-string">&quot;2024-08-04 23:12:20&quot;</span>  --base64-output=DECODE-ROWS --verbose | grep <span class="hljs-string">&quot;building_specialty_store&quot;</span> | grep <span class="hljs-string">&quot;DELETE&quot;</span><br><br>mysqlbinlog --no-defaults --base64-output=decode-rows binlog<span class="hljs-number">.000008</span> --start-datetime=<span class="hljs-string">&quot;2024-08-01 01:06:00&quot;</span> --stop-datetime=<span class="hljs-string">&quot;2025-08-04 23:12:20&quot;</span>  --base64-output=DECODE-ROWS --verbose | grep <span class="hljs-string">&quot;dept&quot;</span> | grep <span class="hljs-string">&quot;DELETE&quot;</span><br><br>mysqlbinlog --no-defaults --start-position=<span class="hljs-number">8019910</span> --stop-position=<span class="hljs-number">8019921</span> binlog<span class="hljs-number">.000456</span>  --base64-output=DECODE-ROWS --verbose<br>mysqlbinlog --no-defaults --base64-output=decode-rows binlog<span class="hljs-number">.000004</span> --start-datetime=<span class="hljs-string">&quot;2024-08-01 01:06:00&quot;</span> --stop-datetime=<span class="hljs-string">&quot;2024-09-04 23:12:20&quot;</span> --base64-output=DECODE-ROWS --verbose | grep <span class="hljs-string">&quot;building_specialty_store&quot;</span> | grep <span class="hljs-string">&quot;DELETE&quot;</span> | grep -v <span class="hljs-string">&quot;button&quot;</span> | grep -v <span class="hljs-string">&quot;color&quot;</span><br></code></pre></td></tr></table></figure><h3 id="使用记录"><a href="#使用记录" class="headerlink" title="使用记录"></a>使用记录</h3><h5 id="如何定位慢查询"><a href="#如何定位慢查询" class="headerlink" title="如何定位慢查询"></a>如何定位慢查询</h5><ul><li>mysql慢日志</li><li>压力测试的时候可以看接口耗时，运维工具</li></ul><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>MySQL的默认存储引擎InnoDB使用的是B+树作为索引的存储结构。</p><p>选择B+树的原因包括：</p><ul><li><p>节点可以有更多子节点，路径更短；</p></li><li><p>磁盘读写代价更低，非叶子节点只存储键值和指针，叶子节点存储数据；</p></li><li><p>B+树适合范围查询和扫描，因为叶子节点形成了一个双向链表。</p></li></ul><p>聚簇索引：聚簇索引是指数据与索引放在一起，B+树的叶子节点保存了整行数据，通常只有一个聚簇索引，一般是由主键构成。</p><p>非聚簇索引：数据与索引分开存储，B+树的叶子节点保存的是主键值</p><p>覆盖索引：SELECT查询中，返回的列全部能在索引中找到，避免了回表查询，提高了性能。使用覆盖索引可以减少对主键索引的查询次数，提高查询效率。</p><p>回表查询：通过二级索引找到对应的主键值，然后再通过主键值查询聚簇索引中对应的整行数据的过程。</p><p>索引创建原则：</p><ul><li>表中的数据量超过10万以上时考虑创建索引。</li><li>选择查询频繁的字段作为索引，如查询条件、排序字段或分组字段。</li><li>尽量使用复合索引，覆盖SQL的返回值。</li><li>如果字段区分度不高，可以将其放在组合索引的后面。</li><li>对于内容较长的字段，考虑使用前缀索引。</li><li>控制索引数量，因为索引虽然可以提高查询速度，但也会影响插入、更新的速度。</li></ul><p>前缀索引：是指对字符串类型（如CHAR、VARCHAR、TEXT）的字段，仅对其前N个字符建立索引，而非整个字段。例如，对VARCHAR(255)字段的前10个字符建立索引。</p><p>索引失效</p><ul><li>没有遵循最左匹配原则。</li><li>使用了模糊查询且%号在前面。</li><li>在索引字段上进行了运算或类型转换。</li><li>使用了复合索引但在中间使用了范围查询，导致右边的条件索引失效。</li></ul><h5 id="explain命令"><a href="#explain命令" class="headerlink" title="explain命令"></a>explain命令</h5><ul><li>possible_key 当前sql可能会用到的索引</li><li>key 当前sql实际命中的索引</li><li>key_len 索引占用的大小</li><li>extra 额外的优化建议<ul><li>using where; using index 查询使用了索引，需要的数据都在索引列中能找到，不需要回表查询数据</li><li>using index condition 查询使用了索引，但是需要回表查询数据</li></ul></li><li>type sql的连接类型，null、system、const、eq_ref、ref、range、index、all<ul><li>null 没有使用到表</li><li>system 查询系统中的表</li><li>const 根据主键查询</li><li>eq_ref 主键索引查询或者唯一索引查询</li><li>ref 索引查询</li><li>range 范围查询</li><li>index 索引树扫描</li><li>all 全表扫描</li></ul></li></ul><h5 id="优化经验"><a href="#优化经验" class="headerlink" title="优化经验"></a>优化经验</h5><ul><li>建表时选择合适的字段类型。</li><li>使用索引，遵循创建索引的原则。</li><li>编写高效的SQL语句，比如避免使用SELECT *，尽量使用UNION ALL代替UNION，以及在表关联时使用INNER JOIN。</li><li>采用主从复制和读写分离提高性能。</li><li>在数据量大时考虑分库分表。</li></ul><h5 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h5><p>脏读、不可重复读、幻读</p><ul><li>缓冲池（Buffer pool）：主内存中的区域，缓存磁盘上经常操作的真实数据，执行增删改查操作的时候，先操作缓冲池中的数据（若缓冲池中没有，则从磁盘中加载并缓存），以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</li><li>数据页：是innodb存储引擎磁盘管理的最小单元，每个页的大小默认为16KB，页中存储的是行数据</li></ul><p><strong>redo log</strong>（记录的是物理日志）：重做日志，记录的是事务提交时对物理页的物理修改，是用来实现事务的持久性，由重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）组成，前者在内存中，后者在磁盘中。</p><p>当事务提交后，Buffer pool变化，redo log buffer会记录变化，同时会把所有的修改信息都记录到该日志文件中，用于刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p><p>为什么不把Buffer pool中的数据直接存在对应表磁盘文件ibd文件中呢？因为这个过程io耗时久，由buffer pool交给redo log buffer后，对redo log file的记录是<strong>顺序的磁盘io</strong>，性能高，这种机制又叫WAL（write ahead logging）</p><p>保证了事务的持久性</p><p><strong>undo log</strong>（记录的是逻辑日志）：回滚日志，记录数据被修改前的信息，提供回滚和MVCC</p><ul><li>delete数据的时候，undo log中会记录一条对应的insert记录</li><li>update一条数据时，会记录一条对应相反的update记录</li></ul><p>保证了事务的原子性和一致性</p><h5 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h5><p>隐藏字段</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务id，记录最后操作这条记录的事务id</td></tr><tr><td>DB_ROLL_PTR</td><td>执行这条记录的上一个版本</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td></tr></tbody></table><ul><li>undo log版本链</li></ul><p><strong>readview</strong> </p><ul><li><p>readview 读视图是快照读sql执行时mvcc提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id</p></li><li><p>当前读：读取的是记录的最新版本，读取时还要保证其他事务不能修改当前记录，会对读取的记录加锁，比如select … lock in share mode(共享锁)、select … for update、insert、update、delete(排他锁)都是一种当前读</p></li><li><p>快照读：简单的select，不加锁，读取的是可见版本，有可能是历史数据，非阻塞读</p><ul><li>读已提交：每次select 都生成一个快照读</li><li>可重复读：开启事务后第一个select语句才是快照读的的地方</li></ul></li></ul><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务id集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务id</td></tr><tr><td>max_trx_id</td><td>预分配事务id，当前最大事务id+1</td></tr><tr><td>creator_trx_id</td><td>readview 创建者的事务id</td></tr></tbody></table><h5 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h5><pre><code class="hljs">核心是binlog文件，记录了所有的ddl（数据定义语言）和dml（数据操纵语言），但不包括select和show语句</code></pre><ul><li>主库事务提交，记录变更到binlog</li><li>从库读取主库binlog，写入到从库的中继日志relay log</li><li>从库重做中继日志中的事件</li></ul><h5 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h5><p>垂直分库：以表为依据，根据业务将不同表拆分到不同库中</p><p>垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中，冷热数据分离，减少io</p><ul><li><p>把不常用的字段单独放在一张表</p></li><li><p>把text、blob等大字段拆分出来放在附表中</p></li></ul><p>水平分库：将一个库的数据拆分到多个库，解决了单库大数据量，高并发的性能瓶颈问题，提高了系统的稳定性和可用性</p><p>路由规则</p><ul><li>根据id节点取模</li><li>按id也就是范围路由</li></ul><p>水平分表：将一个表的数据拆分到多个表中，优化单表数据量过大而产生的性能问题，避免io争抢而减少锁表的几率。</p><p>分库之后的问题：</p><ul><li>分布式事务一致性问题</li><li>跨节点关联查询</li><li>跨节点分页、排序函数</li><li>主键避重</li></ul><p>中间件：sharding-sphere mycat</p><h5 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h5><p>InnoDB 默认工作在自动提交模式（autocommit&#x3D;1），此时每条独立的 SQL 语句（如 INSERT&#x2F;UPDATE&#x2F;DELETE）会被自动包裹在一个隐式事务中。</p><h5 id="死锁排查"><a href="#死锁排查" class="headerlink" title="死锁排查"></a>死锁排查</h5><p>​开启两个事务，对应sql为</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br><span class="hljs-keyword">UPDATE</span> emp <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = &quot;灿2&quot; <span class="hljs-keyword">where</span> id = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">UPDATE</span> `<span class="hljs-keyword">user</span>` <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = &quot;uzii&quot; <span class="hljs-keyword">where</span> id = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br><span class="hljs-keyword">UPDATE</span> `<span class="hljs-keyword">user</span>` <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = &quot;uzii&quot; <span class="hljs-keyword">where</span> id = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">UPDATE</span> emp <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = &quot;灿2&quot; <span class="hljs-keyword">where</span> id = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><ul><li><p>查看&#x2F;开启记录</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;innodb_print_all_deadlocks&#x27;</span>;<br><span class="hljs-keyword">SET</span> GLOBAL <span class="hljs-comment">innodb_print_all_deadlocks = 1</span>;<br></code></pre></td></tr></table></figure></li><li><p>查看死锁日志</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">SHOW ENGINE INNODB STATUS<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br></code></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">*** (2) HOLDS THE LOCK(S):</span><br><span class="hljs-comment">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br></code></pre></td></tr></table></figure><p>事务1、2都执行了前两行sql，此时继续往下执行，事务1等待事务2释放user的锁，事务2持有user的锁，同时，等待事务1释放emp表的锁。</p></li></ul><p>​</p><ul><li><p>其他查看日志的方式</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;log_error&#x27;</span>;<br></code></pre></td></tr></table></figure><p>结果为：log_error    stderr</p><p>MySQL 服务器会将错误日志输出到标准错误输出（stderr）</p><p>若想修改，修改配置文件</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 修改my.cnf文件</span><br>log_error = /var/<span class="hljs-built_in">log</span>/mysql/<span class="hljs-keyword">error</span>.<span class="hljs-built_in">log</span><br><br><span class="hljs-comment"># 重启mysql服务</span><br>sudo systemctl restart mysql<br></code></pre></td></tr></table></figure><p>扩展，查找my.cnf位置</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">find</span> -name my.<span class="hljs-keyword">cnf</span><br>./etc/my.<span class="hljs-keyword">cnf</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="Mysql基础"><a href="#Mysql基础" class="headerlink" title="Mysql基础"></a>Mysql基础</h3><p>关系型数据库(RDBMS):建立在关系模型基础上，由多张相互连接的二维表组成的数据库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">使用表存储数据，格式统一，便于维护<br>使用<span class="hljs-keyword">sql</span>语言操作，标准统一，使用方便，可用于复杂查询<br></code></pre></td></tr></table></figure><p>创建数据库</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> dbname;<br></code></pre></td></tr></table></figure><p>mysql数据库的sql语句不区分大小写；</p><p>SQL分类</p><table><thead><tr><th>分类</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>用来定义数据库对象(数据库，表，字段)</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>用来对数据库表中的数据进行增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>用来查询数据库表中额数据</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>用来创建数据库用户、控制数据库的访问权限</td></tr></tbody></table><h5 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h5><p>下述语法中，database可以替换成schema。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 查询所有数据库</span><br><span class="hljs-keyword">show</span> databases;<br><br><span class="hljs-meta"># 查询当前数据库</span><br><span class="hljs-built_in">select</span> <span class="hljs-built_in">database</span>();<br><br><span class="hljs-meta"># 查询当前数据库所有表</span><br><span class="hljs-keyword">show</span> tables;<br><br><span class="hljs-meta"># 查询表结构</span><br>desc tableName;<br><br><span class="hljs-meta"># 查询建表语句</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> table tableName;<br><br><span class="hljs-meta"># 使用数据库</span><br><span class="hljs-keyword">use</span> 数据库名;<br><br><span class="hljs-meta"># 创建数据库</span><br><span class="hljs-keyword">create</span> database <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exists dbName;<br><br><span class="hljs-meta"># 删除数据库</span><br><span class="hljs-built_in">drop</span> database <span class="hljs-keyword">if</span> exists dbName;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">create <span class="hljs-selector-tag">table</span> 表名(<br>字段<span class="hljs-number">1</span> 字段类型 <span class="hljs-selector-attr">[约束]</span> <span class="hljs-selector-attr">[comment 注释]</span>,<br>......<br>字段n 字段类型 <span class="hljs-selector-attr">[约束]</span> <span class="hljs-selector-attr">[comment 注释]</span>,<br>)<span class="hljs-selector-attr">[comment 注释]</span>;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 添加字段<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> 字段名 类型(长度) [<span class="hljs-keyword">comment</span> 注释] [约束];<br><br># 修改字段类型<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify 字段名 新数据类型(长度);<br><br># 修改字段名和字段类型<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 change 旧字段名 新字段名 类型(长度) [<span class="hljs-keyword">comment</span> 注释] [约束];<br><br># 删除字段<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> 字段名;<br><br># 修改表名<br><span class="hljs-keyword">rename</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">to</span> 新表名;<br><br># 删除表（表中的全部数据也会被删除）<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> [<span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span>] 表名;<br></code></pre></td></tr></table></figure><p>约束</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">目的：为了保证数据库中数据的正确性、有效性和完整性<br>概念：作用与表中字段上的规则，用于限制存储在表中的数据.<br></code></pre></td></tr></table></figure><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段值不能为null</td><td>not null</td></tr><tr><td>唯一约束</td><td>保证字段的所有数据都是唯一、不重复的</td><td>unique</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>primary key</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段值，则采用默认值</td><td>default</td></tr><tr><td>外键约束</td><td>让两张表的数据建立连接，保证数据的一致性和完整性</td><td>foreign key</td></tr></tbody></table><p>数值类型、字符串类型、日期时间类型</p><p>tinyint unsigned 无符号</p><p>char 定长字符串  性能高(无需判断长度) 浪费空间</p><p>varchar 变长字符串 性能低() 节省空间</p><table><thead><tr><th>类型</th><th>大小(byte)</th><th>格式</th></tr></thead><tbody><tr><td>date</td><td>3</td><td>YYYY-MM-DD</td></tr><tr><td>time</td><td>3</td><td>HH:MM:SS</td></tr><tr><td>year</td><td>1</td><td>YYYY</td></tr><tr><td>datetime</td><td>8</td><td>YYYY-MM-DD HH:MM:SS</td></tr><tr><td>timestamp(有限制)</td><td>4</td><td>YYYY-MM-DD HH:MM:SS</td></tr></tbody></table><h5 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 指定字段添加数据</span><br><span class="hljs-attribute">insert</span> into table 表名(字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>) values (值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>);<br><br><span class="hljs-comment"># 全部字段添加数据</span><br><span class="hljs-attribute">insert</span> into table 表名 values (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br><br><span class="hljs-comment"># 批量添加数据</span><br><span class="hljs-attribute">insert</span> into 表名(字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>) values (值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>), (值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>);<br><span class="hljs-attribute">insert</span> into table 表名 values (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure><ul><li><p>插入数据时，顺序要一一对应</p></li><li><p>字符串和日期型数据应该包含在引号中</p></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 更新满足条件的数据</span><br><span class="hljs-attribute">update</span> 表名 set 字段<span class="hljs-number">1</span> = 值<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span> = 值<span class="hljs-number">2</span>, ...<span class="hljs-meta"> [where 条件];</span><br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-comment"># 删除满足条件的数据</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 [where 条件];<br><br><span class="hljs-comment"># 删除所有数据</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名; <br></code></pre></td></tr></table></figure><ul><li>delete语句不能删除某一个字段的值，可以使用update将该字段的值设置为null;</li></ul><p><a href="https://pcmsuat.dcpc.com/zbtest-SH-PUB/pdf/formConfig">https://pcmsuat.dcpc.com/zbtest-SH-PUB/pdf/formConfig</a></p><p>DQL</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span><br>字段列表<br><span class="hljs-keyword">from</span><br>表名列表<br><span class="hljs-keyword">where</span> <br>条件列表<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <br>分组字段列表<br><span class="hljs-keyword">having</span><br>分组后条件列表<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br>排序字段列表<br><span class="hljs-keyword">limit</span><br>分页参数<br></code></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> 字段<span class="hljs-number">1</span> [<span class="hljs-keyword">as</span> 别名<span class="hljs-number">1</span>], 字段<span class="hljs-number">2</span> [<span class="hljs-keyword">as</span> 别名<span class="hljs-number">2</span>] <span class="hljs-keyword">from</span> 表名;<br><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> 字段列表 <span class="hljs-keyword">from</span> 表名；<br></code></pre></td></tr></table></figure><h6 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h6><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于</td></tr><tr><td>between … and …</td><td>在某个范围之内（含最小、最大值）</td></tr><tr><td>in(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>like 占位符</td><td>模糊匹配(_匹配单个字符，&amp;匹配任意个字符)</td></tr><tr><td>is null</td><td>是null</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>and 或 &amp;&amp;</td><td>且</td></tr><tr><td>or 或 ||</td><td>或</td></tr><tr><td>not 或 !</td><td>非</td></tr></tbody></table><h6 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h6><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">介绍：将一列数据作为一个整体，进行纵向计算<br>语法：<span class="hljs-keyword">select</span> 聚合函数(字段列表) <span class="hljs-keyword">from</span> 表名;<br>注意：聚合函数不对<span class="hljs-literal">null</span>值进行计算<br></code></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>count(字段)  </p><p>count(常量)：count(0)、count(1)、count(a)这三种效果都是一样的</p><p>count( * )：求取表的总数据量，<em>“</em>”代表统配，mysql底层专门做了适配，推荐使用。</p><p>sum(字符串列)，我试了，mysql5返回的是0;</p><h6 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h6><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> 字段列表 <span class="hljs-keyword">from</span> 表名 [<span class="hljs-keyword">where</span> 条件] <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段名 [<span class="hljs-keyword">having</span> 分组后过滤条件]<br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># 会报错，分组后，是一组组数据，只能select 分组字段 或者 使用聚合函数</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;<br><span class="hljs-meta"># 正确使用</span><br><span class="hljs-keyword">select</span> gender, COUNT(*) <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;<br></code></pre></td></tr></table></figure><p>使用HAVING对分组后的数据进行条件过滤</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">SELECT</span><br>job,<br>COUNT<span class="hljs-comment">(*) </span><br><span class="hljs-comment">FROM</span><br><span class="hljs-comment">tb_emp </span><br><span class="hljs-comment">WHERE</span><br><span class="hljs-comment">entrydate &lt;= &#x27;2015-01-01&#x27; </span><br><span class="hljs-comment">GROUP BY</span><br><span class="hljs-comment">job</span><br><span class="hljs-comment">HAVING COUNT(*)</span>&gt; <span class="hljs-number">1</span><span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><p>where和having的区别</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">执行时机不同；<span class="hljs-keyword">where</span>是对分组之前进行过滤，不满足<span class="hljs-keyword">where</span>条件，不参与分组;而<span class="hljs-keyword">having</span>是分组后对结果进行过滤。<br>判断条件不同：<span class="hljs-keyword">where</span>不能对聚合函数进行判断，而<span class="hljs-keyword">having</span>可以<br></code></pre></td></tr></table></figure><p>注意事项</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。<br>执行顺序：<span class="hljs-keyword">where</span> &gt; 聚合函数 &gt; <span class="hljs-keyword">having</span><br></code></pre></td></tr></table></figure><h6 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h6><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> 字段列表 <span class="hljs-keyword">from</span> 表名 [<span class="hljs-keyword">where</span> 条件] <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段名 [<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 字段<span class="hljs-number">1</span> 排序方式<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span> 排序方式<span class="hljs-number">2.</span>.....]<br></code></pre></td></tr></table></figure><p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">排序方式<br><span class="hljs-symbol">ASC:</span>升序 默认<br><span class="hljs-symbol">DESC:</span>降序<br></code></pre></td></tr></table></figure><h6 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h6><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> 字段列表 <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">limit</span> 起始索引, 查询记录数;<br></code></pre></td></tr></table></figure><p>注意点：</p><ul><li>起始索引从0开始，起始索引 &#x3D; (页码 - 1) * 每页展示记录数</li><li>如果查询的是第一页数据，起始索引可以忽略，limit 10</li><li>不同数据库不同实现，mysql是limit</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 第一页</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp limit <span class="hljs-number">0</span>,<span class="hljs-number">5</span>;<br><span class="hljs-comment">// 第二页</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp limit <span class="hljs-number">5</span>,<span class="hljs-number">5</span>;<br><span class="hljs-comment">// 第三页</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp limit <span class="hljs-number">10</span>,<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h6 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># <span class="hljs-keyword">if</span> (条件表达式, <span class="hljs-keyword">true</span>取值, <span class="hljs-keyword">false</span>取值)<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">IF</span>(gender = <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;man&#x27;</span>, <span class="hljs-string">&#x27;women&#x27;</span>) [<span class="hljs-keyword">as</span>] 性别, COUNT(*) <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> gender;<br><br>结果<br>man<span class="hljs-number">24</span><br>women<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">case</span> 表达式 <span class="hljs-keyword">when</span>  值<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 结果<span class="hljs-number">1</span> <span class="hljs-keyword">when</span> 值<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 结果<span class="hljs-number">2</span> ... else... <span class="hljs-keyword">end</span><br><span class="hljs-keyword">SELECT</span><br>( <span class="hljs-keyword">CASE</span> job <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;班主任&#x27;</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;讲师&#x27;</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;学工主管&#x27;</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-number">4</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;教研主管&#x27;</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;未分配职位&#x27;</span> <span class="hljs-keyword">END</span> ) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;职位&#x27;</span> <br><span class="hljs-keyword">FROM</span><br>tb_emp;<br><br><br></code></pre></td></tr></table></figure><h5 id="多表设计"><a href="#多表设计" class="headerlink" title="多表设计"></a>多表设计</h5><h6 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h6><p>为了保证数据的一致性和完整性</p><p>外键约束</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sas">-- 创建表时指定<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(<br>字段名    数据类型,<br>...<br>[constraint]   [外键名称]  <span class="hljs-keyword">foreign</span>  <span class="hljs-keyword">key</span> (外键字段名)   <span class="hljs-keyword">references</span>   主表 (字段名)<br>);<br>-- 建完表后，添加外键<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span>  表名  <span class="hljs-keyword">add</span> constraint  外键名称  <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span> (外键字段名) <span class="hljs-keyword">references</span>  主表(字段名);<br></code></pre></td></tr></table></figure><ul><li>物理外键</li></ul><p>概念：使用 foreign key 定义外键关联另外一张表。</p><p>缺点：影响增、删、改的效率（需要检查外键关系）。</p><p>仅用于单节点数据库，不适用与分布式、集群场景。</p><p>容易引发数据库的死锁问题，消耗性能。</p><ul><li>逻辑外键</li></ul><p>概念：在业务层逻辑中，解决外键关联。</p><p>通过逻辑外键，就可以很方便的解决上述问题。</p><h6 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h6><p>案例: 用户 与 身份证信息 的关系</p><p>关系: 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以提升操作效率</p><p>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(unique)</p><h6 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h6><p>案例: 学生 与 课程的关系</p><p>关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择</p><p>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h5 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h5><p>多表查询: 指从多张表中查询数据</p><p>笛卡尔积: 笛卡尔乘积是指在数学中，两个集合(A集合 和 B集合)的所有组合情况。(在多表查询时，需要消除无效的笛卡尔积)</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># 笛卡尔积</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp, tb_dept;<br><br><span class="hljs-meta"># 添加条件，消除无效的笛卡尔积</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp, tb_dept <span class="hljs-keyword">where</span> tb_emp.dept_id = tb_dept.id;<br></code></pre></td></tr></table></figure><ul><li><p>连接查询</p><ul><li>内连接：相当于查询A、B交集部分数据</li><li>外连接<ul><li>左外连接：查询左表所有数据(包括两张表交集部分数据)</li><li>右外连接：查询右表所有数据(包括两张表交集部分数据)</li></ul></li></ul></li><li><p>子查询</p></li></ul><h6 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h6><p>隐式内连接：select  字段列表   from   表1 , 表2   where   条件 … ;</p><p>显式内连接：select  字段列表   from   表1  [ inner ]  join 表2  on  连接条件 … ;</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"># 报错，起了别名后，需要使用别名<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp <span class="hljs-built_in">e</span>, tb_dept d <span class="hljs-keyword">WHERE</span> tb_emp.dept_id = d.id;<br><span class="hljs-keyword">select</span> tb_emp.name <span class="hljs-keyword">from</span> tb_emp <span class="hljs-built_in">e</span>, tb_dept d <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br># 正确<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.name <span class="hljs-keyword">from</span> tb_emp <span class="hljs-built_in">e</span>, tb_dept d <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br></code></pre></td></tr></table></figure><h6 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h6><p>左外连接：select  字段列表   from   表1  left  [ outer ]  join 表2  on 连接条件 … ;</p><p>右外连接：select  字段列表   from   表1  right  [ outer ]  join 表2  on  连接条件 … ;</p><h6 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h6><p>介绍：SQL语句中嵌套select语句，称为嵌套查询，又称子查询。</p><p>形式：select  *  from   t1   where  column1 &#x3D;  ( select  column1  from  t2  … );</p><p>子查询外部的语句可以是insert &#x2F; update &#x2F; delete &#x2F; select 的任何一个，最常见的是 select。</p><ul><li><p>标量子查询：子查询返回的结果为单个值</p><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式常用的操作符：&#x3D;   &lt;&gt;    &gt;     &gt;&#x3D;     &lt;    &lt;&#x3D;   </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> dept_id = (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;教研部&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>列子查询：子查询返回的结果为一列</p><p>子查询返回的结果是一列（可以是多行）常用的操作符：in  、not in等</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;教研部&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;咨询部&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>行子查询：子查询返回的结果为一行</p><p>子查询返回的结果是一行（可以是多列）。常用的操作符：&#x3D;  、&lt;&gt; 、in 、not  in</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> (entrydate, job) = (<span class="hljs-keyword">select</span> entrydate, job <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;韦一笑&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>表子查询：子查询返回的结果为多行多列</p><p>子查询返回的结果是多行多列，常作为临时表常用的操作符：in</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"># 不过滤空值<br><span class="hljs-keyword">select</span> emp.name, tb_dept.name <span class="hljs-keyword">from</span> tb_dept <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> entrydate &gt; <span class="hljs-string">&#x27;2006-01-01&#x27;</span>)  emp <span class="hljs-keyword">on</span> emp.dept_id = tb_dept.id;<br># 过滤空值<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.*, d.name <span class="hljs-keyword">from</span>  (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> entrydate &gt; <span class="hljs-string">&#x27;2006-01-01&#x27;</span>) <span class="hljs-built_in">e</span>, tb_dept d <span class="hljs-keyword">where</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br></code></pre></td></tr></table></figure></li></ul><h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>事务 是一组操作的集合，它是一个不可分割的工作单位。</p><p>事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作 要么同时成功，要么同时失败。</p><p>默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。</p><p>开启事务：start transaction;  &#x2F;  begin ;</p><p>提交事务：commit;</p><p>回滚事务：rollback;</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">start transaction<span class="hljs-comment">;</span><br>sql1<span class="hljs-comment">;</span><br>sql2<span class="hljs-comment">;</span><br>commit<span class="hljs-comment">;</span><br>rollback<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>四大特性</p><p>原子性：事务是不可分割的最小单元，要么全部成功，要么全部失败</p><p>一致性：事务完成时，必须使所有的数据都保持一致状态</p><p>隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</p><p>持久性：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</p><h5 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h5><p>索引（index）是帮助数据库 高效获取数据 的 数据结构 。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_sku_sn <span class="hljs-keyword">on</span> tb_sku(sn);<br></code></pre></td></tr></table></figure><p>优点：</p><p>​提高数据查询的效率，降低数据库的IO成本。</p><p>​通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗。</p><p>缺点：</p><p>​索引会占用存储空间。</p><p>​索引大大提高了查询效率，同时却也降低了insert、update、delete的效率。</p><p>结构</p><p>​MySQL数据库支持的索引结构有很多，如：Hash索引、B+Tree索引、Full-Text索引等。我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。</p><p>问题1：为什么不用二叉搜索树或者红黑树</p><p>​大数据量情况下，层级深，检索速度慢。</p><p>B+Tree(多路平衡搜索树)</p><p>每一个节点，可以存储多个key（有n个key，就有n个指针）。</p><p>所有的数据都存储在叶子节点，非叶子节点仅用于索引数据。</p><p>叶子节点形成了一颗双向链表，便于数据的排序及区间范围查询。</p><p>create  [ unique ]  index 索引名 on  表名 (字段名,… ) ;</p><p>show  index  from  表名;</p><p>drop  index  索引名  on  表名;</p><p>主键字段，在建表时，会自动创建主键索引。</p><p>添加唯一约束时，数据库实际上会添加唯一索引。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机备份</title>
    <link href="/2025/04/27/%E8%99%9A%E6%8B%9F%E6%9C%BA/vmware/%E5%A4%87%E4%BB%BD/"/>
    <url>/2025/04/27/%E8%99%9A%E6%8B%9F%E6%9C%BA/vmware/%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="一、直接复制文件夹"><a href="#一、直接复制文件夹" class="headerlink" title="一、直接复制文件夹"></a>一、直接复制文件夹</h3><ul><li><p>右键虚拟机，打开所在目录，备份此目录内容</p></li><li><p>在新环境下的vmware文件，选择打开虚拟机，选择刚刚目录下的vmx文件即可</p></li></ul><h3 id="二、通过虚拟机导入导出"><a href="#二、通过虚拟机导入导出" class="headerlink" title="二、通过虚拟机导入导出"></a>二、通过虚拟机导入导出</h3><ul><li><p>文件-&gt;导出为OVF文件</p></li><li><p>打开-&gt;选择OVF文件</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>虚拟机</category>
      
      <category>vmware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备份</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows命令行操作</title>
    <link href="/2025/04/24/windows/cmd/"/>
    <url>/2025/04/24/windows/cmd/</url>
    
    <content type="html"><![CDATA[<h5 id="测试网络是否联通"><a href="#测试网络是否联通" class="headerlink" title="测试网络是否联通"></a>测试网络是否联通</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ping</span> <span class="hljs-number">39.98.49.95</span><br><span class="hljs-attribute">telnet</span> <span class="hljs-number">39.98.49.95</span> <span class="hljs-number">7700</span> <br></code></pre></td></tr></table></figure><ul><li>查看架构</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">echo</span> %PROCESSOR_ARCHITECTURE%<br>输出 <span class="hljs-meta">ARM</span>：<span class="hljs-meta">ARM</span> 架构。<br>输出 AMD64：x86 架构（AMD 或 Intel 处理器）。<br></code></pre></td></tr></table></figure><h5 id="找出某个端口正在使用的进程"><a href="#找出某个端口正在使用的进程" class="headerlink" title="找出某个端口正在使用的进程"></a>找出某个端口正在使用的进程</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">netstat <span class="hljs-punctuation">-</span>ano <span class="hljs-string">| findstr :8080</span><br></code></pre></td></tr></table></figure><p><strong>根据 PID 查找对应的进程</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">tasklist <span class="hljs-string">| findstr 10156</span><br></code></pre></td></tr></table></figure><h5 id="结束指定-PID-的进程"><a href="#结束指定-PID-的进程" class="headerlink" title="结束指定 PID 的进程"></a><strong>结束指定 PID 的进程</strong></h5><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">taskkill <span class="hljs-string">/F</span> <span class="hljs-string">/PID</span> 1234<br></code></pre></td></tr></table></figure><ul><li><code>/F</code>：表示强制终止进程。</li><li><code>/PID</code>：用于指定要终止的进程的 ID。</li></ul>]]></content>
    
    
    <categories>
      
      <category>windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring使用</title>
    <link href="/2025/04/24/java/spring/Spring%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/04/24/java/spring/Spring%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="如何启动一个springboot项目"><a href="#如何启动一个springboot项目" class="headerlink" title="如何启动一个springboot项目"></a>如何启动一个springboot项目</h2><h5 id="1-pom-xml文件"><a href="#1-pom-xml文件" class="headerlink" title="1.pom.xml文件"></a>1.pom.xml文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;project xmlns=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br>         xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>         xsi:schemaLocation=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;<br>    &lt;modelVersion&gt;<span class="hljs-number">4.0</span><span class="hljs-number">.0</span>&lt;/modelVersion&gt;<br><br>    &lt;groupId&gt;org.lzc&lt;/groupId&gt;<br>    &lt;artifactId&gt;web-connect&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">1.0</span>-SNAPSHOT&lt;/version&gt;<br><br>    &lt;parent&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br>        &lt;version&gt;<span class="hljs-number">2.2</span><span class="hljs-number">.7</span>.RELEASE&lt;/version&gt;<br>        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;<br>    &lt;/parent&gt;<br><br>    &lt;properties&gt;<br>        &lt;maven.compiler.source&gt;<span class="hljs-number">8</span>&lt;/maven.compiler.source&gt;<br>        &lt;maven.compiler.target&gt;<span class="hljs-number">8</span>&lt;/maven.compiler.target&gt;<br>        &lt;project.build.sourceEncoding&gt;UTF-<span class="hljs-number">8</span>&lt;/project.build.sourceEncoding&gt;<br>    &lt;/properties&gt;<br><br><br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br>            &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br>            &lt;optional&gt;<span class="hljs-literal">true</span>&lt;/optional&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br>  <br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br>                &lt;configuration&gt;<br>                    &lt;excludes&gt;<br>                        &lt;exclude&gt;<br>                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br>                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br>                        &lt;/exclude&gt;<br>                    &lt;/excludes&gt;<br>                &lt;/configuration&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br><br>&lt;/project&gt;<br></code></pre></td></tr></table></figure><h5 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h5><ul><li><p>resources文件夹下添加application.properties配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">spring.application.name=web-connect<br>server.port=<span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure></li><li><p>创建主启动类，类上添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br></code></pre></td></tr></table></figure></li><li><p>主启动类main方法中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SpringApplication.run(主启动类.class, args);<br></code></pre></td></tr></table></figure></li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h5 id="controller与get请求"><a href="#controller与get请求" class="headerlink" title="controller与get请求"></a>controller与get请求</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span> String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Hello %s!&quot;</span>, name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring基础知识</title>
    <link href="/2025/04/24/java/spring/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2025/04/24/java/spring/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>ApplicationContext 、BeanFactory二者都可以获取bean，但是ApplicationContext 更全面，解析配置类，注册beanDefinition。</p><ul><li>实例化bean，早期bean</li><li>属性注入，@Autowried</li><li>初始化前 BeanPostProcessor（postProcessBeforeInitialization）、Aware</li><li>初始化  @PostConstruct 、InitializingBean（afterPropertiesSet）</li><li>初始化后  BeanPostProcessor（postProcessAfterInitialization）</li></ul><p>spring使用class.newInstance()创建对象</p><ul><li><p>默认情况下调用无参构造函数进行构造</p></li><li><p>假如有两个构造函数，也是有无参构造函数优先。</p></li><li><p>没有无参构造函数，有多个有参构造函数，会报错</p></li></ul><h5 id="springmvc的执行流程"><a href="#springmvc的执行流程" class="headerlink" title="springmvc的执行流程"></a>springmvc的执行流程</h5><ul><li><p>视图阶段（老旧jsp等）</p></li><li><p>前后端分离阶段（接口开发、异步）</p></li></ul><h5 id="springboot自动配置原理"><a href="#springboot自动配置原理" class="headerlink" title="springboot自动配置原理"></a>springboot自动配置原理</h5><pre><code class="hljs">Spring Boot的自动配置原理基于@SpringBootApplication注解，它封装了@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan。</code></pre><p>​@EnableAutoConfiguration是核心，它通过@Import导入配置选择器，读取META-INF&#x2F;spring.factories文件中的类名，根据条件注解决定是否将配置类中的Bean导入到Spring容器中。</p><h5 id="nacos和eureka的区别"><a href="#nacos和eureka的区别" class="headerlink" title="nacos和eureka的区别"></a>nacos和eureka的区别</h5><p>共同点：都支持服务注册和服务拉取，都支持服务提供者心跳方式做健康检测</p><p>不同点：</p><ul><li>nacos平时创建的都是临时实例，采用心跳检测，通过配置文件ephemeral控制，如果是非临时实例，nacos会<strong>主动询问</strong>提供者状态是否还存活。</li><li>nacos可以主动推送变更消息到服务消费者</li><li>临时实例不正常会被剔除，非临时实例则不会删除</li><li>nacos集群默认采用ap方式，当集群中存在非临时实例时，采用cp模式; eureka采用ap方式</li><li>nacos还提供了注册中心</li></ul><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>Ribbon，发起远程调用feign就会使用ribbon</p><ul><li>RoundRobinRule：简单的轮询策略。</li><li>WeightedResponseTimeRule：根据响应时间加权选择服务器。</li><li>RandomRule：随机选择服务器。</li><li>ZoneAvoidanceRule：区域感知的负载均衡，优先选择同一区域中可用的服务器。</li></ul><h5 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h5><p>服务雪崩是指一个服务的失败导致整个链路的服务相继失败。我们通常通过服务降级和服务熔断来解决这个问题：</p><ul><li>服务降级：在请求量突增时，主动降低服务的级别，确保核心服务可用。</li><li>服务熔断：当服务调用失败率达到一定阈值时，熔断机制会启动，防止系统过载。</li></ul><p>在Feign客户端启用熔断，定义降级逻辑处理异常：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">&quot;service-name&quot;</span>, fallback = FallbackService.class)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFeignClient</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/endpoint&quot;</span>)<br>    <span class="hljs-keyword">String</span> someMethod();<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">FallbackService</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">MyFeignClient</span></span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> someMethod() &#123;<br>        <span class="hljs-comment">// 返回默认值或抛出降级异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span><span class="hljs-type"></span> ServiceUnavailableException(<span class="hljs-string">&quot;服务暂不可用&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="skywalking"><a href="#skywalking" class="headerlink" title="skywalking"></a>skywalking</h5><p>application performance managment</p><ul><li>服务：微服务</li><li>端点：接口</li><li>实例：物理机</li></ul><h5 id="CAP-和-BASE"><a href="#CAP-和-BASE" class="headerlink" title="CAP 和 BASE"></a>CAP 和 BASE</h5><p>CAP理论是分布式系统设计的基础理论，包含一致性(Consistency)、可用性(Availability)和分区容错性(Partition tolerance)。在网络分区发生时，系统只能在一致性和可用性之间选择其一。</p><ul><li>C：用户访问分布式系统中的任意节点，得到的数据必须一致，即多个节点间数据要及时同步</li><li>A：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或者拒绝</li><li>P：因为网络故障或其他原因导致分布式系统中部分节点与其他节点失去连接，形成独立分区，tolerance是指集群出现分区的时候，整个系统也要持续对外提供服务</li></ul><p>分布式系统节点之间肯定时需要网络连接的，分区是必然存在的</p><p>AP 保证访问的高可用性，可以持续对外提供服务，但不是保证数据的强一致性。</p><p>CP 保证数据的强一致性，放弃高可用性。</p><p>BASE理论是分布式系统设计中对CAP理论中AP方案的延伸，强调通过基本可用、软状态和最终一致性来实现系统设计。</p><h5 id="修改spring默认线程池配置"><a href="#修改spring默认线程池配置" class="headerlink" title="修改spring默认线程池配置"></a>修改spring默认线程池配置</h5><blockquote><p>spring中经常会使用到异步任务，如何修改其线程池配置？</p></blockquote><ul><li>示例，比如事件框架前使用的@EnableAsync(放在任一配置类即可)以及@Async注解</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">xxx</span>&#123;<br>    <span class="hljs-variable">@Async</span><br>    <span class="hljs-variable">@EventListener</span><br>    public void <span class="hljs-built_in">xxx</span>() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>实现AsyncConfigurer即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultAsyncThreadPoolConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AsyncConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getAsyncExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>        <span class="hljs-comment">//核心线程池大小</span><br>        executor.setCorePoolSize(<span class="hljs-number">20</span>);<br>        <span class="hljs-comment">//最大线程数</span><br>        executor.setMaxPoolSize(<span class="hljs-number">150</span>);<br>        <span class="hljs-comment">//队列容量</span><br>        executor.setQueueCapacity(<span class="hljs-number">100</span>);<br>        <span class="hljs-comment">//活跃时间</span><br>        executor.setKeepAliveSeconds(<span class="hljs-number">300</span>);<br>        <span class="hljs-comment">//线程名字前缀</span><br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;DefaultExecutor-&quot;</span>);<br>        <span class="hljs-comment">// setRejectedExecutionHandler：当pool已经达到max size的时候，如何处理新任务</span><br>        <span class="hljs-comment">// CallerRunsPolicy：不在新线程中执行任务，而是由调用者所在的线程来执行</span><br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br>        executor.setWaitForTasksToCompleteOnShutdown(<span class="hljs-literal">true</span>);<br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;cc-async-&quot;</span>);<br>        executor.initialize();<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本人在定时任务中触发的事件框架，事件框架方法处使用的异步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EventListener</span><br><span class="hljs-meta">@Async</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleAutoApproveEvent</span><span class="hljs-params">(TestEvent testEvent)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> testEvent.getInfo();<br>    log.info(info);<br>&#125;<br></code></pre></td></tr></table></figure><p>有个注意的点，异步线程池貌似是懒加载，第一次使用到的时候才会初始化</p><p><img src="/../../../images/Spring_%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1_%E4%BA%8B%E4%BB%B6%E6%A1%86%E6%9E%B6_%E5%BC%82%E6%AD%A5_%E7%BA%BF%E7%A8%8B%E6%B1%A0.png"></p><p>todo，spring自带的线程池和jdk的有什么区别</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="定时任务Schedule跟踪以及afterSingletonsInstantiated、onApplicationEvent-ContextRefreshedEvent-event"><a href="#定时任务Schedule跟踪以及afterSingletonsInstantiated、onApplicationEvent-ContextRefreshedEvent-event" class="headerlink" title="定时任务Schedule跟踪以及afterSingletonsInstantiated、onApplicationEvent(ContextRefreshedEvent event)"></a>定时任务Schedule跟踪以及afterSingletonsInstantiated、onApplicationEvent(ContextRefreshedEvent event)</h5><blockquote><p>spring中经常看到实现一个接口然后修改配置类的情况，此次学习定时任务的时候也发现了，下面来分析下他是如何实现的</p></blockquote><ul><li>代码示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduleConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SchedulingConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureTasks</span><span class="hljs-params">(ScheduledTaskRegistrar scheduledTaskRegistrar)</span> &#123;<br>   scheduledTaskRegistrar.setScheduler(Executors.newScheduledThreadPool(corePoolSize));<br>        scheduledTaskRegistrar.setTaskScheduler(poolScheduler());<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TaskScheduler <span class="hljs-title function_">poolScheduler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolTaskScheduler</span> <span class="hljs-variable">scheduler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskScheduler</span>();<br>        scheduler.setThreadNamePrefix(<span class="hljs-string">&quot;poolScheduler&quot;</span>);<br>        scheduler.setPoolSize(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">return</span> scheduler;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过打断点的方式，网上跟踪代码，发现这段代码实现的接口，是在如下部分被调用的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.beanFactory <span class="hljs-keyword">instanceof</span> ListableBeanFactory) &#123;<br>    Map&lt;String, SchedulingConfigurer&gt; beans = ((ListableBeanFactory)<span class="hljs-built_in">this</span>.beanFactory).getBeansOfType(SchedulingConfigurer.class);<br>    List&lt;SchedulingConfigurer&gt; configurers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(beans.values());<br>    AnnotationAwareOrderComparator.sort(configurers);<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> configurers.iterator();<br><br>    <span class="hljs-keyword">while</span>(var3.hasNext()) &#123;<br>        <span class="hljs-type">SchedulingConfigurer</span> <span class="hljs-variable">configurer</span> <span class="hljs-operator">=</span> (SchedulingConfigurer)var3.next();<br>        configurer.configureTasks(<span class="hljs-built_in">this</span>.registrar);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​其获取了所有实现了SchedulingConfigurer类型的bean，然后依次执行configureTasks方法。</p><ul><li>此方法集成在finishRegistration()中，在afterSingletonsInstantiated和onApplicationEvent中均有调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterSingletonsInstantiated</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.nonAnnotatedClasses.clear();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.applicationContext == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.finishRegistration();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> &#123;<br>    <span class="hljs-keyword">if</span> (event.getApplicationContext() == <span class="hljs-built_in">this</span>.applicationContext) &#123;<br>        <span class="hljs-built_in">this</span>.finishRegistration();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>他们两个的区别</p><table><thead><tr><th>维度</th><th><code>afterSingletonsInstantiated()</code></th><th><code>onApplicationEvent(ContextRefreshedEvent)</code></th></tr></thead><tbody><tr><td><strong>接口类型</strong></td><td><code>SmartInitializingSingleton</code>（Spring 内置）</td><td><code>ApplicationListener</code>（事件监听）</td></tr><tr><td><strong>触发时机</strong></td><td>所有单例 Bean <strong>初始化完成后</strong>立即触发</td><td>整个应用上下文 <strong>刷新完成后</strong>触发</td></tr><tr><td><strong>执行次数</strong></td><td>仅执行 <strong>1 次</strong>（容器启动时）</td><td>可能执行 <strong>多次</strong>（每次上下文刷新时）</td></tr><tr><td><strong>上下文状态</strong></td><td>Bean 已完成实例化和初始化（包括 <code>@PostConstruct</code>）</td><td>整个上下文已刷新，可能包含 Bean 的销毁和重建</td></tr><tr><td><strong>延迟加载 Bean</strong></td><td>不考虑延迟加载 Bean（即使存在也会触发）</td><td>延迟加载 Bean 可能尚未初始化</td></tr></tbody></table><ul><li><p>推荐使用 SmartInitializingSingleton 的场景</p><p>需要确保所有单例 Bean 都已初始化完成（如注册全局拦截器、初始化缓存）。<br>避免多次执行（如加载基础数据到内存）</p></li><li><p>推荐使用 ContextRefreshedEvent 的场景</p><p>需要响应上下文刷新事件（如重新加载配置、重置状态）。<br>在父子上下文环境中，需要区分不同上下文的刷新。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用命令</title>
    <link href="/2025/04/23/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2025/04/23/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h5 id="查找是否存在对应文件"><a href="#查找是否存在对应文件" class="headerlink" title="查找是否存在对应文件"></a>查找是否存在对应文件</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> [文件夹路径] --name <span class="hljs-string">&quot;文件名&quot;</span><br>例如：在当前文件夹下面查找main.dic的文件<br><span class="hljs-built_in">find</span> -name main.dic<br></code></pre></td></tr></table></figure><h5 id="查看文件中包含“xx”的行，上下30行的内容"><a href="#查看文件中包含“xx”的行，上下30行的内容" class="headerlink" title="查看文件中包含“xx”的行，上下30行的内容"></a>查看文件中包含“xx”的行，上下30行的内容</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">grep</span> -B <span class="hljs-number">30</span> -A <span class="hljs-number">30</span> <span class="hljs-string">&quot;xx&quot;</span> filename<br></code></pre></td></tr></table></figure><h5 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h5><ul><li>查看</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">fc-list <span class="hljs-symbol">:lang=zh</span> <br></code></pre></td></tr></table></figure><ul><li>下载</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 步骤1：下载并解压字体压缩包</span><br>wget http:<span class="hljs-regexp">//</span>kkfileview.keking.cn/fonts.zip<br>unzip fonts.zip<br>sudo apt-get install unzip  <span class="hljs-comment"># 应在解压前安装unzip</span><br>sudo apt-get update         <span class="hljs-comment"># 更新软件包列表</span><br><br><span class="hljs-comment"># 步骤2：下载并安装TTF字体</span><br>wget -O <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/fonts/</span>simsun.ttf https:<span class="hljs-regexp">//</span>pfh-file-store.oss-cn-hangzhou.aliyuncs.com/simsun.ttf \<br>&amp;&amp; wget -O <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/fonts/</span>simsun.ttf https:<span class="hljs-regexp">//</span>pfh-file-store.oss-cn-hangzhou.aliyuncs.com/simfang.ttf \<br>&amp;&amp; wget -O <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/fonts/</span>simsun.ttf https:<span class="hljs-regexp">//</span>pfh-file-store.oss-cn-hangzhou.aliyuncs.com/STFANGSO.TTF \<br>&amp;&amp; fc-cache -vf              <span class="hljs-comment"># 刷新字体缓存</span><br>&amp;&amp; fc-list                    <span class="hljs-comment"># 列出已安装字体</span><br></code></pre></td></tr></table></figure><h5 id="tar解压"><a href="#tar解压" class="headerlink" title="tar解压"></a>tar解压</h5><ul><li>格式</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">tar <span class="hljs-selector-attr">[选项]</span> <span class="hljs-selector-attr">[归档文件]</span> <span class="hljs-selector-attr">[源文件/目录]</span><br></code></pre></td></tr></table></figure><ul><li>选项</li></ul><table><thead><tr><th>选项组</th><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>操作模式</td><td><code>-c</code></td><td>创建新的归档文件（<strong>c</strong>reate）。</td></tr><tr><td></td><td><code>-x</code></td><td>从归档文件中提取内容（<strong>e</strong>x<strong>t</strong>ract）。</td></tr><tr><td></td><td><code>-t</code></td><td>列出归档文件的内容（<strong>t</strong>able of contents）。</td></tr><tr><td>文件格式</td><td><code>-z</code></td><td>通过 gzip 压缩 &#x2F; 解压缩（对应 <code>.tar.gz</code> 或 <code>.tgz</code> 文件）。</td></tr><tr><td></td><td><code>-j</code></td><td>通过 bzip2 压缩 &#x2F; 解压缩（对应 <code>.tar.bz2</code> 文件）。</td></tr><tr><td></td><td><code>-J</code></td><td>通过 xz 压缩 &#x2F; 解压缩（对应 <code>.tar.xz</code> 文件）。</td></tr><tr><td>文件操作</td><td><code>-f</code></td><td>指定归档文件的名称（<strong>f</strong>ile），必须紧跟文件名（如 <code>-f archive.tar</code>）。</td></tr><tr><td></td><td><code>-v</code></td><td>显示详细的操作过程（<strong>v</strong>erbose）。</td></tr><tr><td></td><td><code>-C</code></td><td>提取时指定目标目录（<strong>C</strong>hange directory）。</td></tr><tr><td>高级选项</td><td><code>-p</code></td><td>保留文件的权限和属性（<strong>p</strong>reserve permissions）。</td></tr><tr><td></td><td><code>--exclude</code></td><td>排除特定文件或目录（如 <code>--exclude=logs</code>）。</td></tr><tr><td></td><td><code>-P</code></td><td>保留绝对路径（<strong>P</strong>reserve absolute path），可能导致安全风险。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>es部署相关</title>
    <link href="/2025/04/23/docker/es/"/>
    <url>/2025/04/23/docker/es/</url>
    
    <content type="html"><![CDATA[<h3 id="docker部署es"><a href="#docker部署es" class="headerlink" title="docker部署es"></a>docker部署es</h3><h5 id="es部署docker命令"><a href="#es部署docker命令" class="headerlink" title="es部署docker命令"></a>es部署docker命令</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  --name es <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -e <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -v es-data:/usr/share/elasticsearch/data <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -v es-plugins:/usr/share/elasticsearch/plugins <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  --privileged <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  elasticsearch:<span class="hljs-number">7</span>.<span class="hljs-number">12</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>访问如下地址，出现响应即可</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.30.130:9200</span><br></code></pre></td></tr></table></figure><h5 id="Kibana部署docker命令"><a href="#Kibana部署docker命令" class="headerlink" title="Kibana部署docker命令"></a>Kibana部署docker命令</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>--name kibana <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>-e ELASTICSEARCH_HOSTS=http://<span class="hljs-number">192.168.30.130:9200</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>-p <span class="hljs-number">5601</span>:<span class="hljs-number">5601</span>  <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>kibana:<span class="hljs-number">7</span>.<span class="hljs-number">12</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>访问如下地址</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.30.130:5601</span><br></code></pre></td></tr></table></figure><p>出现初始化界面，选择选择<code>Explore on my own</code>之后，进入主页面选择<a href="http://192.168.30.130:5601/app/dev_tools#/">Dev Tools</a></p><h5 id="IK分词器安装"><a href="#IK分词器安装" class="headerlink" title="IK分词器安装"></a>IK分词器安装</h5><ul><li>docker进入es容器</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> es bash<br></code></pre></td></tr></table></figure><ul><li>进入后使用如下连接安装，发现过期了，只能手动下载安装包，安装包从网络获取</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">[root@<span class="hljs-number">4</span>f0ed4099320 bin]<span class="hljs-meta"># elasticsearch-plugin install https:<span class="hljs-comment">//github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip</span></span><br></code></pre></td></tr></table></figure><ul><li>安装包连接</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">通过网盘分享的文件：elasticsearch-analysis-ik-<span class="hljs-number">7.12</span>.<span class="hljs-number">1</span>.jar<br>链接: https:<span class="hljs-regexp">//</span>pan.baidu.com<span class="hljs-regexp">/s/</span><span class="hljs-number">19</span>cKTeNDevnjJxxfIOiTicA?pwd=xqnv 提取码: xqnv<br></code></pre></td></tr></table></figure><p><img src="/../../images/es%E9%83%A8%E7%BD%B2_ik%E5%88%86%E8%AF%8D%E5%99%A8_%E8%B7%AF%E5%BE%84.png"></p><ul><li>下载安装包，复制到docker中</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker cp 待复制文件路径 <span class="hljs-comment">[容器名]</span>:<span class="hljs-comment">[容器内路径]</span><br></code></pre></td></tr></table></figure><ul><li>此处是通过查看挂载卷的方式，直接传输到挂载卷，无需使用docker手动cp</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">volume</span><span class="language-bash"> inspect es-plugins</span><br></code></pre></td></tr></table></figure><ul><li>一切正常后，添加自定义分词，进入config目录，IKAnalyzer.cfg.xml指定了自定义分词读取 ext.dic文件，首先，我们创建一个 ext.dic文件，然后编辑文件，添加分词即可。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> ext.dic<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>es</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务项目-报错记录</title>
    <link href="/2025/04/21/java/%E9%A1%B9%E7%9B%AE/%E9%BB%91%E9%A9%AC%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/04/21/java/%E9%A1%B9%E7%9B%AE/%E9%BB%91%E9%A9%AC%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><h5 id="gateway启动报错"><a href="#gateway启动报错" class="headerlink" title="gateway启动报错"></a>gateway启动报错</h5><p>启动的时候，构造器中找不到对应的类，</p><ul><li>使用命令查看使用到错误类的jar包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plain">mvn dependency:tree -Dincludes=io.projectreactor.netty:reactor-netty<br></code></pre></td></tr></table></figure><ul><li>百度，查找spring微服务之间的版本关系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plain">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E<br></code></pre></td></tr></table></figure><p>最终替换版本解决问题</p><h5 id="maven中nacos自动配置依赖引不进来"><a href="#maven中nacos自动配置依赖引不进来" class="headerlink" title="maven中nacos自动配置依赖引不进来"></a>maven中nacos自动配置依赖引不进来</h5><p>一开始没加版本号，上网查了，特定版本的springcloud，需要指定版本号才行，其父pom中没有此依赖版本配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="IDEA启动报错类找不到，但是代码未提示错误"><a href="#IDEA启动报错类找不到，但是代码未提示错误" class="headerlink" title="IDEA启动报错类找不到，但是代码未提示错误"></a>IDEA启动报错类找不到，但是代码未提示错误</h5><h5 id="IDEA默认配置"><a href="#IDEA默认配置" class="headerlink" title="IDEA默认配置"></a>IDEA默认配置</h5><ul><li>自动编译</li><li>自动引包</li></ul><p><a href="https://zhuanlan.zhihu.com/p/690391225">【IDEA】idea设置默认maven配置, 避免每次设置maven - 知乎</a></p><h5 id="mvn-idea-idea报错"><a href="#mvn-idea-idea报错" class="headerlink" title="mvn idea:idea报错"></a>mvn idea:idea报错</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">For artifact &#123;io.projectreactor.netty:reactor-netty:nul<span class="hljs-variable">l:jar</span>&#125;: The <span class="hljs-keyword">version</span> cannot <span class="hljs-keyword">be</span> <span class="hljs-built_in">empty</span>. <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>项目</category>
      
      <category>黑马微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务项目-黑马商城</title>
    <link href="/2025/04/21/java/%E9%A1%B9%E7%9B%AE/%E9%BB%91%E9%A9%AC%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/"/>
    <url>/2025/04/21/java/%E9%A1%B9%E7%9B%AE/%E9%BB%91%E9%A9%AC%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="网关-gateway部分"><a href="#网关-gateway部分" class="headerlink" title="网关-gateway部分"></a>网关-gateway部分</h3><p>​todo</p><h3 id="nacos部分"><a href="#nacos部分" class="headerlink" title="nacos部分"></a>nacos部分</h3><h5 id="自动配置报错记录"><a href="#自动配置报错记录" class="headerlink" title="自动配置报错记录"></a>自动配置报错记录</h5><p>配置了bootstrap.yaml文件，指定了nacos中的共享配置，但是，本地启动的时候，<br>报错：spring 加载HikariDataSource的时候，如下代码找不到数据库配置导致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HikariDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> (HikariDataSource)DataSourceConfiguration.createDataSource(properties, HikariDataSource.class);<br></code></pre></td></tr></table></figure><p><strong>为什么？</strong></p><p>​一开始以为是这部分的执行顺序在nacos的自动配置之前。</p><p>​先把数据库配置写了一个必要的url在原始配置文件中，结果真的能启动，查看启动日志，发现后续也启动了bootstrap.yaml，但是跑接口的时候发现，启动并没有把我在nacos中的共享配置加载进来。</p><p>​最后实在没办法了，想着总不会是我名字没对上吧，结果还真是，nacos中的配置文件，是我几个月前建立好的共享配置，但是，今天的代码中bootstrap中的共享配置是我直接粘贴的文档内容，还真没对上，有福了，看了半个小时。</p><p>后续问题，在第二个模块中，引入如下依赖的时候，没有指定版本号，但是没报错，项目启动不会启动nacos的自动配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>项目</category>
      
      <category>黑马微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注解使用</title>
    <link href="/2025/04/21/java/spring/%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/04/21/java/spring/%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h5 id="ConditionalOnProperty-根据配置文件决定是否创建类"><a href="#ConditionalOnProperty-根据配置文件决定是否创建类" class="headerlink" title="@ConditionalOnProperty 根据配置文件决定是否创建类"></a>@ConditionalOnProperty 根据配置文件决定是否创建类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(&quot;xdap.sql.connector&quot;)</span><br><span class="hljs-meta">@ConditionalOnProperty(name = &quot;xdap.sql.connector.enable&quot;, havingValue = &quot;true&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApaasSqlConnectorProperties</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">existConnector</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/&quot;</span>;<br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        SqlStringUtil.initExistConnector(existConnector);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h5><p>​用于启用自动配置功能</p><p>该注解通过以下机制实现自动配置：</p><ol><li><p><strong>@Import 注解</strong><br><code>@EnableAutoConfiguration</code> 使用 <code>@Import(AutoConfigurationImportSelector.class)</code> 导入自动配置类。</p></li><li><p><strong>AutoConfigurationImportSelector</strong><br>这是一个实现了 <code>ImportSelector</code> 接口的类，负责加载 <code>META-INF/spring.factories</code> 文件中定义的自动配置类。</p></li><li><p><strong>spring.factories 文件</strong><br>Spring Boot 及各个 Starter 模块在 <code>META-INF/spring.factories</code> 中定义了大量自动配置类，例如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span><br><span class="hljs-string">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\</span><br><span class="hljs-string">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</span><br></code></pre></td></tr></table></figure></li><li><p><strong>条件注解</strong><br>自动配置类中使用了大量条件注解（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>），确保只有在满足特定条件时才会生效。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署github</title>
    <link href="/2025/04/21/hexo/%E9%83%A8%E7%BD%B2github/"/>
    <url>/2025/04/21/hexo/%E9%83%A8%E7%BD%B2github/</url>
    
    <content type="html"><![CDATA[<h5 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">https</span>://hexo.io/zh-cn/docs/<span class="hljs-literal">one</span>-<span class="hljs-keyword">command</span><span class="hljs-title">-deployment</span>.<span class="hljs-title">html</span><br></code></pre></td></tr></table></figure><ol><li><p>安装工具</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure></li><li><p>编辑**_config.yml**配置文件，前置条件，GitHub中创建对应仓库</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> <span class="hljs-params">&lt;repository url&gt;</span> <span class="hljs-meta"># https:<span class="hljs-comment">//bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span></span><br><span class="hljs-symbol">  branch:</span> [branch]<br><span class="hljs-symbol">  message:</span> [message]<br></code></pre></td></tr></table></figure></li><li><p>执行部署命令</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">hexo <span class="hljs-selector-tag">g</span>（生成）<br>hexo d（上传）<br></code></pre></td></tr></table></figure></li><li><p>访问<a href="https://lzc3.github.io/%E5%8D%B3%E5%8F%AF">https://lzc3.github.io/即可</a></p></li></ol><p>Github创建仓库</p><p>1.仓库名固定格式   [用户名]github.io   例如，lzc3.github.io </p><p>2.仓库需要公开</p><p>3.添加readme</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主题替换</title>
    <link href="/2025/04/20/hexo/%E4%B8%BB%E9%A2%98%E6%9B%BF%E6%8D%A2/"/>
    <url>/2025/04/20/hexo/%E4%B8%BB%E9%A2%98%E6%9B%BF%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h5 id="GitHub地址"><a href="#GitHub地址" class="headerlink" title="GitHub地址"></a>GitHub地址</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">https</span>://github.com/fluid-dev/hexo-theme-fluid?<span class="hljs-literal">tab</span>=readme-ov-<span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><h5 id="用户手册"><a href="#用户手册" class="headerlink" title="用户手册"></a>用户手册</h5><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">https:</span>//hexo.fluid-dev.com/docs/guide/#<span class="hljs-variable">%E5</span><span class="hljs-variable">%85</span><span class="hljs-variable">%B3</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%87</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%97</span><br></code></pre></td></tr></table></figure><h5 id="自定义配置修改"><a href="#自定义配置修改" class="headerlink" title="自定义配置修改"></a>自定义配置修改</h5><p>​修改_config.fluid.yml文件内容</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">slogan：<br><span class="hljs-built_in">text</span>：界面主题介绍文字<br></code></pre></td></tr></table></figure><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">navbar:</span><br>blog_title：导航栏左侧文字<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>主题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo</title>
    <link href="/2025/04/20/hexo/use/"/>
    <url>/2025/04/20/hexo/use/</url>
    
    <content type="html"><![CDATA[<h5 id="hexo使用文档"><a href="#hexo使用文档" class="headerlink" title="hexo使用文档"></a>hexo使用文档</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://hexo.io/zh-cn/docs/commands<br></code></pre></td></tr></table></figure><h5 id="新建md文件"><a href="#新建md文件" class="headerlink" title="新建md文件"></a>新建md文件</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">npx hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> <span class="hljs-comment">--path hexo/use &quot;使用hexo&quot;</span><br>npx hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> <span class="hljs-comment">--path hexo/主题替换 &quot;主题替换&quot;</span><br>npx hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> <span class="hljs-comment">--path java/spring/基础知识 &quot;spring基础知识&quot;</span><br></code></pre></td></tr></table></figure><h5 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">npx hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">npx hexo s</span><br></code></pre></td></tr></table></figure><h5 id="常用的格式"><a href="#常用的格式" class="headerlink" title="常用的格式"></a>常用的格式</h5><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">categories:<br>  - [Java, spring]<br>  - [Java, 项目]<br><span class="hljs-keyword">tags:</span><br>  - 注解<br>  - 报错<br></code></pre></td></tr></table></figure><h5 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h5><ul><li>在hexo项目根目录下安装上传本地图片插件</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save<br></code></pre></td></tr></table></figure><ul><li>绝对路径引用</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[]</span>(../images/xx.png)<br></code></pre></td></tr></table></figure><ul><li>相对路径本地引用，修改hexo目录下的配置文件_config.yml中</li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/qq_43401552/article/details/104805466">https://blog.csdn.net/qq_43401552/article/details/104805466</a></p><h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><ul><li>区分source下的post、自定义、draft模式</li><li>自定义主题<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid: :ocean: 一款 Material Design 风格的 Hexo 主题 &#x2F; An elegant Material-Design theme for Hexo</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/04/20/hello-world/"/>
    <url>/2025/04/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p><img src="/../images/test1.png"></p><p>jetcache</p><p><a href="https://github.com/alibaba/jetcache/blob/master/docs/CN/Readme.md">jetcache&#x2F;docs&#x2F;CN&#x2F;Readme.md at master · alibaba&#x2F;jetcache</a></p><p>clash-狗狗加速</p><p>用户名can</p><p>邮箱<a href="mailto:&#51;&#x33;&#51;&#x35;&#x32;&#x32;&#53;&#55;&#x39;&#50;&#x40;&#113;&#x71;&#x2e;&#99;&#x6f;&#109;">3335225792@qq.com</a></p><p>密码：1378925436a.</p><p><a href="https://clashv2ray-hub.github.io/">Clashv2ray-hub | 免费公益V2ray&#x2F;SSR&#x2F;Clash节点订阅链接地址分享</a></p><h5 id="Google账号"><a href="#Google账号" class="headerlink" title="Google账号"></a>Google账号</h5><p><a href="mailto:&#x7a;&#x68;&#x61;&#111;&#99;&#x61;&#110;&#108;&#x69;&#51;&#51;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;">zhaocanli33@gmail.com</a></p><p>密码：1378925436a.<br>辅助邮箱：<a href="mailto:&#x31;&#x33;&#x37;&#56;&#x39;&#50;&#53;&#x34;&#x33;&#x36;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#109;">1378925436@qq.com</a></p><p>window11 任务栏透明主题</p><p>TranslucentTB</p><p>edge扩展</p><p>itab</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
